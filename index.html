
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Helix Point Drop - Telegram Mini App</title> <!-- Removed (Supabase Debug) for production feel -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-gradient-start: #0a0a1a;
            --bg-gradient-end: #111122;
            --bg-header-bar: rgba(10, 10, 25, 0.85);
            --bg-ui-panel: rgba(15, 15, 35, 0.9);
            --bg-overlay: rgba(11, 11, 34, 0.98);
            --bg-menu: rgba(20, 20, 45, 0.97);
            --bg-modal: rgba(15, 15, 35, 0.95);
            --bg-input: rgba(255, 255, 255, 0.08);
            --bg-select: var(--bg-input);
            --bg-button-info: #00cfde;
            --bg-button-info-hover: #00b3bf;
            --bg-button-action: #ff4081;
            --bg-button-action-hover: #d81b60;
            --bg-button-special: #f5d131;
            --bg-button-special-hover: #dbc02b;
            --bg-button-watch-ad: #4CAF50;
            --bg-button-watch-ad-hover: #45a049;
            --bg-button-x: #000000;
            --bg-button-x-hover: #333333;
            --bg-toggle-track: #555;
            --bg-toggle-track-active: var(--accent-cyan);
            --bg-link-button: rgba(255, 255, 255, 0.05);
            --bg-link-button-hover: rgba(255, 255, 255, 0.1);
            --bg-copy-button: rgba(255, 255, 255, 0.1);
            --bg-copy-button-hover: rgba(255, 255, 255, 0.2);
            --bg-difficulty-button: rgba(255, 255, 255, 0.08);
            --bg-difficulty-button-active: var(--accent-cyan);
            --bg-difficulty-button-hover: rgba(255, 255, 255, 0.15);
            --bg-initial-controls: rgba(15, 15, 35, 0.92);
            --bg-withdrawal-section: rgba(255, 255, 255, 0.03);
            --bg-accordion-header: rgba(255, 255, 255, 0.05);
            --bg-accordion-header-hover: rgba(255, 255, 255, 0.1);
            --bg-accordion-content: rgba(255, 255, 255, 0.02);
            --bg-history-item: rgba(255, 255, 255, 0.04);


            --text-light: #ffffff;
            --text-medium: #cccccc;
            --text-dark: #111122;
            --text-link: var(--accent-cyan);
            --text-link-hover: var(--accent-cyan-hover);
            --text-heading-accent: var(--accent-yellow);
            --text-error: var(--accent-pink);
            --text-placeholder: rgba(255, 255, 255, 0.4);
            --text-copy-button: var(--text-medium);
            --text-copy-button-hover: var(--text-light);
            --text-difficulty-button: var(--text-medium);
            --text-difficulty-button-active: var(--text-dark);
            --text-label: var(--text-medium);
            --text-accordion-header: var(--text-light);
            --text-history-status-pending: var(--accent-yellow);
            --text-history-status-completed: #4CAF50;
            --text-history-status-rejected: var(--accent-pink);


            --border-color: rgba(255, 255, 255, 0.15);
            --border-input: rgba(255, 255, 255, 0.15);
            --border-select: var(--border-input);
            --border-menu-item: rgba(255, 255, 255, 0.1);
            --border-link-button: rgba(255, 255, 255, 0.1);
            --border-copy-button: rgba(255, 255, 255, 0.2);
            --border-difficulty-button: rgba(255, 255, 255, 0.15);
            --border-initial-controls: rgba(255, 255, 255, 0.1);
            --border-withdrawal-section: rgba(255, 255, 255, 0.1);
            --border-accordion: rgba(255, 255, 255, 0.1);
            --border-history-item: rgba(255, 255, 255, 0.08);


            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-header-bar: 0 3px 12px var(--shadow-color);
            --shadow-panel: 0 6px 20px var(--shadow-color);
            --shadow-modal: 0 8px 25px var(--shadow-color);
            --shadow-button: 0 2px 5px rgba(0, 0, 0, 0.2);
            --shadow-button-hover: 0 4px 8px rgba(0, 0, 0, 0.25);
            --shadow-initial-controls: 0 6px 20px var(--shadow-color);

            --backdrop-blur: 4px;
            --backdrop-blur-heavy: 6px;

            --accent-cyan: #00cfde;
            --accent-cyan-hover: #00b3bf;
            --accent-pink: #ff4081;
            --accent-pink-hover: #d81b60;
            --accent-yellow: #f5d131;
            --accent-yellow-hover: #dbc02b;
            --danger-glow: #cc8400;
            --danger-color: var(--accent-yellow);
            --ball-color: var(--accent-pink);
            --pole-color: #679b31;
            --star-color: #aaaaee;
            --x-color: #000000;
            --x-color-hover: #333333;

            --menu-width: 260px;
            --transition-speed: 0.4s;
            --transition-timing: ease;
        }

        body.light-mode {
            --bg-gradient-start: #87CEEB;
            --bg-gradient-end: #FFB347;
            --bg-gradient-stop: #FF6F61;
            --bg-header-bar: rgba(255, 255, 255, 0.85);
            --bg-ui-panel: rgba(255, 255, 255, 0.9);
            --bg-overlay: rgba(245, 245, 250, 0.98);
            --bg-menu: rgba(250, 250, 255, 0.97);
            --bg-modal: rgba(250, 250, 255, 0.95);
            --bg-input: rgba(0, 0, 0, 0.05);
            --bg-select: var(--bg-input);
            --bg-button-info: #00a8b5;
            --bg-button-info-hover: #008a96;
            --bg-button-action: #e91e63;
            --bg-button-action-hover: #c2185b;
            --bg-button-special: #fbc02d;
            --bg-button-special-hover: #f9a825;
            --bg-button-watch-ad: #8BC34A;
            --bg-button-watch-ad-hover: #7CB342;
            --bg-button-x: #333333;
            --bg-button-x-hover: #555555;
            --bg-toggle-track: #ccc;
            --bg-toggle-track-active: var(--accent-cyan);
            --bg-link-button: rgba(0, 0, 0, 0.03);
            --bg-link-button-hover: rgba(0, 0, 0, 0.06);
            --bg-copy-button: rgba(0, 0, 0, 0.05);
            --bg-copy-button-hover: rgba(0, 0, 0, 0.1);
            --bg-difficulty-button: rgba(0, 0, 0, 0.05);
            --bg-difficulty-button-active: var(--accent-cyan);
            --bg-difficulty-button-hover: rgba(0, 0, 0, 0.1);
            --bg-initial-controls: rgba(250, 250, 255, 0.92);
            --bg-withdrawal-section: rgba(0, 0, 0, 0.03);
            --bg-accordion-header: rgba(0, 0, 0, 0.03);
            --bg-accordion-header-hover: rgba(0, 0, 0, 0.06);
            --bg-accordion-content: rgba(0,0,0,0.01);
            --bg-history-item: rgba(0, 0, 0, 0.02);


            --text-light: #212121;
            --text-medium: #555555;
            --text-dark: #ffffff;
            --text-link: var(--accent-cyan);
            --text-link-hover: var(--accent-cyan-hover);
            --text-heading-accent: #ff8f00;
            --text-error: var(--accent-pink);
            --text-placeholder: rgba(0, 0, 0, 0.4);
            --text-copy-button: var(--text-medium);
            --text-copy-button-hover: var(--text-light);
            --text-difficulty-button: var(--text-medium);
            --text-difficulty-button-active: var(--text-light);
            --text-label: var(--text-medium);
            --text-accordion-header: var(--text-light);
            --text-history-status-pending: var(--accent-yellow-hover);
            --text-history-status-completed: #45a049;
            --text-history-status-rejected: var(--accent-pink-hover);

            --border-color: rgba(0, 0, 0, 0.1);
            --border-input: rgba(0, 0, 0, 0.15);
            --border-select: var(--border-input);
            --border-menu-item: rgba(0, 0, 0, 0.08);
            --border-link-button: rgba(0, 0, 0, 0.1);
            --border-copy-button: rgba(0, 0, 0, 0.15);
            --border-difficulty-button: rgba(0, 0, 0, 0.1);
            --border-initial-controls: rgba(0, 0, 0, 0.1);
            --border-withdrawal-section: rgba(0, 0, 0, 0.1);
            --border-accordion: rgba(0, 0, 0, 0.1);
            --border-history-item: rgba(0, 0, 0, 0.05);


            --shadow-color: rgba(0, 0, 0, 0.1);
            --shadow-header-bar: 0 3px 12px var(--shadow-color);
            --shadow-panel: 0 6px 20px var(--shadow-color);
            --shadow-modal: 0 8px 25px var(--shadow-color);
            --shadow-button: 0 2px 5px rgba(0, 0, 0, 0.1);
            --shadow-button-hover: 0 4px 8px rgba(0, 0, 0, 0.15);
            --shadow-initial-controls: 0 6px 20px var(--shadow-color);

            --star-color: rgba(170, 170, 238, 0.3);
        }

        * { box-sizing: border-box; }
        html { height: 100%; }
        body {
            margin: 0; overflow: hidden; font-family: 'Poppins', sans-serif;
            background: linear-gradient(180deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 60%, var(--bg-gradient-stop, var(--bg-gradient-end)) 100%);
            color: var(--text-light); touch-action: none; -webkit-user-select: none;
            -ms-user-select: none; user-select: none; height: 100%; min-height: 100%;
            display: flex; flex-direction: column; align-items: center;
            justify-content: flex-start;
            transition: background var(--transition-speed) var(--transition-timing),
                        color var(--transition-speed) var(--transition-timing);
            position: relative;
        }

        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(180deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 60%, var(--bg-gradient-stop, var(--bg-gradient-end)) 100%);
            z-index: 10000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
            opacity: 1; transition: opacity 0.5s ease-out; color: var(--text-light);
        }
        #loading-image {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;
        }
        #loading-text { font-size: 1.1em; font-weight: 400; color: var(--text-medium); margin-bottom: 20px; }
        #loading-bar-container { width: 60%; max-width: 250px; height: 8px; background-color: rgba(255, 255, 255, 0.15); border-radius: 4px; overflow: hidden; position: relative; }
        #loading-bar { width: 100%; height: 100%; position: relative; }
        #loading-bar::before {
            content: ''; position: absolute; top: 0; left: 0; width: 40%; height: 100%;
            background-color: var(--accent-cyan); border-radius: 4px;
            animation: indeterminate-loader 1.8s ease-in-out infinite;
        }
        @keyframes indeterminate-loader {
            0% { left: -40%; width: 40%; }
            50% { left: 50%; width: 60%; }
            100% { left: 100%; width: 40%; }
        }

        #header-bar, #side-menu, #settings-popup, .fullscreen-overlay, .modal, input, button, a.link-button, .score-display, h2, h3, p, #game-canvas, .task-group, .task-item, #referral-list-container, #referral-link-container, #initial-controls-container, #header-timer-display, select, .difficulty-button, .withdrawal-accordion-item, .withdrawal-accordion-header, .withdrawal-accordion-content, .history-item {
            transition: background-color var(--transition-speed) var(--transition-timing),
                         color var(--transition-speed) var(--transition-timing),
                         border-color var(--transition-speed) var(--transition-timing),
                         box-shadow var(--transition-speed) var(--transition-timing),
                         opacity var(--transition-speed) var(--transition-timing),
                         fill var(--transition-speed) var(--transition-timing),
                         display var(--transition-speed) var(--transition-timing),
                         transform var(--transition-speed) var(--transition-timing),
                         max-height 0.3s ease-out;
        }

        #header-bar { padding: 10px 15px 5px 15px; background-color: var(--bg-header-bar); backdrop-filter: blur(var(--backdrop-blur)); color: var(--text-light); z-index: 200; box-shadow: var(--shadow-header-bar); display: flex; flex-direction: column; align-items: center; position: static; border-radius: 0 0 10px 10px; width: 100%; max-width: 500px; margin: 0 auto; flex-shrink: 0; position: relative; }
        #score-wrapper { display: flex; width: 100%; max-width: 350px; justify-content: space-around; align-items: center; padding: 8px 0 4px 0; }
        .score-display { font-size: 1.8em; font-weight: 700; text-shadow: 0 1px 2px var(--shadow-color); text-align: center; color: var(--text-light); }
        .score-label { font-size: 0.55em; display: block; opacity: 0.7; font-weight: 400; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-medium); }

        #initial-controls-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1); width: 90%; max-width: 350px; display: flex; flex-direction: column; align-items: center; padding: 25px 20px; background-color: var(--bg-initial-controls); border: 1px solid var(--border-initial-controls); border-radius: 15px; box-shadow: var(--shadow-initial-controls); z-index: 150; opacity: 1; pointer-events: auto; backdrop-filter: blur(var(--backdrop-blur)); transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s linear 0s; visibility: visible; }
        #initial-controls-container.hidden { opacity: 0; transform: translate(-50%, -50%) scale(0.8); pointer-events: none; visibility: hidden; transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s linear 0.3s; }
        #initial-controls-container h3 { font-size: 1.4em; color: var(--text-heading-accent); margin-top: 0; margin-bottom: 20px; font-weight: 700; }
        #difficulty-options { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; }
        .difficulty-button { padding: 8px 15px; border: 1px solid var(--border-difficulty-button); border-radius: 20px; background-color: var(--bg-difficulty-button); color: var(--text-difficulty-button); font-family: inherit; font-size: 0.9em; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, transform 0.1s ease; }
        .difficulty-button:hover { background-color: var(--bg-difficulty-button-hover); transform: translateY(-1px); }
        .difficulty-button.active { background-color: var(--bg-difficulty-button-active); color: var(--text-difficulty-button-active); border-color: var(--bg-difficulty-button-active); font-weight: 700; }
        #start-game-button { padding: 12px 30px; border: none; border-radius: 8px; background-color: var(--bg-button-special); color: var(--text-dark); font-family: inherit; font-weight: 700; font-size: 1.1em; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; box-shadow: var(--shadow-button); width: 70%; max-width: 250px; text-transform: uppercase; letter-spacing: 1px; }
        #start-game-button:hover:not(:disabled) { background-color: var(--bg-button-special-hover); transform: scale(1.03); box-shadow: var(--shadow-button-hover); }
        #start-game-button:active:not(:disabled) { transform: scale(0.98); }
        #start-game-button:disabled { background-color: #777; color: #bbb; cursor: not-allowed; transform: none; box-shadow: none; }

        #header-timer-display { font-size: 1.6em; font-weight: 700; color: var(--text-heading-accent); margin-top: 5px; margin-bottom: 5px; display: block; opacity: 0; text-shadow: 0 1px 2px var(--shadow-color); transition: opacity 0.3s ease, visibility 0s linear 0.3s, height 0s linear 0.3s; visibility: hidden; height: 0; overflow: hidden; }
        #header-timer-display.visible { opacity: 1; visibility: visible; height: auto; transition: opacity 0.3s ease, height 0s linear 0s, visibility 0s linear 0s; }

        .input-group { margin-bottom: 15px; text-align: left; }
        .input-group label { display: block; margin-bottom: 5px; font-size: 0.9em; font-weight: 600; color: var(--text-label); }
        .input-group input[type="number"], .input-group input[type="text"], .input-group select { display: block; width: 100%; padding: 10px 12px; border: 1px solid var(--border-input); background-color: var(--bg-input); color: var(--text-light); border-radius: 5px; font-family: inherit; font-size: 1em; appearance: none; -webkit-appearance: none; -moz-appearance: none; }
        .input-group input::placeholder { color: var(--text-placeholder); opacity: 1; }
        .input-group select { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23cccccc%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 10px center; background-size: 10px 10px; padding-right: 30px; cursor: pointer; }
        body.light-mode .input-group select { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23555555%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); }

        .modal input[type="number"] { display: block; width: 100%; padding: 10px 12px; margin-bottom: 10px; border: 1px solid var(--border-input); background-color: var(--bg-input); color: var(--text-light); border-radius: 5px; font-family: inherit; font-size: 1em; }
        .modal input::placeholder { color: var(--text-placeholder); opacity: 1; }
        .standard-button { padding: 10px 15px; border: none; border-radius: 5px; background-color: var(--bg-button-info); color: var(--text-dark); font-family: inherit; font-weight: 700; font-size: 1em; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; display: inline-block; margin-top: 5px; }
        .standard-button:hover:not(:disabled) { background-color: var(--bg-button-info-hover); transform: scale(1.03); }
        .standard-button:active:not(:disabled) { transform: scale(0.98); }
        .standard-button.action-button { background-color: var(--bg-button-action); }
        .standard-button.action-button:hover:not(:disabled) { background-color: var(--bg-button-action-hover); }
        .standard-button.special-button { background-color: var(--bg-button-special); }
        .standard-button.special-button:hover:not(:disabled) { background-color: var(--bg-button-special-hover); }
        .standard-button:disabled { background-color: #777; color: #bbb; cursor: not-allowed; transform: none; }

        .icon-button { position: absolute; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--accent-cyan); cursor: pointer; padding: 5px; border-radius: 50%; width: 40px; height: 40px; transition: background-color 0.2s ease, transform 0.2s ease, color 0.2s ease; z-index: 210; display: block; font-size: 24px; line-height: 30px; text-align: center; }
        .icon-button:hover { background-color: rgba(128, 128, 128, 0.1); transform: translateY(-50%) scale(1.1); }
        .icon-button svg { width: 100%; height: 100%; vertical-align: middle; fill: var(--accent-cyan); transition: fill var(--transition-speed) var(--transition-timing); }
        #menu-button { left: 15px; top: 27.5px; }
        #settings-button { right: 15px; top: 27.5px; color: var(--accent-cyan); }
        #side-menu { position: fixed; top: 0; left: calc(var(--menu-width) * -1); width: var(--menu-width); height: 100%; background-color: var(--bg-menu); backdrop-filter: blur(var(--backdrop-blur-heavy)); box-shadow: 4px 0 15px var(--shadow-color); z-index: 400; transition: left var(--transition-speed) cubic-bezier(0.25, 0.8, 0.25, 1), background-color var(--transition-speed) var(--transition-timing); padding: 60px 0 20px 0; display: flex; flex-direction: column; overflow-y: auto; }
        #side-menu.open { left: 0; }
        .menu-item-button { display: block; width: 100%; padding: 15px 25px; text-align: left; background: none; border: none; border-bottom: 1px solid var(--border-menu-item); color: var(--text-light); font-family: inherit; font-size: 1.1em; font-weight: 400; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color var(--transition-speed) var(--transition-timing); }
        .menu-item-button:first-of-type { border-top: 1px solid var(--border-menu-item); }
        .menu-item-button:hover { background-color: rgba(128, 128, 128, 0.08); color: var(--accent-cyan); }
        #settings-popup { display: none; position: absolute; top: 60px; right: 15px; background-color: var(--bg-ui-panel); backdrop-filter: blur(var(--backdrop-blur)); border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; box-shadow: var(--shadow-panel); z-index: 350; min-width: 180px; text-align: left; }
        #settings-popup .setting-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        #settings-popup .setting-item p { margin: 0; font-size: 0.95em; color: var(--text-medium); }
        .theme-switch { position: relative; display: inline-block; width: 50px; height: 26px; flex-shrink: 0; }
        .theme-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-toggle-track); transition: background-color var(--transition-speed) var(--transition-timing); border-radius: 26px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: transform var(--transition-speed) var(--transition-timing), background-color var(--transition-speed) var(--transition-timing); border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        input:checked + .slider { background-color: var(--bg-toggle-track-active); }
        input:focus + .slider { box-shadow: 0 0 1px var(--bg-toggle-track-active); }
        input:checked + .slider:before { transform: translateX(24px); }
        .fullscreen-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-overlay); backdrop-filter: blur(var(--backdrop-blur-heavy)); z-index: 500; display: none; padding: 80px 20px 20px 20px; overflow-y: auto; color: var(--text-light); align-items: center; justify-content: flex-start; flex-direction: column; text-align: center; animation: fadeInOverlay 0.3s ease-out; }
        @keyframes fadeInOverlay { from { opacity: 0; } to { opacity: 1; } }
        .overlay-close-button { position: absolute; top: 15px; right: 15px; padding: 8px 12px; background-color: var(--bg-button-action); color: var(--text-dark); border: none; border-radius: 5px; font-size: 1em; font-weight: 700; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease, color var(--transition-speed) var(--transition-timing); z-index: 510; }
        .overlay-close-button:hover { background-color: var(--bg-button-action-hover); transform: scale(1.05); }
        .overlay-title { font-size: 2em; font-weight: 700; color: var(--text-heading-accent); margin-bottom: 20px; margin-top: 20px; }
        .overlay-content { width: 100%; max-width: 450px; padding: 25px; background-color: var(--bg-ui-panel); border-radius: 10px; box-shadow: var(--shadow-panel); color: var(--text-light); display: flex; flex-direction: column; gap: 15px; }
        .overlay-content p { font-size: 1.1em; color: var(--text-medium); margin-bottom: 0; line-height: 1.6; }
        .overlay-content p strong { color: var(--accent-cyan); word-break: break-all; }
        .overlay-content p strong.highlight { color: var(--accent-yellow); font-weight: 700; }
        #profile-overlay .profile-info-item { display: flex; justify-content: space-between; align-items: center; font-size: 1.1em; color: var(--text-medium); padding: 5px 0; border-bottom: 1px solid var(--border-color); }
        #profile-overlay .profile-info-item:last-child { border-bottom: none; }
        #profile-overlay .profile-info-item span { margin-right: 15px; }
        #profile-overlay .profile-info-item strong { color: var(--text-light); word-break: break-all; text-align: right; margin-top: 0; }
        #tasks-overlay .overlay-content { background-color: transparent; box-shadow: none; padding: 0; max-width: 500px; display: flex; flex-direction: column; gap: 30px; }
        .task-group { background-color: var(--bg-ui-panel); border-radius: 10px; box-shadow: var(--shadow-panel); padding: 20px; width: 100%; }
        .task-group h3 { font-size: 1.4em; color: var(--text-heading-accent); margin-top: 0; margin-bottom: 20px; text-align: center; font-weight: 700; }
        .task-group .task-list { display: flex; flex-direction: column; gap: 15px; }
        .task-item { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; background-color: var(--bg-link-button); padding: 10px 15px; border-radius: 8px; border: 1px solid var(--border-link-button); }
        .task-item span { font-size: 1em; color: var(--text-medium); margin-right: 15px; flex-grow: 1; text-align: left; margin-bottom: 5px; }
        .task-item .link-button { display: inline-flex; align-items: center; padding: 8px 18px; border-radius: 20px; background-color: var(--bg-button-info); color: var(--text-dark); text-decoration: none; font-weight: 700; font-size: 0.9em; transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; box-shadow: var(--shadow-button); cursor: pointer; white-space: nowrap; border: none; flex-shrink: 0; }
        .task-item .link-button:hover { background-color: var(--bg-button-info-hover); transform: scale(1.04); box-shadow: var(--shadow-button-hover); }
        .task-item .link-button svg { width: 18px; height: 18px; fill: currentColor; margin-right: 8px; }
        .task-item .link-button.x-link { background-color: var(--bg-button-x); color: white; }
        .task-item .link-button.x-link:hover { background-color: var(--bg-button-x-hover); }
        .task-item .link-button.youtube-link { background-color: #FF0000; color: white; }
        .task-item .link-button.youtube-link:hover { background-color: #CC0000; }
        .task-item .link-button.submit-link { background-color: var(--bg-button-special); color: var(--text-dark); }
        .task-item .link-button.submit-link:hover { background-color: var(--bg-button-special-hover); }
        #sponsor-contact-button { display: block; width: fit-content; margin: 10px auto 0 auto; padding: 10px 20px; }

        #withdrawal-overlay .overlay-content { gap: 0; padding: 15px; }
        .withdrawal-accordion-item { width: 100%; margin-bottom: 10px; border: 1px solid var(--border-accordion); border-radius: 8px; overflow: hidden; background-color: var(--bg-withdrawal-section); }
        .withdrawal-accordion-header { padding: 15px 20px; background-color: var(--bg-accordion-header); color: var(--text-accordion-header); font-size: 1.2em; font-weight: 700; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid transparent; }
        .withdrawal-accordion-header:hover { background-color: var(--bg-accordion-header-hover); }
        .withdrawal-accordion-header.active { border-bottom-color: var(--border-accordion); }
        .withdrawal-accordion-header .accordion-icon { font-size: 1.2em; transition: transform 0.3s ease-out; }
        .withdrawal-accordion-header.active .accordion-icon { transform: rotate(90deg); }
        .withdrawal-accordion-content { padding: 0px; background-color: var(--bg-accordion-content); max-height: 0; overflow: hidden; text-align: left; }
        .withdrawal-accordion-content .content-padding { padding: 20px; }
        .withdrawal-accordion-content.open { max-height: 1000px; }
        .withdrawal-accordion-content ul { list-style: none; padding-left: 0; margin: 0; }
        .withdrawal-accordion-content li { font-size: 1em; color: var(--text-medium); margin-bottom: 10px; line-height: 1.5; padding-left: 20px; position: relative; }
        .withdrawal-accordion-content li::before { content: "•"; position: absolute; left: 0; color: var(--accent-cyan); font-weight: bold; display: inline-block; width: 20px; }
        .withdrawal-accordion-content li strong { color: var(--accent-yellow); font-weight: 600; }
        #withdraw-main-button, #convert-points-button { padding: 12px 25px; border: none; border-radius: 8px; font-family: inherit; font-weight: 700; font-size: 1.1em; display: block; width: 100%; margin-top: 15px; }
        #convert-points-button { background-color: var(--bg-button-info); color: var(--text-dark); cursor: pointer; }
        #convert-points-button:hover:not(:disabled) { background-color: var(--bg-button-info-hover); }
        #convert-points-button:disabled { background-color: #777; color: #bbb; cursor: not-allowed; }
        #withdraw-main-button { background-color: var(--bg-button-action); color: var(--text-dark); cursor: pointer; }
        #withdraw-main-button:hover:not(:disabled) { background-color: var(--bg-button-action-hover); }
        #withdraw-main-button:disabled { background-color: #777; color: #bbb; cursor: not-allowed; opacity: 0.6;}

        .balance-display { margin-bottom: 10px; font-size: 1em; color: var(--text-medium); display: flex; align-items: center; }
        .balance-display strong { color: var(--text-light); margin-left: 5px;}
        .crypto-icon { width: 18px; height: 18px; margin-right: 8px; vertical-align: middle; }

        #withdrawal-history-list { display: flex; flex-direction: column; gap: 10px; max-height: 250px; overflow-y: auto; padding-right: 5px; }
        .history-item { background-color: var(--bg-history-item); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-history-item); font-size: 0.9em; }
        .history-item-details { display: block; color: var(--text-medium); margin-bottom: 3px; }
        .history-item-details strong { color: var(--text-light); }
        .history-item-details .status-pending { color: var(--text-history-status-pending); font-weight: bold; }
        .history-item-details .status-completed { color: var(--text-history-status-completed); font-weight: bold; }
        .history-item-details .status-rejected { color: var(--text-history-status-rejected); font-weight: bold; }
        .history-item-details .status-processing { color: var(--accent-cyan); font-weight: bold; }
        .history-item-tx { font-size: 0.8em; color: var(--text-link); word-break: break-all; }
        .history-item-tx:hover { color: var(--text-link-hover); }


        #friends-overlay .overlay-content { gap: 20px; }
        #friends-overlay .referral-info { display: flex; flex-direction: column; gap: 10px; text-align: center; margin-bottom: 15px; }
        #referral-link-container { display: flex; align-items: center; gap: 10px; background-color: var(--bg-input); padding: 8px 12px; border-radius: 6px; margin-top: 10px; border: 1px solid var(--border-input); }
        #referral-link-display { flex-grow: 1; font-size: 0.9em; color: var(--text-medium); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: left; }
        #copy-referral-link-button { padding: 6px 10px; font-size: 0.85em; font-weight: 600; background-color: var(--bg-copy-button); color: var(--text-copy-button); border: 1px solid var(--border-copy-button); border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
        #copy-referral-link-button:hover { background-color: var(--bg-copy-button-hover); color: var(--text-copy-button-hover); }
        #friends-overlay .referral-count { font-size: 1.2em; font-weight: 700; color: var(--text-light); margin-bottom: 10px; padding-bottom: 10px; text-align: center; border-bottom: 1px solid var(--border-color); }
        #friends-overlay .referral-count strong { color: var(--accent-yellow); }
        #referral-list-container { width: 100%; max-height: 280px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; background-color: rgba(0,0,0,0.1); padding: 10px; scrollbar-width: thin; scrollbar-color: var(--accent-cyan) rgba(0,0,0,0.1); }
        #referral-list-container::-webkit-scrollbar { width: 6px; }
        #referral-list-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 3px;}
        #referral-list-container::-webkit-scrollbar-thumb { background-color: var(--accent-cyan); border-radius: 3px; }
        #referral-list { display: flex; flex-direction: column; gap: 10px; }
        .referral-item { display: flex; align-items: center; justify-content: space-between; background-color: var(--bg-link-button); padding: 10px 15px; border-radius: 6px; border: 1px solid var(--border-link-button); }
        .referral-item span { font-size: 1em; color: var(--text-medium); flex-grow: 1; margin-right: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; order: -1; z-index: 1; }
        #game-canvas { display: block; width: 100%; height: 100%; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; }

        .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: var(--bg-modal); backdrop-filter: blur(var(--backdrop-blur-heavy)); padding: 30px 40px; border-radius: 15px; text-align: center; z-index: 600; display: none; box-shadow: var(--shadow-modal); width: 90%; max-width: 400px; border: 1px solid var(--border-color); pointer-events: auto; color: var(--text-light); }
        .modal h2 { margin: 0 0 20px 0; font-size: 2.1em; font-weight: 700; color: var(--text-heading-accent); text-align: center; }
        .modal p { font-size: 1.1em; margin-bottom: 25px; font-weight: 400; color: var(--text-medium); line-height: 1.5; text-align: center; }
        .modal-buttons { margin-top: 20px; display: flex; justify-content: space-between; gap: 15px; flex-wrap: nowrap; }
        .modal-button { padding: 12px 15px; font-size: 1em; flex-grow: 1; flex-basis: 0; min-width: 100px; text-align: center; cursor: pointer; border: none; border-radius: 8px; background-color: var(--bg-button-info); color: var(--text-dark); font-weight: 700; transition: all .2s ease; pointer-events: auto; text-transform: uppercase; letter-spacing: 0.5px; box-shadow: var(--shadow-button); }
        .modal-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #777; color: #eee; transform: none; box-shadow: none; }
        .modal-button:hover:not(:disabled) { background-color: var(--bg-button-info-hover); transform: translateY(-2px) scale(1.02); box-shadow: var(--shadow-button-hover); }
        .modal-button:active:not(:disabled) { transform: translateY(0px) scale(0.98); box-shadow: 0 1px 3px var(--shadow-color); }
        .modal-button.boost-button { background-color: var(--bg-button-watch-ad); }
        .modal-button.boost-button:hover:not(:disabled) { background-color: var(--bg-button-watch-ad-hover); }
        .modal-button.special-button { background-color: var(--bg-button-special); }
        .modal-button.special-button:hover:not(:disabled) { background-color: var(--bg-button-special-hover); }
        /* Specific style for announcement popup button */
        #announcement-follow-button { display: inline-flex; align-items: center; text-decoration: none; }
        #announcement-follow-button svg { width: 18px; height: 18px; fill: currentColor; margin-right: 8px; }


        #game-over-ui h2 { margin-bottom: 15px; }
        #game-over-ui p#game-over-message { font-size: 1.2em; min-height: 1.5em; margin-bottom: 25px; }
        #game-over-buttons { margin-top: 0; }
        #game-over-ui .game-over-button { background-color: var(--bg-button-info); }
        #game-over-ui .game-over-button:hover:not(:disabled) { background-color: var(--bg-button-info-hover); }
        #watch-ad-button.game-over-button { background-color: var(--bg-button-special); }
        #watch-ad-button.game-over-button:hover:not(:disabled) { background-color: var(--bg-button-special-hover); }

        #start-game-modal h2 { margin-bottom: 25px; }
        #start-game-modal p { display: none; } /* Kept hidden as per original, or adjust if needed */
        #start-game-modal .modal-buttons { margin-top: 0; }
        #start-normal-button.modal-button { background-color: var(--bg-button-info); }
        #start-normal-button.modal-button:hover:not(:disabled) { background-color: var(--bg-button-info-hover); }

        #menu-overlay-dimmer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 399; display: none; opacity: 0; transition: opacity var(--transition-speed) ease-in-out; }
        #menu-overlay-dimmer.visible { display: block; opacity: 1; }
    </style>

    <!-- Real Telegram Web Apps SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <!-- Ad SDK (Keep this if you are using it) -->
    <script src='//whephiwums.com/sdk.js' data-zone='9292240' data-sdk='show_9292240'></script>
</head>
<body>

    <div id="loading-screen">
        <img src="loading_drop.png" alt="Loading Helix Point Drop" id="loading-image">
        <div id="loading-text">Initializing Game...</div>
        <div id="loading-bar-container"><div id="loading-bar"></div></div>
    </div>

    <div id="header-bar">
        <div id="score-wrapper">
            <div class="score-display"><span class="score-label">Current</span> <span id="current-score">0</span></div>
            <div class="score-display"><span class="score-label">Total</span> <span id="total-score">...</span></div>
        </div>
        <div id="header-timer-display">0:00</div>
        <button id="menu-button" class="icon-button" aria-label="Open Menu">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill-rule="evenodd" d="M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z" clip-rule="evenodd" /></svg>
        </button>
        <button id="settings-button" class="icon-button" aria-label="Settings">⚙️</button>
        <div id="settings-popup">
             <div class="setting-item">
                 <p>Light Mode</p>
                 <label class="theme-switch"><input type="checkbox" id="theme-toggle-checkbox"><span class="slider round"></span></label>
             </div>
        </div>
    </div>

    <div id="side-menu">
        <button class="menu-item-button" data-action="show-profile">Profile</button>
        <button class="menu-item-button" data-action="show-withdrawal">Withdrawal</button>
        <button class="menu-item-button" data-action="show-friends">Friends</button>
        <button class="menu-item-button" data-action="show-tasks">Tasks</button>
    </div>
    <div id="menu-overlay-dimmer"></div>

    <div id="profile-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="profile-overlay">Close</button>
        <h2 class="overlay-title">Profile</h2>
        <div class="overlay-content">
             <div class="profile-info-item"><span>Telegram ID:</span><strong id="user-id-overlay">...</strong></div>
             <div class="profile-info-item"><span>Username:</span><strong id="username-overlay">...</strong></div>
             <div class="profile-info-item"><span>Total Score:</span><strong id="profile-total-score-display">...</strong></div>
        </div>
    </div>

    <div id="withdrawal-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="withdrawal-overlay">Close</button>
        <h2 class="overlay-title">Withdrawal</h2>
        <div class="overlay-content">
            <div class="withdrawal-accordion-item">
                <div class="withdrawal-accordion-header" data-accordion-target="withdrawal-rules-content">
                    <span>Rules</span><span class="accordion-icon">&gt;</span>
                </div>
                <div class="withdrawal-accordion-content" id="withdrawal-rules-content">
                    <div class="content-padding">
                        <ul>
                            <li>Withdrawals will be enabled in <strong>early or late July</strong>.</li>
                            <li>Minimum <strong>10 referrals</strong> required.</li>
                            <li>Minimum <strong>2 TON</strong> or <strong>0.08 SOL</strong> is required for withdrawal (after fees).</li>
                            <li>Provide your <strong>TON</strong> (The Open Network) address for TON withdrawals.</li>
                            <li>Provide your <strong>SOL</strong> (BEP-20 Network) address for SOL withdrawals.</li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="withdrawal-accordion-item">
                <div class="withdrawal-accordion-header" data-accordion-target="withdrawal-conversion-content">
                    <span>Point Conversion</span><span class="accordion-icon">&gt;</span>
                </div>
                <div class="withdrawal-accordion-content" id="withdrawal-conversion-content">
                    <div class="content-padding">
                        <div class="input-group">
                            <label for="conversion-points-input">Points to Convert:</label>
                            <input type="number" id="conversion-points-input" name="conversion-points-input" placeholder="Enter points" min="1" step="1">
                        </div>
                        <div class="input-group">
                            <label for="conversion-crypto-select">Select Crypto for Conversion:</label>
                            <select id="conversion-crypto-select" name="conversion-crypto-select">
                                <option value="ton">TON</option>
                                <option value="sol">SOL</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <p style="font-size: 0.9em; color: var(--text-medium); margin-bottom: 5px;">Expected Amount (Before Fees):</p>
                            <strong id="conversion-expected-amount" style="font-size: 1.1em; color: var(--accent-yellow);">0.0000 CRYPTO</strong>
                        </div>
                        <button id="convert-points-button" disabled>Convert</button>
                        <p style="font-size: 0.8em; color: var(--text-medium); margin-top: 15px;">Note: 1000 pts = 0.0005 TON or 1000 pts = 0.00002 SOL. Withdrawal fees (0.05 TON / 0.01 SOL) apply separately.</p>
                    </div>
                </div>
            </div>
            <div class="withdrawal-accordion-item">
                <div class="withdrawal-accordion-header" data-accordion-target="withdrawal-form-content">
                    <span>Withdraw Funds</span><span class="accordion-icon">&gt;</span>
                </div>
                <div class="withdrawal-accordion-content" id="withdrawal-form-content">
                    <div class="content-padding">
                        <div class="balance-display">
                            <img src="ton_icon.svg" alt="TON" class="crypto-icon"> <!-- TODO: Replace with actual TON icon path -->
                            TON Balance: <strong id="actual-ton-balance-display">0.00000</strong>
                        </div>
                        <div class="balance-display">
                            <img src="sol_icon.svg" alt="SOL" class="crypto-icon"> <!-- TODO: Replace with actual SOL icon path -->
                            SOL Balance: <strong id="actual-sol-balance-display">0.000000</strong>
                        </div>
                        <hr style="border-color: var(--border-color); margin: 15px 0;">
                        <div class="input-group">
                            <label for="withdraw-crypto-select">Crypto to Withdraw:</label>
                            <select id="withdraw-crypto-select" name="withdraw-crypto-select">
                                <option value="ton">TON</option>
                                <option value="sol">SOL</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label for="withdraw-amount-input">Amount to Withdraw (Crypto):</label>
                            <input type="number" id="withdraw-amount-input" name="withdraw-amount-input" placeholder="e.g., 2.5" step="any" min="0">
                        </div>
                        <div class="input-group">
                            <label for="withdraw-address-input">Wallet Address:</label>
                            <input type="text" id="withdraw-address-input" name="withdraw-address-input" placeholder="Enter your wallet address">
                        </div>
                        <div class="input-group">
                            <p style="font-size: 0.9em; color: var(--text-medium); margin-bottom: 5px;">Expected Amount (After Fees):</p>
                            <strong id="withdraw-expected-after-fees" style="font-size: 1.1em; color: var(--accent-yellow);">0.0000 CRYPTO</strong>
                        </div>
                        <button id="withdraw-main-button" disabled>Withdraw</button>
                    </div>
                </div>
            </div>
            <div class="withdrawal-accordion-item">
                <div class="withdrawal-accordion-header" data-accordion-target="withdrawal-history-content">
                    <span>Withdrawal History</span><span class="accordion-icon">&gt;</span>
                </div>
                <div class="withdrawal-accordion-content" id="withdrawal-history-content">
                    <div class="content-padding">
                        <div id="withdrawal-history-list">
                            <p style="text-align: center; opacity: 0.7;">Loading history...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="friends-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="friends-overlay">Close</button>
        <h2 class="overlay-title">Friends</h2>
        <div class="overlay-content">
            <div class="referral-info">
                <p>Invite your <strong>friends</strong> using your unique referral link!</p>
<p>For each reffered user you will get <strong>+1 point</strong> capped at <strong>9 points</strong></p>
                 <div id="referral-link-container">
                     <span id="referral-link-display">Generating link...</span>
                     <button id="copy-referral-link-button">Copy</button>
                 </div>
            </div>
            <div class="referral-count">Total Referrals: <strong id="referral-count-display">0</strong></div>
            <div id="referral-list-container"><div id="referral-list"><p style="text-align: center; opacity: 0.7;">Loading referrals...</p></div></div>
        </div>
    </div>
    <div id="tasks-overlay" class="fullscreen-overlay">
         <button class="overlay-close-button" data-overlay-id="tasks-overlay">Close</button>
         <h2 class="overlay-title">Tasks</h2>
         <div class="overlay-content" style="gap: 20px;">
            <div class="task-group">
                <h3>Follow Social Accounts</h3>
                <div class="task-list">
                    <div class="task-item"><span>Join Telegram Channel</span><a href="https://t.me/helix_cryptodrop" target="_blank" rel="noopener noreferrer" class="link-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.17.91-.497 1.208-.82 1.23-.696.047-1.225-.46-1.9-.91-.546-.353-1.075-.688-1.758-1.104l-.108-.061c-1.218-.78-1.896-1.182-1.736-1.889.05-.212.333-.717.333-.717l.11-.24s4.17-3.8 4.576-4.18c.07-.07.12-.15.05-.23-.07-.08-.18-.05-.25-.02-.11.04-1.88 1.16-5.36 3.34-.47.29-.88.43-1.28.42-.49-.01-.97-.13-1.42-.25-1.03-.28-1.88-.42-1.79-.93.04-.22.31-.42.88-.63 3.41-1.22 5.68-2.07 6.94-2.51.3-.11.56-.2.78-.2z"/></svg>Join</a></div>
                    <div class="task-item"><span>Follow on X (Twitter)</span><a href="https://x.com/drop_official89?t=lJ9kaQKLwWQk41avHSJdhw&s=08" target="_blank" rel="noopener noreferrer" class="link-button x-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>Follow</a></div>
                    <div class="task-item"><span>Subscribe on YouTube</span><a href="https://youtube.com/@YourChannelName" target="_blank" rel="noopener noreferrer" class="link-button youtube-link"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path fill-rule="evenodd" d="M19.802 5.578a3.75 3.75 0 0 0-2.652-2.652C15.547 2.5 12 2.5 12 2.5s-3.547 0-5.15.426A3.75 3.75 0 0 0 4.198 5.578C3.773 7.18 3.773 12 3.773 12s0 4.82.425 6.422a3.75 3.75 0 0 0 2.652 2.652C8.453 21.5 12 21.5 12 21.5s3.547 0 5.15-.426a3.75 3.75 0 0 0 2.652-2.652C20.227 16.82 20.227 12 20.227 12s0-4.82-.425-6.422ZM9.75 15.5V8.5l6 3.5-6 3.5Z" clip-rule="evenodd" /></svg>Subscribe</a></div>
                </div>
            </div>
            <div class="task-group">
                <h3>Creator Media Rewards</h3>
                 <div class="task-list">
                     <div class="task-item"><span>Created Instagram Content? Submit Proof for Rewards</span><a href="#creator-submission" class="link-button submit-link">Submit Proof</a></div>
                     <div class="task-item"><span>Created YouTube Content? Submit Proof for Rewards</span><a href="#creator-submission" class="link-button submit-link">Submit Proof</a></div>
                     <div class="task-item"><span>Created Facebook Content? Submit Proof for Rewards</span><a href="#creator-submission" class="link-button submit-link">Submit Proof</a></div>
                 </div>
            </div>
             <div class="task-group">
                 <h3>Sponsorship & Partnership</h3>
                 <p style="font-size: 1em; text-align: center; margin-bottom: 15px;">Are you interested in sponsoring or partnering with Helix Point Drop?</p>
                 <a href="mailto:youremail@example.com?subject=Sponsorship Inquiry - Helix Point Drop" id="sponsor-contact-button" class="standard-button special-button">Contact Us</a>
             </div>
         </div>
     </div>

    <div id="game-over-ui" class="modal">
        <h2>Game Over!</h2>
        <p id="game-over-message">Score: <span id="final-score">0</span></p>
        <div id="game-over-buttons" class="modal-buttons">
            <button id="watch-ad-button" class="game-over-button modal-button special-button">Watch Ad & Save</button>
            <button id="restart-button" class="game-over-button modal-button">Play Again</button>
        </div>
    </div>

    <div id="start-game-modal" class="modal">
        <h2>Start Game</h2>
        <p>Start normally or watch an ad for a points boost!</p>
        <div class="modal-buttons">
            <button id="start-boost-button" class="modal-button boost-button">+1 Pt/Platform</button>
            <button id="start-normal-button" class="modal-button">Normally</button>
        </div>
    </div>

    <!-- Announcement Popup -->
    <div id="announcement-popup" class="modal" style="display: none;"> <!-- Start hidden -->
        <h2>Announcement</h2>
        <p id="announcement-message">Important Announcement: [Details will be updated here]</p>
        <div class="modal-buttons" style="justify-content: center; gap: 10px;">
            <a id="announcement-follow-button" href="https://t.me/helix_cryptodrop" target="_blank" rel="noopener noreferrer" class="modal-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: currentColor; margin-right: 8px;"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.17.91-.497 1.208-.82 1.23-.696.047-1.225-.46-1.9-.91-.546-.353-1.075-.688-1.758-1.104l-.108-.061c-1.218-.78-1.896-1.182-1.736-1.889.05-.212.333-.717.333-.717l.11-.24s4.17-3.8 4.576-4.18c.07-.07.12-.15.05-.23-.07-.08-.18-.05-.25-.02-.11.04-1.88 1.16-5.36 3.34-.47.29-.88.43-1.28.42-.49-.01-.97-.13-1.42-.25-1.03-.28-1.88-.42-1.79-.93.04-.22.31-.42.88-.63 3.41-1.22 5.68-2.07 6.94-2.51.3-.11.56-.2.78-.2z"/></svg>
                Follow Telegram
            </a>
            <button id="announcement-close-button" class="modal-button">OK</button>
        </div>
    </div>
    <!-- End Announcement Popup -->

    <div id="game-container"><canvas id="game-canvas"></canvas></div>

    <div id="initial-controls-container" class="hidden"> <!-- Start hidden -->
        <h3>Select Difficulty & Start</h3>
         <div id="difficulty-options">
             <button class="difficulty-button active" data-difficulty="easy">Easy</button>
             <button class="difficulty-button" data-difficulty="medium">Medium</button>
             <button class="difficulty-button" data-difficulty="hard">Hard</button>
         </div>
         <button id="start-game-button">Start Game (1 Min)</button>
    </div>

    <!--
        REMOVED MOCK TELEGRAM SCRIPT BLOCK.
        The real Telegram SDK is now included in the <head>.
    -->

    <script type="importmap">{
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js",
            "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/",
            "@supabase/supabase-js": "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm"
        }
    }</script>

    <script type="module">
        import * as THREE from 'three';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { TextureLoader } from 'three';
        import { createClient } from '@supabase/supabase-js';

        const BOT_USERNAME = "Crypto_drop_ya_bot";
        const MINI_APP_NAME = "";
        const FADE_DURATION = 500;
        const SUPABASE_URL = 'https://ihoguaucknakkmywqunm.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlob2d1YXVja25ha2tteXdxdW5tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY0NTk4MzgsImV4cCI6MjA2MjAzNTgzOH0.GjX0iJnQWrdD1-T2H1cMG9yXOeHfo3eQK5Sk8F3NN6w';
        const GAME_DURATION_SECONDS = 60;
        const TELEGRAM_CHANNEL_URL = "https://t.me/helix_cryptodrop";

        let scene, camera, renderer, composer, bloomPass;
        let ball, platformGroup, poleGroup, starField;
        let currentScore = 0;
        let gameState = 'initializing';
        let internalPauseState = false;
        let rotationSensitivity = 0.02, bounceSpeed = 0.11;
        let currentBallVelocityY = 0, ballPreviousY = 0, lastSafePlatformY = 0;
        const gravity = -0.0035;
        const platformRadius = 2.5, poleRadius = 0.5, gapSize = Math.PI / 2.5;
        const platformSegments = 3, platformSpacingY = 2.0;
        let activePlatforms = [], nextPlatformY = 0;
        let activePoleSegments = {};
        let scoreIncrementedForPlatform = {};
        const ballStartX = 1.5; const ballStartZ = 0; const initialBallY = 8;
        const cameraVerticalOffset = 4.5, cameraLookAtOffset = 1.0;
        const cameraFixedZ = 11; const cameraZoomedInZ = 9.5; const cameraZoomDuration = 600;
        let isCameraZooming = false; let cameraZoomRequestId = null;
        const cameraFollowLerpFactor = 0.08;
        let envMap = null;
        const clock = new THREE.Clock();
        let ballTexture = null;
        const textureLoader = new TextureLoader();
        const platformColorPalette = [ 0x00cfde, 0x8e44ad, 0x3498db, 0x2ecc71, 0xe74c3c, 0xf39c12 ];
        let platformColorIndex = 0;
        let shakeIntensity = 0; const shakeDecreaseFactor = 0.9; const maxShakeOffset = 0.15;
        let isPointerDown = false; let previousPointerX = 0;
        let adTimerIntervalId = null;

        let selectedDifficulty = 'easy';
        let currentGameCountdown = 0;
        let gameTimerIntervalId = null;
        let adBonusActiveForThisGame = false;
        let isTimedGameActive = false;

        // --- DOM Element References ---
        const currentScoreEl = document.getElementById('current-score');
        const totalScoreEl = document.getElementById('total-score');
        const gameOverUI = document.getElementById('game-over-ui');
        const finalScoreEl = document.getElementById('final-score');
        const gameOverMessageP = document.getElementById('game-over-message');
        const restartButton = document.getElementById('restart-button');
        const watchAdButton = document.getElementById('watch-ad-button');
        const gameContainer = document.getElementById('game-container');
        const headerBar = document.getElementById('header-bar');
        const menuButton = document.getElementById('menu-button');
        const settingsButton = document.getElementById('settings-button');
        const sideMenu = document.getElementById('side-menu');
        const menuOverlayDimmer = document.getElementById('menu-overlay-dimmer');
        const settingsPopup = document.getElementById('settings-popup');
        const profileOverlay = document.getElementById('profile-overlay');
        const profileTotalScoreDisplay = document.getElementById('profile-total-score-display');
        const userIdOverlay = document.getElementById('user-id-overlay');
        const usernameOverlay = document.getElementById('username-overlay');
        const withdrawalOverlay = document.getElementById('withdrawal-overlay');
        const friendsOverlay = document.getElementById('friends-overlay');
        const tasksOverlay = document.getElementById('tasks-overlay');
        const overlayCloseButtons = document.querySelectorAll('.overlay-close-button');
        const menuItemButtons = sideMenu.querySelectorAll('.menu-item-button');
        const themeToggleCheckbox = document.getElementById('theme-toggle-checkbox');
        const referralLinkDisplay = document.getElementById('referral-link-display');
        const copyReferralLinkButton = document.getElementById('copy-referral-link-button');
        const referralCountDisplay = document.getElementById('referral-count-display');
        const referralList = document.getElementById('referral-list');
        const initialControlsContainer = document.getElementById('initial-controls-container');
        const difficultyButtons = initialControlsContainer.querySelectorAll('.difficulty-button');
        const startGameButton = initialControlsContainer.querySelector('#start-game-button');
        const headerTimerDisplayEl = document.getElementById('header-timer-display');
        const startGameModal = document.getElementById('start-game-modal');
        const startNormalButton = document.getElementById('start-normal-button');
        const startBoostButton = document.getElementById('start-boost-button');
        const loadingScreen = document.getElementById('loading-screen');
        const loadingTextEl = document.getElementById('loading-text');
        const announcementPopupEl = document.getElementById('announcement-popup');
        const announcementMessageEl = document.getElementById('announcement-message');
        const announcementFollowButtonEl = document.getElementById('announcement-follow-button');
        const announcementCloseButtonEl = document.getElementById('announcement-close-button');
        const withdrawalAccordionHeaders = document.querySelectorAll('#withdrawal-overlay .withdrawal-accordion-header');
        const conversionPointsInput = document.getElementById('conversion-points-input');
        const conversionCryptoSelect = document.getElementById('conversion-crypto-select');
        const conversionExpectedAmountDisplay = document.getElementById('conversion-expected-amount');
        const convertPointsButton = document.getElementById('convert-points-button');
        const actualTonBalanceDisplay = document.getElementById('actual-ton-balance-display');
        const actualSolBalanceDisplay = document.getElementById('actual-sol-balance-display');
        const withdrawCryptoSelect = document.getElementById('withdraw-crypto-select');
        const withdrawAmountInput = document.getElementById('withdraw-amount-input');
        const withdrawAddressInput = document.getElementById('withdraw-address-input');
        const withdrawExpectedAfterFeesDisplay = document.getElementById('withdraw-expected-after-fees');
        const withdrawMainButton = document.getElementById('withdraw-main-button');
        const withdrawalHistoryListDiv = document.getElementById('withdrawal-history-list');

        // --- Supabase & User State ---
        let supabase = null;
        let telegramUserId = null;
        let telegramUserData = null;
        let currentUserTotalScore = 0n;
        let currentUserReferralCount = 0;
        let userRealtimeChannel = null;
        let hasProcessedReferral = false;
        let actualTonBalance = 0.0;
        let actualSolBalance = 0.0;

        // --- Constants ---
        const POINTS_TO_TON_RATE = 0.0005 / 1000;
        const POINTS_TO_SOL_RATE = 0.00002 / 1000;
        const TON_FEE = 0.05;
        const SOL_FEE = 0.01;
        const TON_DECIMALS = 5;
        const SOL_DECIMALS = 6;
        const MIN_REFERRALS_FOR_WITHDRAWAL = 10;
        const MIN_TON_WITHDRAWAL_AFTER_FEE = 2.0;
        const MIN_SOL_WITHDRAWAL_AFTER_FEE = 0.08;

        // --- Utility Functions ---
        function getCssVariable(varName) { return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
        function parseColorHex(colorString) { if (colorString.startsWith('#')) { return parseInt(colorString.substring(1), 16); } console.warn(`Could not parse color hex: ${colorString}`); return 0xffffff; }
        function formatNumber(num) { try { if (typeof num !== 'number' && typeof num !== 'bigint' && typeof num !== 'string') return num; return BigInt(num).toLocaleString(); } catch (e) { console.warn("formatNumber error:", e, "Input:", num); return String(num); } }
        function maskUsername(username) { if (!username || username.length <= 3) return "***"; return username.substring(0, 3) + '*'.repeat(username.length - 3); }
        function generateReferralLink(userId) { if (!userId) { console.warn("generateReferralLink called without a userId."); return "Link Unavailable"; } if (BOT_USERNAME === "Crypto_drop_ya_bot") { console.warn("Note: Your BOT_USERNAME is set to 'Crypto_drop_ya_bot'. Ensure this is correct."); } const appPath = MINI_APP_NAME ? `/${MINI_APP_NAME}` : ''; return `https://t.me/${BOT_USERNAME}${appPath}?startapp=${userId}`; }
        async function copyToClipboard(text) { if (!navigator.clipboard) { console.warn("Clipboard API missing"); return false; } try { await navigator.clipboard.writeText(text); return true; } catch (err) { console.error('Copy fail: ', err); return false; } }
        function formatTime(seconds) { if (typeof seconds !== 'number' || seconds < 0) seconds = 0; const mins = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${mins}:${secs < 10 ? '0' : ''}${secs}`; }
        function formatDate(dateString) { if (!dateString) return 'N/A'; try { return new Date(dateString).toLocaleString(undefined, { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }); } catch (e) { return dateString; } }

        // --- UI Update Functions ---
        function updateScoreUI() { if (currentScoreEl) currentScoreEl.textContent = formatNumber(currentScore); }
        function updateTotalScoreUI(score) {
            try {
                const fmt = formatNumber(score);
                if (totalScoreEl) totalScoreEl.textContent = String(fmt);
                if (profileTotalScoreDisplay) profileTotalScoreDisplay.textContent = String(fmt);
                currentUserTotalScore = BigInt(score);
            } catch(e) {
                console.error("Error updating total score UI:", e, "Score:", score);
                if (totalScoreEl) totalScoreEl.textContent = "Error";
                if (profileTotalScoreDisplay) profileTotalScoreDisplay.textContent = "Error";
                currentUserTotalScore = 0n;
            }
             calculateConversionAmount();
        }
        function updateReferralCountUI(count) {
            const fmt = formatNumber(count || 0);
            if(referralCountDisplay) referralCountDisplay.textContent = String(fmt);
            currentUserReferralCount = Number(count || 0);
            console.log("Updated currentUserReferralCount:", currentUserReferralCount);
            calculateWithdrawalAfterFees();
        }
        function updateReferralLinkUI(userId) { if (referralLinkDisplay) referralLinkDisplay.textContent = generateReferralLink(userId); }
        async function populateReferralListUI() { if (!referralList || !telegramUserId) return; referralList.innerHTML = '<p style="text-align: center; opacity: 0.7;">Loading referrals...</p>'; try { const { data, error } = await supabase.rpc('get_user_referrals', { p_user_id: telegramUserId }); if (error) { console.error("Error fetching referrals:", error); referralList.innerHTML = '<p style="text-align: center; color: var(--text-error);">Could not load referrals.</p>'; return; } referralList.innerHTML = ''; if (!data || data.length === 0) { referralList.innerHTML = '<p style="text-align: center; opacity: 0.7;">No referrals yet.</p>'; return; } data.forEach(ref => { const li = document.createElement('div'); li.className = 'referral-item'; const span = document.createElement('span'); const displayName = ref.ref_username ? maskUsername(ref.ref_username) : (ref.ref_first_name || 'User'); span.textContent = displayName; li.appendChild(span); referralList.appendChild(li); }); } catch(e) { console.error("Exception fetching referrals:", e); referralList.innerHTML = '<p style="text-align: center; color: var(--text-error);">Error loading referrals.</p>'; } }

        // --- Game State & UI Pause/Resume ---
        function setInternalPause(pause) { if (internalPauseState === pause) return; internalPauseState = pause; if (!pause && gameState === 'playing' && isTimedGameActive) { clock.getDelta(); } console.log("Internal Pause State:", internalPauseState); }
        function isAnyUIOverlayOpen() { return sideMenu.classList.contains('open') || settingsPopup.style.display === 'block' || profileOverlay.style.display === 'flex' || withdrawalOverlay.style.display === 'flex' || friendsOverlay.style.display === 'flex' || tasksOverlay.style.display === 'flex' || gameOverUI.style.display === 'block' || startGameModal.style.display === 'block' || announcementPopupEl.style.display === 'block' || (initialControlsContainer && !initialControlsContainer.classList.contains('hidden')); }
        function pauseGameForUI() { if (gameState === 'playing') { setInternalPause(true); console.log("Paused for UI (Physics/Input only)"); } }
        function resumeGameFromUI() { if (!isAnyUIOverlayOpen()) { if (gameState === 'playing' && internalPauseState) { setInternalPause(false); console.log("Resumed from UI (Physics/Input only)"); } else if (gameState === 'ready') { showInitialControls(); } } }

        // --- Supabase Functions ---
        function initializeSupabaseClient() { if (!SUPABASE_URL || !SUPABASE_ANON_KEY || SUPABASE_URL === 'YOUR_SUPABASE_URL') { console.error("Supabase URL or Anon Key is not configured."); alert("Service Configuration Error."); gameState = 'error'; setInternalPause(true); updateTotalScoreUI("Config Error"); updateReferralCountUI("Config Error"); if (loadingTextEl) loadingTextEl.textContent = "Service Configuration Error."; return false; } try { supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY); console.log("Supabase Client Initialized OK"); return true; } catch (e) { console.error("Supabase Client Init Failed:", e); alert("Service Initialization Error."); updateTotalScoreUI("Init Error"); updateReferralCountUI("Init Error"); gameState='error'; setInternalPause(true); if (loadingTextEl) loadingTextEl.textContent = "Service Initialization Error."; return false; } }
        function subscribeToUserData(tgUserId) { if (!supabase || !tgUserId) return; if (userRealtimeChannel) { supabase.removeChannel(userRealtimeChannel).then(() => console.log("Removed existing user data channel.")).catch(e => console.warn("Error removing previous channel:", e)); userRealtimeChannel = null; } console.log(`Subscribing to updates for user: ${tgUserId}`); userRealtimeChannel = supabase.channel(`user-data-${tgUserId}`).on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'users', filter: `telegram_id=eq.${tgUserId}` }, (payload) => { console.log('User data UPDATE received:', payload); const updatedUserData = payload.new; if (updatedUserData) { updateTotalScoreUI(updatedUserData.total_score ?? currentUserTotalScore); updateReferralCountUI(updatedUserData.referral_count ?? currentUserReferralCount); actualTonBalance = parseFloat(updatedUserData.actual_ton_balance || 0); actualSolBalance = parseFloat(updatedUserData.actual_sol_balance || 0); updateActualCryptoBalancesUI(); } }).on('SYSTEM', { event: 'error' }, (payload) => { console.error(`Realtime channel error for user ${tgUserId}:`, payload); }).on('SYSTEM', { event: 'close' }, () => { console.log(`Realtime channel explicitly closed for user ${tgUserId}.`); }); userRealtimeChannel.subscribe((status, err) => { if (status === 'SUBSCRIBED') { console.log(`Successfully subscribed to channel: user-data-${tgUserId}`); } else if (status === 'CHANNEL_ERROR') { console.error(`Realtime channel error during subscribe for user ${tgUserId}:`, err); } else if (status === 'TIMED_OUT') { console.warn(`Realtime subscription timed out for user ${tgUserId}.`); } else if (status === 'CLOSED') { console.log(`Realtime channel subscription stream closed for user ${tgUserId}.`) } else { console.log(`Realtime channel status update for user ${tgUserId}:`, status); } }); }
        async function fetchAndInitializeUser(tgUserId, tgUser) {
            if (!supabase || !tgUserId) { console.error("Cannot fetch user: Supabase client or User ID missing."); updateTotalScoreUI("Config Error"); updateReferralCountUI("Config Error"); gameState = 'error'; setInternalPause(true); if (loadingTextEl) loadingTextEl.textContent = "Database Connection Error."; return null; }
            try {
                console.log(`Fetching/Initializing user: ${tgUserId}`); if (loadingTextEl) loadingTextEl.textContent = "Verifying User...";
                let { data: userData, error: fetchError } = await supabase
                    .from('users')
                    .select('total_score, referral_count, referred_by, actual_ton_balance, actual_sol_balance')
                    .eq('telegram_id', tgUserId)
                    .single();

                if (fetchError && fetchError.code !== 'PGRST116') { console.error("Error during fetch (excluding not found):", fetchError); throw fetchError; }

                if (userData) {
                    console.log(`User ${tgUserId} found. Data:`, userData); if (loadingTextEl) loadingTextEl.textContent = "Welcome Back!";
                    const { error: updateError } = await supabase.from('users').update({ last_seen_at: new Date().toISOString(), username: tgUser?.username || userData.username || null, first_name: tgUser?.first_name || userData.first_name || 'User' }).eq('telegram_id', tgUserId);
                    if (updateError) console.warn("Error updating last_seen (non-critical):", updateError);
                    updateTotalScoreUI(userData.total_score ?? 0);
                    updateReferralCountUI(userData.referral_count ?? 0);
                    actualTonBalance = parseFloat(userData.actual_ton_balance || 0);
                    actualSolBalance = parseFloat(userData.actual_sol_balance || 0);
                    updateActualCryptoBalancesUI();
                    subscribeToUserData(tgUserId);
                    return userData;
                } else {
                    console.log(`User ${tgUserId} not found. Attempting to create.`); if (loadingTextEl) loadingTextEl.textContent = "Creating Profile...";
                    const newUserRecord = { telegram_id: tgUserId, username: tgUser?.username || null, first_name: tgUser?.first_name || 'User', first_seen_at: new Date().toISOString(), last_seen_at: new Date().toISOString(), actual_ton_balance: 0.0, actual_sol_balance: 0.0 };
                    const { data: insertedData, error: insertError } = await supabase.from('users').insert(newUserRecord).select('total_score, referral_count, referred_by, actual_ton_balance, actual_sol_balance').single();
                    if (insertError) { console.error("Error creating new user:", insertError); if (insertError.code === '42501') console.error("RLS policy might be blocking INSERT."); throw insertError; }
                    if (insertedData) {
                        console.log("New user created successfully:", insertedData); if (loadingTextEl) loadingTextEl.textContent = "Profile Created!";
                        updateTotalScoreUI(insertedData.total_score ?? 0);
                        updateReferralCountUI(insertedData.referral_count ?? 0);
                        actualTonBalance = parseFloat(insertedData.actual_ton_balance || 0);
                        actualSolBalance = parseFloat(insertedData.actual_sol_balance || 0);
                        updateActualCryptoBalancesUI();
                        subscribeToUserData(tgUserId);
                        return insertedData;
                    } else { console.error("Insert succeeded but no data returned."); throw new Error("Insert operation failed to return data."); }
                }
            } catch (error) { console.error("Failed to fetch or initialize user:", error); updateTotalScoreUI("DB Err"); updateReferralCountUI("DB Err"); gameState = 'error'; setInternalPause(true); if (loadingTextEl) loadingTextEl.textContent = "Database Error. Please Refresh."; alert("Database connection error. Please refresh or try again later."); return null; }
        }
        async function processReferralOnLoad(currentUserId, currentUserTgData, initialUserData) { if (hasProcessedReferral || !supabase || !currentUserId) return; if (initialUserData?.referred_by) { console.log(`User ${currentUserId} already referred by ${initialUserData.referred_by}.`); hasProcessedReferral = true; return; } const startParam = window.Telegram?.WebApp?.initDataUnsafe?.start_param; if (!startParam) { console.log("No start_param for referral."); hasProcessedReferral = true; return; } const referrerId = parseInt(startParam, 10); if (!referrerId || isNaN(referrerId) || referrerId === currentUserId) { console.warn(`Invalid referral: start_param=${startParam}, currentId=${currentUserId}`); hasProcessedReferral = true; return; } console.log(`Referral: Referrer ${referrerId}, Current ${currentUserId}. Processing...`); if (loadingTextEl) loadingTextEl.textContent = "Processing Referral..."; hasProcessedReferral = true; try { const { data, error } = await supabase.rpc('process_referral', { p_referrer_id: referrerId, p_referred_id: currentUserId, p_referred_username: currentUserTgData?.username || null, p_referred_first_name: currentUserTgData?.first_name || 'User' }); if (error) { console.error('Error calling process_referral RPC:', error); return; } if (data === true) { console.log(`Referral processed: ${currentUserId} by ${referrerId}`); if (loadingTextEl) loadingTextEl.textContent = "Referral Applied!"; } else { console.log(`Referral not processed (RPC false): ${currentUserId}`); } } catch (e) { console.error('Exception calling process_referral RPC:', e); } }
        async function updateUserScoreInBackend(pointsChange) {
            if (!supabase || !telegramUserId || typeof pointsChange !== 'number' || isNaN(pointsChange) || pointsChange === 0) {
                console.warn("Invalid score update request (or zero change) to backend:", { supabase: !!supabase, telegramUserId, pointsChange });
                return Promise.resolve(); // No actual update needed for zero or invalid
            }
            console.log(`Calling RPC increment_total_score for user ${telegramUserId} with points change ${pointsChange}`);
            const { error } = await supabase.rpc('increment_total_score', {
                user_id: telegramUserId,
                score_to_add: Math.floor(pointsChange)
            });
            if (error) {
                console.error("Error updating total score via RPC:", error);
                return Promise.reject(error);
            } else {
                console.log(`Score update RPC successful for ${telegramUserId}. Change: ${pointsChange}`);
                return Promise.resolve();
            }
        }

        // --- Theme Functions ---
        function applyTheme(theme) { const isLight = theme === 'light'; document.body.classList.toggle('light-mode', isLight); themeToggleCheckbox.checked = isLight; localStorage.setItem('theme', theme); updateMaterialsTheme(); try { if (window.Telegram?.WebApp) { const hc = getCssVariable('--bg-header-bar'); window.Telegram.WebApp.setHeaderColor(hc); } } catch (e) { console.warn("TG theme color set fail:", e); } console.log(`Theme: ${theme}`); }
        function updateMaterialsTheme() { const isLight = document.body.classList.contains('light-mode'); if (ball?.material) { const bc = parseColorHex(getCssVariable('--ball-color')); ball.material.color.setHex(bc); } const pc = parseColorHex(getCssVariable('--pole-color')); for (const y in activePoleSegments) { const s = activePoleSegments[y]; if (s?.material) { s.material.color.setHex(pc); } } const dCol = parseColorHex(getCssVariable('--danger-color')); const dEm = parseColorHex(getCssVariable('--danger-glow')); activePlatforms.forEach(p => { if (p?.userData?.segmentAngles) { p.userData.segmentAngles.forEach(sd => { if (sd.isDanger && sd.material) { sd.material.color.setHex(dCol); sd.material.emissive.setHex(dEm); } else if (!sd.isDanger && sd.material && p.userData.colorHex) { sd.material.color.setHex(p.userData.colorHex); } }); } }); if (scene) { if (isLight) { scene.background = null; if (starField) starField.visible = false; } else { scene.background = null; if (starField) { starField.visible = true; const sc = parseColorHex(getCssVariable('--star-color')); starField.material.color.setHex(sc); starField.material.needsUpdate = true; } else { createStarfield(); } } } }
        function setupTheme() { let initTheme = 'dark'; try { initTheme = window.Telegram?.WebApp?.colorScheme || localStorage.getItem('theme') || 'dark'; } catch (e) { initTheme = localStorage.getItem('theme') || 'dark'; } applyTheme(initTheme); themeToggleCheckbox.addEventListener('change', () => applyTheme(themeToggleCheckbox.checked ? 'light' : 'dark')); try { window.Telegram?.WebApp?.onEvent('themeChanged', () => applyTheme(window.Telegram.WebApp.colorScheme)); } catch(e) { console.warn("TG theme listener err:", e); } }

        // --- Overlay & Menu Toggles ---
        function toggleSideMenu() { const open=sideMenu.classList.toggle('open'); menuOverlayDimmer.classList.toggle('visible', open); if(open){ closeSettingsPopup(); pauseGameForUI(); } else { resumeGameFromUI(); }}
        function closeSideMenu() { if(sideMenu.classList.contains('open')){ sideMenu.classList.remove('open'); menuOverlayDimmer.classList.remove('visible'); resumeGameFromUI(); }}
        function toggleSettingsPopup() { const vis=settingsPopup.style.display==='block'; if(vis){ closeSettingsPopup(); } else { openSettingsPopup(); }}
        function openSettingsPopup() { closeSideMenu(); settingsPopup.style.display = 'block'; pauseGameForUI(); }
        function closeSettingsPopup() { if(settingsPopup.style.display === 'block'){ settingsPopup.style.display = 'none'; resumeGameFromUI(); }}
        function showOverlay(el) {
             if (!el) return;
             closeSideMenu();
             closeSettingsPopup();
             closeAllOverlays(el);
             hideInitialControls();
             el.style.display = 'block';
             if (el.classList.contains('fullscreen-overlay')) el.style.display = 'flex';
             pauseGameForUI();
             if (el === profileOverlay) updateTotalScoreUI(currentUserTotalScore);
             else if (el === friendsOverlay) { updateReferralCountUI(currentUserReferralCount); updateReferralLinkUI(telegramUserId); populateReferralListUI(); }
             else if (el === withdrawalOverlay) updateActualCryptoBalancesUI();
         }
        function hideOverlay(el) { if(!el || el.style.display === 'none') return; el.style.display = 'none'; resumeGameFromUI(); }
        function closeAllOverlays(exclude=null) { [profileOverlay, withdrawalOverlay, friendsOverlay, tasksOverlay, startGameModal, gameOverUI, announcementPopupEl].forEach(o => { if (o && o !== exclude && o.style.display !== 'none') o.style.display = 'none'; }); if (gameState === 'ready' && !isAnyUIOverlayOpen()) showInitialControls(); }

        // --- Announcement Popup ---
        function showAnnouncementPopup() {
             if (!announcementPopupEl) return;
             const announcementText = "Welcome to Helix Point Drop! Follow our channel for updates. Withdrawals coming soon!";
             announcementMessageEl.textContent = announcementText;
             announcementFollowButtonEl.href = TELEGRAM_CHANNEL_URL;
             closeAllOverlays(announcementPopupEl);
             hideInitialControls();
             announcementPopupEl.style.display = 'block';
             pauseGameForUI();
             console.log("Announcement popup shown");
         }
        function hideAnnouncementPopup() {
            if (!announcementPopupEl) return;
            announcementPopupEl.style.display = 'none';
            console.log("Announcement popup hidden");
            if (gameState === 'ready') {
                showInitialControls();
            }
            resumeGameFromUI();
        }

        // --- Withdrawal Accordion & Forms ---
        function toggleAccordion(headerElement) {
            console.log("toggleAccordion called for header:", headerElement.dataset.accordionTarget);
            const targetId = headerElement.dataset.accordionTarget;
            const contentElement = document.getElementById(targetId);
            if (!contentElement) { console.error("Accordion content element not found:", targetId); return; }
            const isActive = headerElement.classList.contains('active');
            withdrawalAccordionHeaders.forEach(otherHeader => {
                if (otherHeader !== headerElement) {
                    otherHeader.classList.remove('active');
                    const otherContent = document.getElementById(otherHeader.dataset.accordionTarget);
                    if (otherContent) otherContent.classList.remove('open');
                }
            });
            if (!isActive) {
                headerElement.classList.add('active');
                contentElement.classList.add('open');
                console.log("Opening accordion:", targetId);
                if (targetId === 'withdrawal-conversion-content') calculateConversionAmount();
                else if (targetId === 'withdrawal-form-content') calculateWithdrawalAfterFees();
                else if (targetId === 'withdrawal-history-content') populateWithdrawalHistoryUI();
            } else {
                headerElement.classList.remove('active');
                contentElement.classList.remove('open');
                console.log("Closing accordion (was active):", targetId);
            }
        }
        function updateActualCryptoBalancesUI() {
            if (actualTonBalanceDisplay) actualTonBalanceDisplay.textContent = actualTonBalance.toFixed(TON_DECIMALS);
            if (actualSolBalanceDisplay) actualSolBalanceDisplay.textContent = actualSolBalance.toFixed(SOL_DECIMALS);
            calculateConversionAmount();
            calculateWithdrawalAfterFees();
        }
        async function handlePointConversion() {
            if (!conversionPointsInput || !conversionCryptoSelect || !convertPointsButton || !telegramUserId) { alert("System error or not logged in."); return; }
            const pointsToConvertStr = conversionPointsInput.value;
            if (!pointsToConvertStr) { alert("Please enter the number of points to convert."); return; }
            const pointsToConvert = parseInt(pointsToConvertStr, 10);
            const selectedCrypto = conversionCryptoSelect.value;
            if (isNaN(pointsToConvert) || pointsToConvert <= 0) { alert("Please enter a valid positive number of points."); return; }
            const pointsToConvertBigInt = BigInt(pointsToConvert);
            if (currentUserTotalScore < pointsToConvertBigInt) { alert("Insufficient points balance."); return; }

            convertPointsButton.disabled = true; convertPointsButton.textContent = "Converting...";
            try {
                const { data, error: rpcError } = await supabase.rpc('convert_points', {
                    p_user_id: telegramUserId,
                    p_points_to_convert: pointsToConvert,
                    p_target_crypto_type: selectedCrypto.toUpperCase()
                });
                if (rpcError) throw rpcError;
                if (data && data.length > 0 && data[0].success) {
                    const result = data[0];
                    currentUserTotalScore = BigInt(result.updated_total_score);
                    actualTonBalance = parseFloat(result.updated_ton_balance);
                    actualSolBalance = parseFloat(result.updated_sol_balance);
                    updateTotalScoreUI(currentUserTotalScore);
                    updateActualCryptoBalancesUI();
                    alert(result.message || `Successfully converted ${pointsToConvert} points!`);
                    conversionPointsInput.value = '';
                    calculateConversionAmount();
                } else {
                    alert(data && data.length > 0 ? data[0].message : "Conversion failed.");
                }
            } catch (error) {
                console.error("Point conversion RPC error:", error);
                alert("An error occurred during conversion: " + error.message);
            } finally {
                convertPointsButton.textContent = "Convert";
                 updateActualCryptoBalancesUI();
            }
        }
        function calculateConversionAmount() {
            if (!conversionPointsInput || !conversionCryptoSelect || !conversionExpectedAmountDisplay || !convertPointsButton) return;
            const points = parseInt(conversionPointsInput.value, 10);
            const selectedCrypto = conversionCryptoSelect.value;
            let expectedAmount = 0;
            let displayMessage = `0.0000 ${selectedCrypto.toUpperCase()}`;
            let canConvert = false;
            if (!isNaN(points) && points > 0) {
                let rate, decimals;
                if (selectedCrypto === 'ton') { rate = POINTS_TO_TON_RATE; decimals = TON_DECIMALS; }
                else { rate = POINTS_TO_SOL_RATE; decimals = SOL_DECIMALS; }
                expectedAmount = points * rate;
                displayMessage = `${expectedAmount.toFixed(decimals)} ${selectedCrypto.toUpperCase()}`;
                const pointsToConvertBigInt = BigInt(points);
                if (currentUserTotalScore >= pointsToConvertBigInt) {
                    canConvert = true;
                } else {
                     displayMessage += " (Insufficient Pts)";
                }
            }
            conversionExpectedAmountDisplay.textContent = displayMessage;
            convertPointsButton.disabled = !canConvert;
        }
        function calculateWithdrawalAfterFees() {
            if (!withdrawAmountInput || !withdrawCryptoSelect || !withdrawExpectedAfterFeesDisplay || !withdrawAddressInput || !withdrawMainButton) return;
            const amountToWithdraw = parseFloat(withdrawAmountInput.value);
            const selectedCrypto = withdrawCryptoSelect.value;
            const walletAddress = withdrawAddressInput.value.trim();

            let fee, decimals, currentBalance, minWithdrawAfterFee;
            if (selectedCrypto === 'ton') {
                 fee = TON_FEE; decimals = TON_DECIMALS; currentBalance = actualTonBalance; minWithdrawAfterFee = MIN_TON_WITHDRAWAL_AFTER_FEE;
            } else {
                 fee = SOL_FEE; decimals = SOL_DECIMALS; currentBalance = actualSolBalance; minWithdrawAfterFee = MIN_SOL_WITHDRAWAL_AFTER_FEE;
            }

            let expectedAfterFees = 0;
            let displayMessage = `0.0000 ${selectedCrypto.toUpperCase()}`;
            let canWithdraw = false;

            if (!isNaN(amountToWithdraw) && amountToWithdraw > 0) {
                expectedAfterFees = amountToWithdraw - fee;
                if (expectedAfterFees >= 0) {
                    displayMessage = `${expectedAfterFees.toFixed(decimals)} ${selectedCrypto.toUpperCase()}`;
                    if (amountToWithdraw <= currentBalance && expectedAfterFees >= minWithdrawAfterFee) {
                        if (currentUserReferralCount >= MIN_REFERRALS_FOR_WITHDRAWAL) {
                            if (walletAddress) {
                                canWithdraw = true;
                            } else {
                                displayMessage += " (Enter Address)";
                            }
                        } else {
                             displayMessage += ` (${MIN_REFERRALS_FOR_WITHDRAWAL}+ Refs Req.)`;
                        }
                    } else if (amountToWithdraw > currentBalance) {
                        displayMessage += " (Insufficient Balance)";
                    } else if (expectedAfterFees < minWithdrawAfterFee) {
                         displayMessage += " (Below Min.)";
                    }
                 } else {
                    displayMessage = `0.0000 ${selectedCrypto.toUpperCase()} (Fee > Amount)`;
                }
             } else if (amountToWithdraw <= 0 && walletAddress && currentUserReferralCount >= MIN_REFERRALS_FOR_WITHDRAWAL) {
                 displayMessage = `0.0000 ${selectedCrypto.toUpperCase()} (Enter Amount)`;
             } else if (amountToWithdraw <= 0 && !walletAddress && currentUserReferralCount >= MIN_REFERRALS_FOR_WITHDRAWAL){
                 displayMessage = `0.0000 ${selectedCrypto.toUpperCase()} (Enter Amount & Address)`;
             }

            withdrawExpectedAfterFeesDisplay.textContent = displayMessage;
            withdrawMainButton.disabled = !canWithdraw;
        }
        async function handleWithdrawalRequest() {
            if (!withdrawCryptoSelect || !withdrawAmountInput || !withdrawAddressInput || !telegramUserId || !telegramUserData) { alert("System error or user data missing."); return; }
            const selectedCrypto = withdrawCryptoSelect.value.toUpperCase();
            const amountToWithdraw = parseFloat(withdrawAmountInput.value);
            const walletAddress = withdrawAddressInput.value.trim();

             let fee, currentBalance, minWithdrawAfterFee;
             if (selectedCrypto === 'TON') { fee = TON_FEE; currentBalance = actualTonBalance; minWithdrawAfterFee = MIN_TON_WITHDRAWAL_AFTER_FEE; }
             else { fee = SOL_FEE; currentBalance = actualSolBalance; minWithdrawAfterFee = MIN_SOL_WITHDRAWAL_AFTER_FEE; }

             if (isNaN(amountToWithdraw) || amountToWithdraw <= 0) { alert("Please enter a valid positive amount."); return; }
             if (!walletAddress) { alert("Please enter your wallet address."); return; }
             if (amountToWithdraw > currentBalance) { alert(`Insufficient ${selectedCrypto} balance.`); return; }
             if (amountToWithdraw - fee < minWithdrawAfterFee) { alert(`Amount after fee is below the minimum withdrawal threshold (${minWithdrawAfterFee} ${selectedCrypto}).`); return; }
             if (currentUserReferralCount < MIN_REFERRALS_FOR_WITHDRAWAL) { alert(`Minimum ${MIN_REFERRALS_FOR_WITHDRAWAL} referrals required to withdraw.`); return; }

            withdrawMainButton.disabled = true; withdrawMainButton.textContent = "Processing...";
            try {
                const { data, error: rpcError } = await supabase.rpc('request_crypto_withdrawal', {
                    p_user_telegram_id: telegramUserId,
                    p_user_telegram_name: telegramUserData.first_name || "N/A",
                    p_user_telegram_username: telegramUserData.username || null,
                    p_crypto_type: selectedCrypto,
                    p_amount_requested: amountToWithdraw,
                    p_wallet_address: walletAddress
                });
                if (rpcError) throw rpcError;
                if (data && data.length > 0 && data[0].success) {
                    const result = data[0];
                    actualTonBalance = parseFloat(result.updated_ton_balance);
                    actualSolBalance = parseFloat(result.updated_sol_balance);
                    updateActualCryptoBalancesUI();
                    alert(result.message || "Withdrawal request submitted successfully and is now pending!");
                    withdrawAmountInput.value = "";
                    calculateWithdrawalAfterFees();
                    if (document.getElementById('withdrawal-history-content').classList.contains('open')) {
                        populateWithdrawalHistoryUI();
                    }
                } else {
                    alert(data && data.length > 0 ? data[0].message : "Withdrawal request failed.");
                    calculateWithdrawalAfterFees();
                }
            } catch (err) {
                console.error("Error during withdrawal request:", err);
                alert("An error occurred: " + (err.message || "Unknown error"));
                calculateWithdrawalAfterFees();
            } finally {
                withdrawMainButton.textContent = "Withdraw";
                 updateActualCryptoBalancesUI();
            }
        }
        async function populateWithdrawalHistoryUI() {
            if (!withdrawalHistoryListDiv || !telegramUserId) { if(withdrawalHistoryListDiv) withdrawalHistoryListDiv.innerHTML = '<p>Could not load history (User ID missing).</p>'; return; }
            console.log('Fetching withdrawal history for user ID:', telegramUserId);
            withdrawalHistoryListDiv.innerHTML = '<p style="text-align: center; opacity: 0.7;">Loading history...</p>';

            try {
                const { data, error } = await supabase.rpc('get_user_withdrawal_history', { p_user_telegram_id: telegramUserId });
                if (error) { console.error("Error fetching withdrawal history RPC:", error); withdrawalHistoryListDiv.innerHTML = `<p style="color: var(--text-error);">Could not load history: ${error.message}</p>`; return; }

                withdrawalHistoryListDiv.innerHTML = '';
                if (!data || data.length === 0) { withdrawalHistoryListDiv.innerHTML = '<p style="opacity: 0.7;">No withdrawal history yet.</p>'; return; }

                data.sort((a, b) => new Date(b.requested_at) - new Date(a.requested_at));

                data.forEach((item) => {
                    const historyDiv = document.createElement('div');
                    historyDiv.className = 'history-item';
                    const amountDecimals = item.crypto_type === 'TON' ? TON_DECIMALS : SOL_DECIMALS;
                    const statusValue = item.status ? item.status.toLowerCase() : 'unknown';
                    const statusClass = `status-${statusValue}`;
                    let statusText = item.status ? (item.status.charAt(0).toUpperCase() + item.status.slice(1)) : 'Unknown';
                    if (statusValue === 'processing' && !item.transaction_hash) statusText = 'Processing';
                    else if (statusValue === 'completed' && item.transaction_hash) statusText = 'Completed';

                    let txHtml = '';
                    if (item.transaction_hash) {
                        const explorerLink = item.crypto_type === 'TON' ? `https://tonscan.org/tx/${item.transaction_hash}` : `https://solscan.io/tx/${item.transaction_hash}`;
                        txHtml = `<span class="history-item-details"><strong>TxID:</strong> <a href="${explorerLink}" target="_blank" rel="noopener noreferrer" class="history-item-tx">${item.transaction_hash.substring(0,10)}...</a></span>`;
                    }
                    let reasonHtml = '';
                    if (statusValue === 'rejected' && item.rejection_reason) {
                        reasonHtml = `<span class="history-item-details" style="color: var(--text-error);"><strong>Reason:</strong> ${item.rejection_reason}</span>`;
                    }

                    historyDiv.innerHTML = `
                        <span class="history-item-details"><strong>Date:</strong> ${formatDate(item.requested_at)}</span>
                        <span class="history-item-details"><strong>Type:</strong> ${item.crypto_type}</span>
                        <span class="history-item-details"><strong>Amount:</strong> ${parseFloat(item.amount_requested).toFixed(amountDecimals)} ${item.crypto_type}</span>
                        <span class="history-item-details"><strong>Status:</strong> <span class="${statusClass}">${statusText}</span></span>
                        ${txHtml}
                        ${reasonHtml}
                    `;
                    withdrawalHistoryListDiv.appendChild(historyDiv);
                });
            } catch (e) {
                console.error("Exception processing withdrawal history:", e);
                withdrawalHistoryListDiv.innerHTML = '<p style="color: var(--text-error);">Error loading withdrawal history.</p>';
            }
        }

        // --- Three.js Scene Setup ---
        function createStarfield() { if(starField)scene.remove(starField); const c=7000; const p=new Float32Array(c*3); const g=new THREE.BufferGeometry(); const h=parseColorHex(getCssVariable('--star-color')); for(let i=0;i<c;i++){ const i3=i*3; const r=60+Math.random()*60; const ph=Math.acos(-1+(2*Math.random())); const th=Math.random()*Math.PI*2; p[i3]=r*Math.sin(ph)*Math.cos(th); p[i3+1]=r*Math.cos(ph); p[i3+2]=r*Math.sin(ph)*Math.sin(th); } g.setAttribute('position',new THREE.BufferAttribute(p,3)); const m=new THREE.PointsMaterial({size:0.1,color:h,sizeAttenuation:true,transparent:true,opacity:0.8,depthWrite:false,blending:THREE.AdditiveBlending}); starField=new THREE.Points(g,m); starField.userData.isStarfield=true; starField.renderOrder=-1; starField.visible=!document.body.classList.contains('light-mode'); scene.add(starField); }
        function createBall() { if(ball)scene.remove(ball); const g=new THREE.SphereGeometry(0.25,32,32); const h=parseColorHex(getCssVariable('--ball-color')); const m=new THREE.MeshStandardMaterial({color:h,map:ballTexture,metalness:0.8,roughness:0.3,envMap:envMap,envMapIntensity:0.7}); ball=new THREE.Mesh(g,m); ball.userData.isBall=true; ball.position.set(ballStartX,initialBallY,ballStartZ); ballPreviousY=ball.position.y; scene.add(ball); }
        function createPoleSegment(y) { const h=platformSpacingY; const g=new THREE.CylinderGeometry(poleRadius,poleRadius,h,16); const c=parseColorHex(getCssVariable('--pole-color')); const m=new THREE.MeshStandardMaterial({color:c,roughness:0.6,metalness:0.2,transparent:true,opacity:1.0}); const s=new THREE.Mesh(g,m); s.position.y=y; s.userData={y:y,isPoleSegment:true,fadeOut:false,fadeProgress:0,material:m}; poleGroup.add(s); activePoleSegments[y]=s; }
        function createPlatform(y) { const p = new THREE.Group(); p.position.y = y; p.rotation.y = Math.random() * Math.PI * 2; const circ = 2 * Math.PI; if(platformSegments <= 0) return; const segAng = (circ - gapSize) / platformSegments; const gapSt = Math.random() * circ; const gapEnd = (gapSt + gapSize) % circ; let dangerProbability = 0.25; switch (selectedDifficulty) { case 'medium': dangerProbability = 0.55; break; case 'hard': dangerProbability = 0.9; break; default: dangerProbability = 0.25; break; } const hasD = Math.random() < dangerProbability; const dIdx = hasD ? Math.floor(Math.random() * platformSegments) : -1; const sCol = platformColorPalette[platformColorIndex % platformColorPalette.length]; platformColorIndex++; p.userData={y:y,isSafe:!hasD,segmentAngles:[],isPlatformGroup:true,gapStartAngle:gapSt,gapEndAngle:gapEnd,gapSize:gapSize,fadeOut:false,fadeProgress:0,colorHex:sCol}; const iR=poleRadius+0.05; const oR=platformRadius; let currAng=gapEnd; const dColH=parseColorHex(getCssVariable('--danger-color')); const dEmH=parseColorHex(getCssVariable('--danger-glow')); for(let i=0;i<platformSegments;i++){ const isD=(i===dIdx); const matOpts={roughness:isD?0.5:0.7,metalness:0.1,side:THREE.DoubleSide,transparent:true,opacity:1.0}; if(isD){matOpts.color=new THREE.Color(dColH);matOpts.emissive=new THREE.Color(dEmH);matOpts.emissiveIntensity=0.7;} else{matOpts.color=new THREE.Color(sCol);} const segMat=new THREE.MeshStandardMaterial(matOpts); const segGeo=new THREE.RingGeometry(iR,oR,32,1,0,segAng); segGeo.rotateX(-Math.PI/2); const segMesh=new THREE.Mesh(segGeo,segMat); segMesh.rotation.y=currAng; const sSt=currAng%circ; const sEnd=(currAng+segAng)%circ; const segDat={type:'platform_segment',isDanger:isD,parentPlatform:p,index:i,startAngle:sSt,endAngle:sEnd,mesh:segMesh,material:segMat}; p.userData.segmentAngles.push(segDat); segMesh.userData=segDat; p.add(segMesh); currAng=(currAng+segAng)%circ; } platformGroup.add(p); activePlatforms.push(p); }

        // --- Initialization & Game Flow ---
        async function initializeTelegramIntegration() {
            hasProcessedReferral = false;
            // The real Telegram SDK script is already in <head>, so window.Telegram should exist when run in Telegram
            if (!window.Telegram?.WebApp) {
                console.error("Telegram WebApp object not found! Ensure you are running this in a Telegram Mini App environment.");
                // Optionally, you could fall back to a mock here for local development if you want,
                // but for production, it's better to fail or show a message.
                // For now, we'll assume it will be present in the TG environment.
                if (loadingTextEl) loadingTextEl.textContent = "Please open in Telegram.";
                gameState = 'error'; setInternalPause(true);
                return Promise.reject("Telegram Env Missing");
            }
            const tg = window.Telegram.WebApp;

            return new Promise(async (resolve, reject) => {
                try {
                    tg.ready(); console.log("TG Ready. Data:", tg.initDataUnsafe); tg.expand();
                    if (loadingTextEl) loadingTextEl.textContent = "Connecting to Telegram...";

                    if (tg.initDataUnsafe?.user?.id) {
                        telegramUserData = tg.initDataUnsafe.user; telegramUserId = telegramUserData.id;
                        console.log("TG User:", telegramUserId, telegramUserData);
                        if(userIdOverlay) userIdOverlay.textContent = telegramUserId.toString();
                        if(usernameOverlay) usernameOverlay.textContent = telegramUserData?.username ? `@${telegramUserData.username}` : '(Not Set)';

                        if (!initializeSupabaseClient()) { reject("Supabase Init Failed"); return; }
                        const initialUserData = await fetchAndInitializeUser(telegramUserId, telegramUserData);

                        if (initialUserData !== null) {
                            await processReferralOnLoad(telegramUserId, telegramUserData, initialUserData);
                            if (loadingTextEl) loadingTextEl.textContent = "Finalizing...";
                            gameState = 'ready'; setInternalPause(false);
                            showAnnouncementPopup();
                            updateScoreUI(); updateReferralLinkUI(telegramUserId); updateActualCryptoBalancesUI();
                            setTimeout(() => { onWindowResize(); resolve(); }, 100);
                        } else { if (loadingTextEl) loadingTextEl.textContent = "User Profile Error."; reject("User Fetch/Init Failed"); }
                    } else {
                        console.error("TG user ID missing!"); gameState='error'; setInternalPause(true);
                        alert("User information error. Are you in a valid Telegram session?");
                        if (loadingTextEl) loadingTextEl.textContent = "Telegram User Error.";
                        reject("TG User Missing");
                    }
                } catch (err) {
                    console.error("Error during Telegram integration:", err);
                    if (loadingTextEl) loadingTextEl.textContent = "Telegram Integration Error.";
                    gameState = 'error'; setInternalPause(true);
                    reject("TG Integration Error");
                }
            });
        }
        async function init() {
            console.log("Initializing App..."); gameState = 'initializing'; setInternalPause(true);
            if (loadingTextEl) loadingTextEl.textContent = "Loading Game Assets...";

            scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 150); camera.position.z = cameraFixedZ;
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true, alpha: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0; renderer.outputEncoding = THREE.sRGBEncoding; renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); renderer.setClearColor(0x000000, 0);

            setupTheme();

            composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera));
            bloomPass = new UnrealBloomPass(new THREE.Vector2(gameContainer.clientWidth, gameContainer.clientHeight), 0.6, 0.5, 0.8); composer.addPass(bloomPass);

            scene.add(new THREE.HemisphereLight(0xccccff, 0x555599, 0.7)); const dirLight = new THREE.DirectionalLight(0xffffff, 0.9); dirLight.position.set(5, 8, 6); scene.add(dirLight); scene.add(new THREE.AmbientLight(0x404040, 0.6));
            new RGBELoader().load('back.hdr', (t) => { t.mapping = THREE.EquirectangularReflectionMapping; scene.environment = t; envMap = t; if (ball?.material) ball.material.needsUpdate = true; }, undefined, e => console.warn("HDR load fail", e));
            textureLoader.load('ball.jpg', (t) => { t.wrapS = t.wrapT = THREE.RepeatWrapping; ballTexture = t; if (ball?.material) { ball.material.map = t; ball.material.needsUpdate = true; } }, undefined, e => console.warn("Ball tex fail.", e));

            createBall(); platformGroup = new THREE.Group(); scene.add(platformGroup); poleGroup = new THREE.Group(); scene.add(poleGroup);

            window.addEventListener('resize', onWindowResize, false); document.addEventListener('pointerdown', onPointerDown, { passive: false }); document.addEventListener('pointermove', onPointerMove, { passive: false }); document.addEventListener('pointerup', onPointerUp, false); document.addEventListener('pointerleave', onPointerUp, false);
            setupUIListeners();

            if (loadingTextEl) loadingTextEl.textContent = "Connecting to Services...";
            try {
                await initializeTelegramIntegration();
                console.log("TG/Supabase Init OK. Hiding loading screen.");
                if (loadingScreen) { loadingScreen.style.opacity = '0'; setTimeout(() => { loadingScreen.style.display = 'none'; }, 500); }
            } catch (e) { console.error("Initialization failed:", e); if (loadingTextEl) loadingTextEl.textContent = "Initialization Failed."; return; }

            onWindowResize(); animate(); console.log("Init complete.");
        }
        function setupUIListeners() {
             menuButton.addEventListener('click', (e) => { e.stopPropagation(); toggleSideMenu(); });
             settingsButton.addEventListener('click', (e) => { e.stopPropagation(); toggleSettingsPopup(); });
             menuItemButtons.forEach(b => { b.addEventListener('click', () => { const action = b.getAttribute('data-action'); closeSideMenu(); switch (action) { case 'show-profile': showOverlay(profileOverlay); break; case 'show-withdrawal': showOverlay(withdrawalOverlay); break; case 'show-friends': showOverlay(friendsOverlay); break; case 'show-tasks': showOverlay(tasksOverlay); break; } }); });
             overlayCloseButtons.forEach(b => { b.addEventListener('click', () => { const id = b.getAttribute('data-overlay-id'); const o = document.getElementById(id); if (o) { hideOverlay(o); if (id === 'game-over-ui') handlePlayAgain(); } }); });
             document.addEventListener('click', (e) => { if (sideMenu.classList.contains('open') && !sideMenu.contains(e.target) && !menuButton.contains(e.target)) closeSideMenu(); if (settingsPopup.style.display === 'block' && !settingsPopup.contains(e.target) && !settingsButton.contains(e.target)) closeSettingsPopup(); });
             menuOverlayDimmer.addEventListener('click', closeSideMenu);
             settingsPopup.addEventListener('click', e => e.stopPropagation()); sideMenu.addEventListener('click', e => e.stopPropagation());
             [profileOverlay, withdrawalOverlay, friendsOverlay, tasksOverlay, gameOverUI, startGameModal, announcementPopupEl].forEach(overlay => { if (overlay) { overlay.addEventListener('click', e => { if (!e.target.closest('button') && !e.target.closest('a') && !e.target.closest('input') && !e.target.closest('select') && !e.target.closest('.theme-switch') && !e.target.closest('#referral-list-container') && !e.target.closest('.withdrawal-accordion-header')) { e.stopPropagation(); } }); } });
             if (initialControlsContainer) initialControlsContainer.addEventListener('click', e => e.stopPropagation());

             if (announcementCloseButtonEl) announcementCloseButtonEl.addEventListener('click', hideAnnouncementPopup);

             restartButton.addEventListener('click', handlePlayAgain);
             if (watchAdButton) watchAdButton.addEventListener('click', handleWatchAdForSave);
             difficultyButtons.forEach(button => { button.addEventListener('click', () => { if (isTimedGameActive || gameState === 'playing') return; handleDifficultySelection(button.getAttribute('data-difficulty')); }); });
             startGameButton.addEventListener('click', () => { if (gameState === 'ready') { startNormalButton.disabled = false; startBoostButton.disabled = false; startBoostButton.textContent = '+1 Pt/Platform'; showOverlay(startGameModal); } });
             startNormalButton.addEventListener('click', () => { adBonusActiveForThisGame = false; hideOverlay(startGameModal); startGame(); });
             startBoostButton.addEventListener('click', handleWatchAdForBoost);
             if (copyReferralLinkButton) { copyReferralLinkButton.addEventListener('click', async () => { const link = referralLinkDisplay.textContent; if (link && link !== "Generating link..." && link !== "Link Unavailable") { const success = await copyToClipboard(link); copyReferralLinkButton.textContent = success ? "Copied!" : "Failed"; } else { copyReferralLinkButton.textContent = "Error"; } setTimeout(() => { copyReferralLinkButton.textContent = "Copy"; }, 1500); }); }

            withdrawalAccordionHeaders.forEach(header => { header.addEventListener('click', () => toggleAccordion(header)); });
            if (conversionPointsInput) conversionPointsInput.addEventListener('input', calculateConversionAmount);
            if (conversionCryptoSelect) conversionCryptoSelect.addEventListener('change', calculateConversionAmount);
            if (convertPointsButton) convertPointsButton.addEventListener('click', handlePointConversion);
            if (withdrawCryptoSelect) withdrawCryptoSelect.addEventListener('change', calculateWithdrawalAfterFees);
            if (withdrawAmountInput) withdrawAmountInput.addEventListener('input', calculateWithdrawalAfterFees);
            if (withdrawAddressInput) withdrawAddressInput.addEventListener('input', calculateWithdrawalAfterFees);
            if (withdrawMainButton) withdrawMainButton.addEventListener('click', handleWithdrawalRequest);
         }
        function handleDifficultySelection(difficulty) { selectedDifficulty = difficulty; difficultyButtons.forEach(btn => { btn.classList.toggle('active', btn.getAttribute('data-difficulty') === difficulty); }); console.log("Selected difficulty:", selectedDifficulty); }
        function showInitialControls() { if (initialControlsContainer) initialControlsContainer.classList.remove('hidden'); if (headerTimerDisplayEl) headerTimerDisplayEl.classList.remove('visible'); if (startGameButton) startGameButton.disabled = false; updateScoreUI(); }
        function hideInitialControls() { if (initialControlsContainer) initialControlsContainer.classList.add('hidden'); }
        function hideInitialControlsAndShowTimer() { hideInitialControls(); if (headerTimerDisplayEl) headerTimerDisplayEl.classList.add('visible'); }
        function updateHeaderTimerDisplay() { if (headerTimerDisplayEl) headerTimerDisplayEl.textContent = formatTime(currentGameCountdown); }
        function updateGameTimer() { if (internalPauseState) return; if (currentGameCountdown > 0 && isTimedGameActive && gameState === 'playing') { currentGameCountdown--; updateHeaderTimerDisplay(); } if (currentGameCountdown <= 0 && isTimedGameActive && gameState === 'playing') { console.log("Timer ended!"); handleGameOver("Time's Up!"); } }
        async function startGame() {
            if (gameState !== 'ready') { console.warn("Cannot start game, not in ready state."); return; }
            currentGameCountdown = GAME_DURATION_SECONDS; isTimedGameActive = true;
            hideInitialControlsAndShowTimer(); updateHeaderTimerDisplay();
            await prepareGameForStart();
            gameState = 'playing'; setInternalPause(false);
            if (gameTimerIntervalId) clearInterval(gameTimerIntervalId);
            gameTimerIntervalId = setInterval(updateGameTimer, 1000);
            clock.getDelta();
            animateCameraZoom(cameraZoomedInZ, cameraZoomDuration);
            console.log("Game started! Ad Bonus:", adBonusActiveForThisGame, "Refs:", currentUserReferralCount);
        }
        async function prepareGameForStart() {
             console.log("Preparing game board for difficulty:", selectedDifficulty);
             if (adTimerIntervalId) { clearInterval(adTimerIntervalId); adTimerIntervalId = null; }
             if (gameTimerIntervalId) { clearInterval(gameTimerIntervalId); gameTimerIntervalId = null; }
             if (gameState === 'error') { return Promise.reject("Game Error State"); }
             if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId); cameraZoomRequestId = null; isCameraZooming = false;
             if (!ball) createBall(); else { const ballColorHex = parseColorHex(getCssVariable('--ball-color')); ball.material.color.setHex(ballColorHex); }
             ball.position.set(ballStartX, initialBallY, ballStartZ); ballPreviousY = ball.position.y; currentBallVelocityY = 0;
             activePlatforms.forEach(p => disposePlatformSegments(p)); activePlatforms = [];
             if (platformGroup) { while(platformGroup.children.length > 0) disposePlatformSegments(platformGroup.children[0]); platformGroup.rotation.y = 0; } else { platformGroup = new THREE.Group(); scene.add(platformGroup); }
             Object.keys(activePoleSegments).forEach(y => disposePoleSegment(parseFloat(y))); activePoleSegments = {};
             if (poleGroup) { while(poleGroup.children.length > 0) { const child = poleGroup.children[0]; poleGroup.remove(child); if(child.geometry) child.geometry.dispose(); if(child.material) child.material.dispose(); } } else { poleGroup = new THREE.Group(); scene.add(poleGroup); }
             currentScore = 0; updateScoreUI(); scoreIncrementedForPlatform = {}; platformColorIndex = 0; shakeIntensity = 0;
             nextPlatformY = initialBallY - platformSpacingY * 2; lastSafePlatformY = nextPlatformY + platformSpacingY;
             for (let i = 0; i < 15; i++) { createPlatform(nextPlatformY); createPoleSegment(nextPlatformY); nextPlatformY -= platformSpacingY; }
             hideOverlay(gameOverUI); hideOverlay(startGameModal); hideOverlay(announcementPopupEl);
             if (camera && ball) { const camY = ball.position.y + cameraVerticalOffset; const lookY = ball.position.y + cameraLookAtOffset; camera.position.set(0, camY, cameraFixedZ); camera.lookAt(0, lookY, 0); }
             setTimeout(onWindowResize, 50); return Promise.resolve();
         }
        function handlePlayAgain() { hideOverlay(gameOverUI); gameState = 'ready'; setInternalPause(false); isTimedGameActive = false; adBonusActiveForThisGame = false; currentGameCountdown = 0; showInitialControls(); }

        // --- Game Logic: Physics, Collisions, Generation ---
        function generatePlatforms() { if (!ball || !camera || internalPauseState || gameState !== 'playing' || !isTimedGameActive) return; const generationTriggerY = nextPlatformY + platformSpacingY * 8; while (ball.position.y < generationTriggerY && nextPlatformY > -1000) { createPlatform(nextPlatformY); createPoleSegment(nextPlatformY); nextPlatformY -= platformSpacingY; } const removalThresholdY_Above = camera.position.y + 15; activePlatforms.forEach(p => { if (p.position.y > removalThresholdY_Above && !p.userData.fadeOut) startFadeOut(p); }); for (const yPos in activePoleSegments) { const seg = activePoleSegments[yPos]; if (parseFloat(yPos) > removalThresholdY_Above && seg && !seg.userData.fadeOut) startFadeOut(seg); } }
        function updateBallPosition() { if (!ball || internalPauseState || gameState !== 'playing' || !isTimedGameActive) return; currentBallVelocityY += gravity; ball.position.y += currentBallVelocityY; ball.position.x = ballStartX; ball.position.z = ballStartZ; if (ball.position.y < nextPlatformY - platformSpacingY * 5) { handleGameOver("Fell Off!"); } }
        function disposePlatformSegments(platform) { if (!platform) return; platform.traverse(object => { if (object.isMesh) { if (object.geometry) object.geometry.dispose(); if (object.material) { ['map', 'emissiveMap', 'aoMap', 'metalnessMap', 'roughnessMap', 'normalMap', 'displacementMap', 'alphaMap', 'envMap'].forEach(prop => { if (object.material[prop]?.dispose) object.material[prop].dispose(); }); if (Array.isArray(object.material)) { object.material.forEach(m => m.dispose()); } else { object.material.dispose(); } } } }); if (platform.parent) platform.parent.remove(platform); }
        function disposePoleSegment(yPos) { const segment = activePoleSegments[yPos]; if (segment) { if (segment.geometry) segment.geometry.dispose(); if (segment.material) segment.material.dispose(); if (segment.parent) segment.parent.remove(segment); delete activePoleSegments[yPos]; return true; } return false; }
        function startFadeOut(object) { if (!object || !object.userData || object.userData.fadeOut) return; object.userData.fadeOut = true; object.userData.fadeProgress = 0; }
        function destroyPlatformAndPole(platform) {
            if (!platform || !platform.userData || platform.userData.fadeOut) return;
            const platformY = platform.userData.y;
            if (!scoreIncrementedForPlatform[platformY]) {
                let basePoints = currentUserReferralCount > 0 ? Math.min(currentUserReferralCount, 9) : 1;
                let adBonus = adBonusActiveForThisGame ? 1 : 0;
                let pointsForPlatform = basePoints + adBonus;
                currentScore += pointsForPlatform; updateScoreUI();
                scoreIncrementedForPlatform[platformY] = true;
                console.log(`Scored: ${pointsForPlatform} (Base: ${basePoints}, Ad: ${adBonus}, Refs: ${currentUserReferralCount})`);
            }
            startFadeOut(platform); const poleSegment = activePoleSegments[platformY];
            if (poleSegment) startFadeOut(poleSegment);
        }
        function updateFadingObjects(deltaTime) { if (gameState !== 'playing' && gameState !== 'gameOver') return; const fadeSpeed = 1.0 / (FADE_DURATION / 1000); const platformsToRemoveIndexes = []; const poleYPositionsToRemove = []; for (let i = activePlatforms.length - 1; i >= 0; i--) { const p = activePlatforms[i]; if (p.userData.fadeOut) { p.userData.fadeProgress += fadeSpeed * deltaTime; const progress = Math.min(p.userData.fadeProgress, 1); const scale = 1.0 - progress * 0.5; p.scale.set(scale, 1, scale); p.traverse((child) => { if (child.isMesh && child.material) { child.material.opacity = 1.0 - progress; child.material.transparent = true; child.material.needsUpdate = true; } }); if (progress >= 1) platformsToRemoveIndexes.push(i); } } for (let i = platformsToRemoveIndexes.length - 1; i >= 0; i--) { const index = platformsToRemoveIndexes[i]; disposePlatformSegments(activePlatforms[index]); activePlatforms.splice(index, 1); } for (const y in activePoleSegments) { const segment = activePoleSegments[y]; if (segment?.userData.fadeOut) { segment.userData.fadeProgress += fadeSpeed * deltaTime; const progress = Math.min(segment.userData.fadeProgress, 1); if (segment.material) { segment.material.opacity = 1.0 - progress; segment.material.transparent = true; segment.material.needsUpdate = true; } const scale = 1.0 - progress; segment.scale.set(scale, scale, scale); if (progress >= 1) poleYPositionsToRemove.push(parseFloat(y)); } } poleYPositionsToRemove.forEach(y => disposePoleSegment(y)); }
        function checkCollisions() { if (!ball || internalPauseState || gameState !== 'playing' || !isTimedGameActive || currentBallVelocityY >= 0) return; const ballRadius = 0.25; const ballBottomY = ball.position.y - ballRadius; let candidatePlatform = null; let highestCandidateY = -Infinity; for (let i = 0; i < activePlatforms.length; i++) { const platform = activePlatforms[i]; if (!platform || !platform.userData || platform.userData.fadeOut) continue; const platformSurfaceY = platform.position.y; if (ballPreviousY - ballRadius >= platformSurfaceY && ballBottomY <= platformSurfaceY) { if (platformSurfaceY > highestCandidateY) { highestCandidateY = platformSurfaceY; candidatePlatform = platform; } } } if (!candidatePlatform) return; const platformData = candidatePlatform.userData; const collisionY = platformData.y; const ballAngle = Math.atan2(ball.position.z - platformGroup.position.z, ball.position.x - platformGroup.position.x); const towerRotation = platformGroup.rotation.y; const platformInternalRotation = candidatePlatform.rotation.y; let angleRelativeToPlatform = THREE.MathUtils.euclideanModulo( ballAngle - towerRotation - platformInternalRotation, 2 * Math.PI ); const gapStart = platformData.gapStartAngle; const gapEnd = platformData.gapEndAngle; let isInGap; if (gapStart < gapEnd) { isInGap = angleRelativeToPlatform >= gapStart && angleRelativeToPlatform < gapEnd; } else { isInGap = angleRelativeToPlatform >= gapStart || angleRelativeToPlatform < gapEnd; } const ballDistFromCenter = Math.hypot(ball.position.x, ball.position.z); const isInsidePoleRadius = ballDistFromCenter < poleRadius; if (isInGap || isInsidePoleRadius) { destroyPlatformAndPole(candidatePlatform); } else { let hitSegmentData = null; for (const segmentData of platformData.segmentAngles) { let segStart = segmentData.startAngle; let segEnd = segmentData.endAngle; let angleFallsInSegment; if (segStart < segEnd) { angleFallsInSegment = angleRelativeToPlatform >= segStart && angleRelativeToPlatform < segEnd; } else { angleFallsInSegment = angleRelativeToPlatform >= segStart || angleRelativeToPlatform < segEnd; } if (angleFallsInSegment) { hitSegmentData = segmentData; break; } } if (hitSegmentData) { if (hitSegmentData.isDanger) { lastSafePlatformY = collisionY - platformSpacingY; handleGameOver("Hit Danger Zone!"); startShake(0.7); } else { lastSafePlatformY = collisionY; ball.position.y = collisionY + ballRadius + 0.01; currentBallVelocityY = bounceSpeed; Object.keys(scoreIncrementedForPlatform).forEach(keyY => { if (parseFloat(keyY) < collisionY) delete scoreIncrementedForPlatform[keyY]; }); startShake(0.3); } } else { console.warn("Collision: Not in gap, but no segment hit?", { ballAngle, towerRotation, platformInternalRotation, angleRelativeToPlatform}); destroyPlatformAndPole(candidatePlatform); } } }
        async function handleGameOver(reason = "Unknown Reason") {
            if (gameState !== 'playing') return;
            console.log(`Game Over! Reason: ${reason}. Score: ${currentScore}`);
            gameState = 'gameOver'; setInternalPause(true); isTimedGameActive = false;
            if (gameTimerIntervalId) { clearInterval(gameTimerIntervalId); gameTimerIntervalId = null; }
            if (headerTimerDisplayEl) headerTimerDisplayEl.classList.remove('visible');
            gameOverMessageP.innerHTML = `${reason}<br>Score: <span id="final-score">${formatNumber(currentScore)}</span>`;
            showOverlay(gameOverUI);
            if (restartButton) restartButton.disabled = false;
            if (watchAdButton) {
                const showAdSdk = typeof show_9292240 === 'function';
                if (telegramUserId && currentScore > 0 && showAdSdk) { watchAdButton.style.display = 'block'; watchAdButton.disabled = false; }
                else { watchAdButton.style.display = 'none'; }
            }
            if (watchAdButton.style.display === 'none' && currentScore > 0 && telegramUserId) {
                 console.log("Attempting direct score save (no ad shown or available)...");
                 try { await updateUserScoreInBackend(currentScore); console.log("Score saved directly successfully."); }
                 catch (error) { console.error("Direct score save failed:", error); gameOverMessageP.innerHTML += "<br><small>(Save Failed)</small>"; }
             } else if (currentScore <= 0) { console.log("Zero score, not saving."); }
            startShake(0.5);
        }
        function handleWatchAdForBoost() {
            if (gameState !== 'ready' || typeof show_9292240 !== 'function') { alert("Ad service not available."); startNormalButton.disabled = false; startBoostButton.disabled = false; startBoostButton.textContent = '+1 Pt/Platform'; return; }
            startNormalButton.disabled = true; startBoostButton.disabled = true; startBoostButton.textContent = 'Loading Ad...';
            show_9292240().then(() => { adBonusActiveForThisGame = true; hideOverlay(startGameModal); startGame(); }).catch((error) => { console.error("Ad for boost failed:", error); alert("Ad failed. Starting normally."); adBonusActiveForThisGame = false; hideOverlay(startGameModal); startGame(); }).finally(() => { startNormalButton.disabled = false; startBoostButton.disabled = false; startBoostButton.textContent = '+1 Pt/Platform'; });
        }
        function handleWatchAdForSave() {
            if (gameState !== 'gameOver' || !telegramUserId || currentScore <= 0 || typeof show_9292240 !== 'function') { alert("Ad service not ready or score not eligible."); return; }
            if (restartButton) restartButton.disabled = true; if (watchAdButton) watchAdButton.disabled = true;
            const originalMessage = gameOverMessageP.innerHTML; gameOverMessageP.textContent = `Loading Ad to Save Score...`;
            show_9292240().then(async () => {
                 console.log("Ad watched successfully. Attempting to save score...");
                 try { await updateUserScoreInBackend(currentScore); gameOverMessageP.textContent = `Score Saved! Final: ${formatNumber(currentScore)}`; if (restartButton) restartButton.disabled = false; if (watchAdButton) watchAdButton.style.display = 'none'; }
                 catch (error) { console.error("Score save after ad failed:", error); alert("Could not save score after ad."); gameOverMessageP.innerHTML = originalMessage; if (restartButton) restartButton.disabled = false; if (watchAdButton) watchAdButton.disabled = false; }
             }).catch((error) => {
                 console.error("Ad failed to show/complete:", error); alert("Ad failed. Score not saved.");
                 gameOverMessageP.innerHTML = originalMessage; if (restartButton) restartButton.disabled = false; if (watchAdButton) watchAdButton.disabled = false;
             });
         }
        function startShake(intensity) { shakeIntensity = Math.max(shakeIntensity, intensity); }

        // --- Input Handling ---
        function onPointerDown(e){ let target = e.target; let isUI = false; if (headerBar.contains(target) || (sideMenu.classList.contains('open') && sideMenu.contains(target)) || (menuOverlayDimmer.classList.contains('visible') && target === menuOverlayDimmer) || (settingsPopup.style.display === 'block' && settingsPopup.contains(target)) || (profileOverlay.style.display === 'flex' && profileOverlay.contains(target)) || (withdrawalOverlay.style.display === 'flex' && withdrawalOverlay.contains(target)) || (friendsOverlay.style.display === 'flex' && friendsOverlay.contains(target)) || (tasksOverlay.style.display === 'flex' && tasksOverlay.contains(target)) || (gameOverUI.style.display === 'block' && gameOverUI.contains(target)) || (startGameModal.style.display === 'block' && startGameModal.contains(target)) || (announcementPopupEl.style.display === 'block' && announcementPopupEl.contains(target)) || (initialControlsContainer && !initialControlsContainer.classList.contains('hidden') && initialControlsContainer.contains(target)) || target.closest('.icon-button') || target.closest('button') || target.closest('a') || target.closest('input') || target.closest('select') || target.closest('.theme-switch') || target.closest('#referral-list-container') || target.closest('.withdrawal-accordion-header') ) { isUI = true; } if (target === renderer?.domElement && gameState === 'playing' && isTimedGameActive && !internalPauseState) { isUI = false; } else if (target === renderer?.domElement) { isUI = true; } if (isUI) { isPointerDown = false; } else { isPointerDown = true; previousPointerX = e.clientX ?? e.touches?.[0]?.clientX; if (previousPointerX === undefined) { isPointerDown = false; return; } document.body.style.cursor = 'grabbing'; if (e.cancelable && e.touches && gameContainer.contains(target)) { e.preventDefault(); } } }
        function onPointerMove(e){ if (!isPointerDown || gameState !== 'playing' || !isTimedGameActive || internalPauseState) return; const currentX = e.clientX ?? e.touches?.[0]?.clientX; if (currentX === undefined) return; const deltaX = currentX - previousPointerX; if (platformGroup) { platformGroup.rotation.y += deltaX * rotationSensitivity; } previousPointerX = currentX; if (e.cancelable && e.touches) { e.preventDefault(); } }
        function onPointerUp(e){ if (isPointerDown) { isPointerDown = false; document.body.style.cursor = 'default'; } }

        // --- Render Loop & Resize ---
        function onWindowResize() { if (!camera || !renderer || !gameContainer || !composer) return; const w = window.innerWidth; const h = window.innerHeight; if (w > 0 && h > 0) { camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h); composer.setSize(w, h); } else { console.warn("Window resize with zero dimensions."); } }
        function animateCameraZoom(targetZ, duration) { if (!camera || isCameraZooming) return; if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId); isCameraZooming = true; const startZ = camera.position.z; const startTime = performance.now(); function step(now) { const elapsed = now - startTime; const prog = Math.min(elapsed / duration, 1); const ease = t => t * (2 - t); const newZ = startZ + (targetZ - startZ) * ease(prog); camera.position.z = newZ; if (prog < 1) { cameraZoomRequestId = requestAnimationFrame(step); } else { camera.position.z = targetZ; isCameraZooming = false; cameraZoomRequestId = null; } } cameraZoomRequestId = requestAnimationFrame(step); }
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            if (starField && starField.visible) starField.rotation.y += dt * 0.01;

            if (gameState === 'playing' && isTimedGameActive && !internalPauseState) {
                updateBallPosition(); checkCollisions(); generatePlatforms();
                if (ball) { ballPreviousY = ball.position.y; }
            }
            if (gameState === 'playing' || gameState === 'gameOver') { updateFadingObjects(dt); }

            let camY = camera ? camera.position.y : (initialBallY + cameraVerticalOffset);
            let lookY = ball ? (ball.position.y + cameraLookAtOffset) : (initialBallY + cameraLookAtOffset);

            if (ball && camera && (gameState === 'playing' || gameState === 'gameOver')) {
                const targetCamY = ball.position.y + cameraVerticalOffset;
                const lerpedY = THREE.MathUtils.lerp(camera.position.y, targetCamY, cameraFollowLerpFactor * dt * 60);
                if (lerpedY < camera.position.y || (currentBallVelocityY > 0.05 && gameState === 'playing' && !internalPauseState) || ball.position.y < camera.position.y - cameraVerticalOffset - 2) { camY = lerpedY; }
                lookY = ball.position.y + cameraLookAtOffset;
            } else if (camera && gameState === 'ready') {
                camY = initialBallY + cameraVerticalOffset; lookY = initialBallY + cameraLookAtOffset;
                camera.position.y = camY; camera.lookAt(0, lookY, 0);
            }

            let shakeX = 0, shakeY = 0;
            if (shakeIntensity > 0.01) {
                shakeX = (Math.random() - 0.5) * 2 * maxShakeOffset * shakeIntensity; shakeY = (Math.random() - 0.5) * 2 * maxShakeOffset * shakeIntensity;
                if (gameState === 'playing' && isTimedGameActive && !internalPauseState) { shakeIntensity *= Math.pow(shakeDecreaseFactor, dt * 60); }
                else if (gameState !== 'playing') { shakeIntensity *= Math.pow(shakeDecreaseFactor * 0.8, dt * 60); }
            } else { shakeIntensity = 0; }

            if (camera && gameState !== 'ready') { camera.position.y = camY + shakeY; camera.position.x = 0 + shakeX; camera.lookAt(0 + shakeX, lookY + shakeY, 0); }
            else if (camera && gameState === 'ready') { camera.position.set(0, initialBallY + cameraVerticalOffset, camera.position.z); camera.lookAt(0, initialBallY + cameraLookAtOffset, 0); }

            if (composer) { composer.render(dt); }
            else if (renderer && scene && camera) { renderer.render(scene, camera); }
        }

        // --- Lifecycle Listeners ---
        document.addEventListener('DOMContentLoaded', init);
        window.addEventListener('beforeunload', () => { if (userRealtimeChannel) { supabase.removeChannel(userRealtimeChannel).then(() => console.log("Removed user channel on unload.")).catch(e => console.warn("Error removing channel on unload:", e)); } });

    </script>

</body>
</html>
