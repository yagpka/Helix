
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Helix Point Drop - Final Layout</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Base Styles --- */
        :root {
            --bg-dark: #111122;
            --bg-medium: #0a0a1a;
            --ui-panel-bg: rgba(15, 15, 35, 0.9);
            --text-light: #ffffff;
            --text-medium: #cccccc;
            --accent-cyan: #00cfde;
            --accent-cyan-hover: #00b3bf;
            --accent-pink: #ff4081;
            --accent-pink-hover: #d81b60;
            --accent-yellow: #f5d131;
            --accent-yellow-hover: #dbc02b;
            --danger-glow: #cc8400;
            /* SAFE_COLOR uses palette */
            --danger-color: var(--accent-yellow);
            --ball-color: var(--accent-pink);
            --pole-color: #679b31;
            --star-color: #aaaaee;
            --x-color: #000000; /* Or Twitter blue: #1DA1F2 */
            --x-color-hover: #333333; /* Darker grey or lighter blue */
        }

        * {
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }

        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(180deg, var(--bg-medium) 0%, var(--bg-dark) 100%);
            color: var(--text-light);
            touch-action: none; /* Disable default touch actions like pinch zoom */
            -webkit-user-select: none; /* Disable text selection */
            -ms-user-select: none;
            user-select: none;
            height: 100%;
            min-height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center; /* Center top bar horizontally */
            justify-content: flex-start; /* Keep top bar at the top */
        }

        /* --- Auth Container Base Styles --- */
        #auth-container {
            padding: 15px;
            padding-top: 10px; /* Reduced top padding */
            padding-bottom: 10px; /* Reduced bottom padding */
            background-color: rgba(10, 10, 25, 0.85);
            backdrop-filter: blur(4px);
            color: var(--text-light);
            z-index: 200; /* Above game, below modals */
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: static; /* Default: part of the flow */
            border-radius: 0 0 10px 10px; /* Default: top bar */
            width: 100%;
            max-width: 500px; /* Default: top bar */
            margin: 0 auto; /* Default: top bar horizontal centering */
            flex-shrink: 0; /* Default: doesn't shrink in body flex */
            position: relative; /* Needed for absolute positioning of pause/profile buttons */
        }

        /* --- Auth Container - LOGGED OUT (Centered) --- */
        #auth-container.logged-out {
            position: fixed; /* Position relative to viewport */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center it */
            width: 90%;
            max-width: 400px; /* Responsive width */
            border-radius: 15px; /* Rounder corners when centered */
            background-color: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(6px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            margin: 0;
            flex-shrink: initial; /* Not part of body flex layout */
            padding: 25px; /* More padding when centered */
        }

        /* --- Auth Container - LOGGED IN (Top Bar) --- */
        #auth-container.logged-in {
            position: static; /* Back to normal flow */
            top: auto;
            left: auto;
            transform: none;
            width: 100%;
            max-width: 500px;
            border-radius: 0 0 10px 10px;
            background-color: rgba(10, 10, 25, 0.85);
            backdrop-filter: blur(4px);
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
            margin: 0 auto;
            flex-shrink: 0;
            min-height: auto;
            align-items: center;
            padding: 10px 15px; /* Restore padding */
            padding-bottom: 5px; /* Slightly reduce bottom padding to accommodate button */
        }

        /* Control visibility based on logged-in/out state */
        #auth-container.logged-in #login-view,
        #auth-container.logged-in #signup-view {
            display: none;
        }
        #auth-container.logged-in #score-wrapper {
            display: flex; /* Show score when logged in */
        }
         #auth-container.logged-in #social-buttons-wrapper { /* UPDATED ID */
             display: flex; /* Show when logged in */
         }
        #auth-container.logged-in #profile-button {
            display: block; /* Show profile button */
        }
        #auth-container #pause-button {
             display: none; /* Start hidden, shown by JS based on game state */
        }

        #auth-container.logged-out #score-wrapper,
        #auth-container.logged-out #social-buttons-wrapper, /* UPDATED ID */
        #auth-container.logged-out #profile-button,
        #auth-container.logged-out #profile-panel,
        #auth-container.logged-out #pause-button { /* Ensure pause button is hidden when logged out */
            display: none;
        }
        #auth-container.logged-out #login-view,
        #auth-container.logged-out #signup-view {
            width: 100%;
            max-width: 350px;
        }


        /* --- Shared Auth Styles (Inputs, Buttons, etc.) --- */
        #auth-container h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--accent-yellow);
            text-align: center;
            font-weight: 700;
        }
        #auth-container input[type="email"],
        #auth-container input[type="password"] {
            display: block;
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background-color: rgba(255, 255, 255, 0.08);
            color: var(--text-light);
            border-radius: 5px;
            font-family: inherit;
            font-size: 1em;
        }
        #auth-container button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: var(--accent-cyan);
            color: #fff;
            font-family: inherit;
            font-weight: 700;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: inline-block;
            margin-top: 5px;
        }
        #auth-container button:hover {
            background-color: var(--accent-cyan-hover);
            transform: scale(1.03);
        }
        #auth-container button:active {
            transform: scale(0.98);
        }
        #auth-container p {
            margin-top: 15px;
            margin-bottom: 5px;
            text-align: center;
            font-size: 0.9em;
        }
        #auth-container .toggle-link {
            background: none;
            border: none;
            color: var(--accent-cyan);
            cursor: pointer;
            padding: 0;
            text-decoration: underline;
            font-size: inherit;
            margin-left: 5px;
            transition: color 0.2s ease;
        }
        #auth-container .toggle-link:hover {
            color: var(--accent-cyan-hover);
        }

        #auth-message {
            color: var(--accent-pink);
            min-height: 1.2em; /* Reserve space */
            text-align: center;
            font-weight: 700;
            margin-top: 5px;
            margin-bottom: 0;
            width: 100%;
            padding: 0 10px;
            background-color: transparent !important; /* Override other button styles if needed */
        }

        /* Score Display */
        #score-wrapper {
            width: 100%;
            max-width: 350px;
            justify-content: space-around;
            align-items: center;
            padding: 8px 0 4px 0;
            margin-top: 5px;
            border-top: none; /* Removed border */
        }
        .score-display {
            font-size: 1.8em;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
            text-align: center;
        }
        .score-label {
            font-size: 0.55em;
            display: block;
            opacity: 0.7;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* --- Social Buttons Wrapper --- */
        #social-buttons-wrapper { /* UPDATED ID */
            width: 100%;
            text-align: center; /* Center content horizontally */
            margin-top: 8px;
            margin-bottom: 5px;
            display: none; /* Hidden by default */
            justify-content: center; /* Center buttons with space */
            align-items: center;
            gap: 10px; /* Space between buttons */
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
        }

        /* --- NEW: Info Button Style (Can be reused) --- */
        .info-button {
             padding: 6px 15px; /* Slightly smaller padding */
             border: none;
             border-radius: 15px; /* More rounded */
             background-color: var(--accent-cyan);
             color: var(--text-light);
             font-family: inherit;
             font-weight: 700;
             font-size: 0.9em; /* Slightly smaller font */
             cursor: pointer;
             transition: background-color 0.2s ease, transform 0.1s ease;
             display: inline-flex; /* Use inline-flex for icon alignment */
             align-items: center;
             justify-content: center;
             box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
             margin-top: 0; /* Reset margin-top from auth button */
        }
        .info-button:hover {
            background-color: var(--accent-cyan-hover);
            transform: scale(1.04);
        }
        .info-button:active {
            transform: scale(0.97);
        }
        .info-button svg {
            margin-right: 5px;
            vertical-align: middle;
            width: 18px; /* Consistent icon size */
            height: 18px;
        }

        /* Apply info-button style to the telegram & X buttons */
        #telegram-button,
        #follow-x-button {
            /* Inherits .info-button styles */
        }
        /* Specific style for X button (optional) */
        #follow-x-button {
             background-color: var(--x-color); /* Black for X */
             color: white; /* White text */
        }
        #follow-x-button:hover {
             background-color: var(--x-color-hover); /* Slightly lighter black */
        }


        /* --- NEW: Pause Button --- */
        #pause-button {
            position: absolute;
            top: 10px; /* Align with profile button vertically */
            left: 15px; /* Position on the left */
            background: none;
            border: none;
            color: var(--accent-cyan); /* Use accent color */
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 40px; /* Same size as profile button */
            height: 40px;
            transition: background-color 0.2s ease, transform 0.2s ease;
            z-index: 210; /* Above auth container content, below profile panel */
            display: none; /* Initially hidden, shown by JS when game is playing */
        }
        #pause-button:hover {
             background-color: rgba(255, 255, 255, 0.1);
             transform: scale(1.1);
        }
        #pause-button svg {
             width: 100%;
             height: 100%;
        }

        /* Profile UI */
        #profile-button {
            display: none; /* Controlled by CSS .logged-in */
            position: absolute; /* Position relative to #auth-container */
            top: 10px; /* Align vertically */
            right: 15px; /* Position on the right */
            background: none;
            border: none;
            color: var(--accent-cyan);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            transition: background-color 0.2s ease, transform 0.2s ease;
            z-index: 210; /* Above auth container content */
        }
        #profile-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }
        #profile-button svg {
            width: 100%;
            height: 100%;
        }
        #profile-panel {
            display: none; /* Shown by JS */
            position: absolute; /* Relative to auth container */
            top: 60px; /* Position below the profile button */
            right: 15px;
            background-color: var(--ui-panel-bg);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
            z-index: 205; /* Above auth container, below modal */
            min-width: 200px;
            text-align: center;
        }
        #profile-panel p {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: var(--text-medium);
            word-break: break-all;
        }
        #profile-panel p:first-of-type {
            margin-bottom: 2px;
            opacity: 0.7;
            font-size: 0.8em;
        }
        #profile-panel button {
            display: block;
            width: 100%;
            margin-top: 10px;
            padding: 8px 10px;
            font-size: 0.9em;
        }
        #profile-panel #logout-button {
            background-color: var(--accent-pink);
        }
        #profile-panel #logout-button:hover {
            background-color: var(--accent-pink-hover);
            transform: scale(1.03);
        }
        #profile-panel #withdrawal-button {
            background-color: var(--accent-yellow);
            color: var(--bg-dark);
        }
        #profile-panel #withdrawal-button:hover {
            background-color: var(--accent-yellow-hover);
            transform: scale(1.03);
        }

        /* --- Game & Game Over --- */
        #game-container {
            position: relative; /* Needed if elements inside need absolute positioning */
            order: 1; /* Place below auth container in flex flow */
            flex-grow: 1; /* Takes remaining vertical space */
            width: 100%;
            min-height: 150px; /* Ensure some minimum height */
            overflow: hidden; /* Clip canvas if needed */
            z-index: 1; /* Below UI elements */
         }
        #game-canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 100%;
            image-rendering: -webkit-optimize-contrast; /* For potential pixel art (less relevant for 3D) */
            image-rendering: crisp-edges;
        }
        #game-over-ui {
            position: fixed; /* Overlay */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(15, 15, 35, 0.95);
            backdrop-filter: blur(5px);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 100; /* Below auth dropdown/modals */
            display: none; /* Hidden by default */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            width: 90%; /* Increased width slightly */
            max-width: 400px; /* Increased max-width */
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: auto; /* Allow interaction when visible */
        }
        #game-over-ui h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 2.1em;
            color: var(--accent-yellow);
            font-weight: 700;
        }
        #game-over-ui p#game-over-message { /* Added ID for targeting */
            font-size: 1.4em;
            margin-bottom: 25px;
            font-weight: 400;
            min-height: 1.5em; /* Reserve space for timer text */
        }
        #game-over-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 15px; /* Add space between buttons */
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
        }
        .game-over-button { /* Reusable class for modal buttons */
            padding: 12px 20px; /* Adjusted padding */
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: var(--accent-cyan);
            color: var(--text-light);
            font-size: 1.1em; /* Slightly smaller */
            font-weight: 700;
            transition: background-color .2s ease, transform 0.1s ease, box-shadow 0.2s ease, opacity 0.2s ease;
            pointer-events: auto;
            width: auto;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            flex-grow: 1; /* Allow buttons to grow */
            min-width: 120px; /* Ensure minimum width */
            text-align: center;
        }
        .game-over-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #555; /* Grey out disabled */
            transform: none;
            box-shadow: none;
        }
        .game-over-button:hover:not(:disabled) {
            background-color: var(--accent-cyan-hover);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
        }
        .game-over-button:active:not(:disabled) {
            transform: translateY(0px) scale(0.98);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        #watch-ad-button {
            background-color: var(--accent-yellow);
            color: var(--bg-dark); /* Dark text on yellow */
        }
        #watch-ad-button:hover:not(:disabled) {
            background-color: var(--accent-yellow-hover);
        }


        /* --- Withdrawal Modal Styles --- */
        #withdrawal-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(15, 15, 35, 0.95); /* Consistent background */
            backdrop-filter: blur(5px);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 300; /* Above profile panel (205) and auth container (200) */
            display: none; /* Hidden by default */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            width: 80%;
            max-width: 350px; /* Consistent width */
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: auto; /* Allow interaction */
            color: var(--text-light);
        }
        #withdrawal-modal h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.8em; /* Slightly smaller than game over */
            color: var(--accent-yellow);
            font-weight: 700;
        }
        #withdrawal-modal p {
            font-size: 1.1em; /* Adjust size as needed */
            margin-bottom: 25px;
            font-weight: 400;
            color: var(--text-medium);
        }
        #withdrawal-modal-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
        }
        #close-withdrawal-modal-button {
            /* Reuse generic class */
            /* No specific styles needed if using .modal-close-button */
        }


        /* --- Telegram Modal Styles --- */
        #telegram-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(15, 15, 35, 0.95); /* Consistent background */
            backdrop-filter: blur(5px);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 300; /* Same level as withdrawal modal */
            display: none; /* Hidden by default */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            width: 80%;
            max-width: 350px; /* Consistent width */
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: auto; /* Allow interaction */
            color: var(--text-light);
        }
        #telegram-modal h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.8em;
            color: var(--accent-cyan); /* Use cyan to match button */
            font-weight: 700;
        }
        #telegram-modal p {
            font-size: 1.1em;
            margin-bottom: 25px;
            font-weight: 400;
            color: var(--text-medium);
        }
        #telegram-modal-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 15px; /* Space between buttons */
            flex-wrap: wrap;
        }

        /* --- X (Twitter) Modal Styles --- */
        #x-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(15, 15, 35, 0.95); /* Consistent background */
            backdrop-filter: blur(5px);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 300; /* Same level as other modals */
            display: none; /* Hidden by default */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            width: 80%;
            max-width: 350px; /* Consistent width */
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: auto; /* Allow interaction */
            color: var(--text-light);
        }
        #x-modal h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.8em;
            color: var(--x-color); /* Use X color for title */
            font-weight: 700;
        }
        #x-modal p {
            font-size: 1.1em;
            margin-bottom: 25px;
            font-weight: 400;
            color: var(--text-medium);
        }
        #x-modal-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 15px; /* Space between buttons */
            flex-wrap: wrap;
        }

        /* --- Reusable Modal Button Styles (Combine from game-over/withdrawal/telegram/x) --- */
        .modal-action-button,
        .modal-close-button {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            color: var(--text-light);
            font-size: 1.0em;
            font-weight: 700;
            transition: background-color .2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            pointer-events: auto;
            width: auto;
            min-width: 110px; /* Ensure minimum width */
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            text-decoration: none; /* For anchor tags */
            display: inline-block; /* For anchor tags */
            text-align: center;
            flex-grow: 1; /* Allow buttons to grow */
        }
        .modal-action-button:hover,
        .modal-close-button:hover {
             transform: translateY(-2px) scale(1.02);
             box-shadow: 0 4px 8px rgba(0, 0, 0, 0.25);
        }
         .modal-action-button:active,
         .modal-close-button:active {
             transform: translateY(0px) scale(0.98);
             box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
         }

        /* Specific styles for Telegram modal buttons */
        #join-telegram-button.telegram-join {
            background-color: var(--accent-cyan); /* Cyan for join */
        }
        #join-telegram-button.telegram-join:hover {
            background-color: var(--accent-cyan-hover);
        }
        /* Specific styles for X modal buttons */
        #follow-x-link-button.x-follow {
            background-color: var(--x-color); /* X color for follow */
            color: white;
        }
        #follow-x-link-button.x-follow:hover {
            background-color: var(--x-color-hover);
        }

        /* Generic Close Button Style */
        #close-telegram-modal-button,
        #close-withdrawal-modal-button,
        #close-x-modal-button { /* Added X modal close button */
            background-color: var(--accent-pink); /* Pink for close */
        }
        #close-telegram-modal-button:hover,
        #close-withdrawal-modal-button:hover,
        #close-x-modal-button:hover { /* Added X modal close button hover */
            background-color: var(--accent-pink-hover);
        }


        /* --- Pause Modal Styles --- */
        #pause-modal {
            position: fixed; /* Overlay */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(15, 15, 35, 0.95); /* Consistent with other modals */
            backdrop-filter: blur(5px);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 250; /* Above profile panel, below withdrawal/telegram/x modal */
            display: none; /* Hidden by default */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            width: 80%;
            max-width: 350px; /* Consistent width */
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: auto; /* Allow interaction when visible */
            color: var(--text-light);
        }
        #pause-modal h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 2.0em; /* Similar to game over */
            color: var(--accent-cyan); /* Use cyan for pause */
            font-weight: 700;
        }
        #pause-modal p {
            font-size: 1.4em; /* Match game over score display size */
            margin-bottom: 25px;
            font-weight: 400;
        }
        #pause-modal-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: center;
        }
        /* Resume button can reuse .game-over-button styles */
        #resume-button {
             /* Uses .game-over-button styles */
        }

    </style>

</head>
<body>

    <!-- Auth Container: Starts centered, moves to top bar on login -->
    <div id="auth-container" class="logged-out"> <!-- Start logged-out -->
        <!-- Login Form -->
        <div id="login-view">
            <h3>Login</h3>
            <input type="email" id="login-email" placeholder="Email" autocomplete="email">
            <input type="password" id="login-password" placeholder="Password" autocomplete="current-password">
            <button id="login-button">Login</button>
            <p>No account? <button id="show-signup-button" class="toggle-link">Sign Up</button></p>
        </div>
        <!-- Signup Form -->
        <div id="signup-view" style="display: none;">
            <h3>Sign Up</h3>
            <input type="email" id="signup-email" placeholder="Email" autocomplete="email">
            <input type="password" id="signup-password" placeholder="New Password" autocomplete="new-password">
            <button id="signup-button">Sign Up</button>
            <p>Have an account? <button id="show-login-button" class="toggle-link">Login</button></p>
        </div>

        <!-- Score Display (Visible when logged in) -->
        <div id="score-wrapper">
            <div class="score-display">
                <span class="score-label">Current</span>
                <span id="current-score">0</span>
            </div>
            <div class="score-display">
                <span class="score-label">Total</span>
                <span id="total-score">...</span>
            </div>
        </div>

        <!-- Social Buttons (Visible when logged in) -->
        <div id="social-buttons-wrapper">  <!-- UPDATED ID -->
            <button id="telegram-button" class="info-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.17.91-.497 1.208-.82 1.23-.696.047-1.225-.46-1.9-.91-.546-.353-1.075-.688-1.758-1.104l-.108-.061c-1.218-.78-1.896-1.182-1.736-1.889.05-.212.333-.717.333-.717l.11-.24s4.17-3.8 4.576-4.18c.07-.07.12-.15.05-.23-.07-.08-.18-.05-.25-.02-.11.04-1.88 1.16-5.36 3.34-.47.29-.88.43-1.28.42-.49-.01-.97-.13-1.42-.25-1.03-.28-1.88-.42-1.79-.93.04-.22.31-.42.88-.63 3.41-1.22 5.68-2.07 6.94-2.51.3-.11.56-.2.78-.2z"/>
                </svg>
                Join Telegram
            </button>
            <!-- NEW X Button -->
            <button id="follow-x-button" class="info-button">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                   <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                </svg>
                Follow X
            </button>
        </div>

        <!-- Pause Button (Positioned absolutely, visibility controlled by JS) -->
        <button id="pause-button" aria-label="Pause Game">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                 <path fill-rule="evenodd" d="M6.75 5.25a.75.75 0 0 0-.75.75V18a.75.75 0 0 0 .75.75h.75a.75.75 0 0 0 .75-.75V6a.75.75 0 0 0-.75-.75H6.75Zm8.25 0a.75.75 0 0 0-.75.75V18a.75.75 0 0 0 .75.75h.75a.75.75 0 0 0 .75-.75V6a.75.75 0 0 0-.75-.75H15Z" clip-rule="evenodd" />
             </svg>
        </button>

        <!-- Profile Button & Panel (Visible when logged in, positioned absolutely) -->
        <button id="profile-button" aria-label="Profile Options">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                 <path fill-rule="evenodd" d="M18.685 19.097A9.723 9.723 0 0 0 21.75 12c0-5.385-4.365-9.75-9.75-9.75S2.25 6.615 2.25 12a9.723 9.723 0 0 0 3.065 7.097A9.716 9.716 0 0 0 12 21.75a9.716 9.716 0 0 0 6.685-2.653Zm-12.54-1.285A7.486 7.486 0 0 1 12 15a7.486 7.486 0 0 1 5.855 2.812A8.224 8.224 0 0 1 12 20.25a8.224 8.224 0 0 1-5.855-2.438ZM15.75 9a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" clip-rule="evenodd" />
             </svg>
        </button>
        <div id="profile-panel">
            <p>Logged in as:</p>
            <p><strong id="user-email-display" style="color: var(--accent-cyan);"></strong></p>
            <button id="withdrawal-button">withdrawal</button>
            <button id="logout-button">Logout</button>
        </div>

        <!-- Auth Messages -->
        <p id="auth-message"></p>
    </div>

    <!-- Game Over UI -->
    <div id="game-over-ui">
        <h2>Game Over!</h2>
        <p id="game-over-message">Score: <span id="final-score">0</span></p>
        <div id="game-over-buttons">
            <button id="watch-ad-button" class="game-over-button" style="display: none;">
                Watch Ad & Save
            </button>
            <button id="restart-button" class="game-over-button">
                Restart
            </button>
        </div>
    </div>

    <!-- Withdrawal Modal -->
    <div id="withdrawal-modal">
        <h2>Withdrawal</h2>
        <p>Withdrawal system to be announced soon.</p>
        <div id="withdrawal-modal-buttons">
            <button id="close-withdrawal-modal-button" class="modal-close-button">Close</button>
        </div>
    </div>

    <!-- Telegram Modal -->
    <div id="telegram-modal">
        <h2>Join Telegram</h2>
        <p>Join our Telegram channel for future updates and announcements!</p>
        <div id="telegram-modal-buttons">
            <a href="https://t.me/helix_cryptodrop" target="_blank" rel="noopener noreferrer" id="join-telegram-button" class="modal-action-button telegram-join">
                Join Channel
            </a>
            <button id="close-telegram-modal-button" class="modal-close-button">Close</button>
        </div>
    </div>

    <!-- X (Twitter) Modal - NEW -->
    <div id="x-modal">
        <h2>Follow on X</h2>
        <p>Follow us on X (formerly Twitter) for the latest news!</p>
        <div id="x-modal-buttons">
            <a href="https://x.com/drop_official89?t=lJ9kaQKLwWQk41avHSJdhw&s=08" target="_blank" rel="noopener noreferrer" id="follow-x-link-button" class="modal-action-button x-follow">
                Follow Us
            </a>
            <button id="close-x-modal-button" class="modal-close-button">Close</button>
        </div>
    </div>

    <!-- Pause Modal -->
    <div id="pause-modal">
        <h2>Paused</h2>
        <p>Score: <span id="pause-current-score">0</span></p>
        <div id="pause-modal-buttons">
            <button id="resume-button" class="game-over-button">Resume</button> <!-- Reuses styling -->
        </div>
    </div>


    <!-- Game Container -->
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>

    <!-- Audio Elements (Hidden) -->
    <!-- Make sure these files exist or update paths -->
    <audio id="bg-music" src="background.mp3" preload="auto" loop></audio>
    <audio id="ui-tap-sound" src="uitapping.mp3" preload="auto"></audio>
    <audio id="platform-destruction-sound" src="platformdestruction.mp3" preload="auto"></audio>
    <audio id="bounce-sound" src="bounce.mp3" preload="auto"></audio>
    <audio id="game-start-sound" src="game-start-.mp3" preload="auto"></audio>
    <audio id="game-over-sound" src="game-over.mp3" preload="auto"></audio>


    <!-- Libraries & SDKs -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

    <!-- AD SCRIPT -->
    <script type='text/javascript' src='https://pl26492184.profitableratecpm.com/ff/35/a9/ff35a9afa8af54896e4a160afe339513.js'></script>


    <!-- Game Logic (as module) -->
    <script type="module">

        // --- Imports ---
        import * as THREE from 'three';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { TextureLoader } from 'three';

        // --- Global Variables ---
        let scene, camera, renderer, composer, bloomPass;
        let ball, platformGroup, poleGroup, starField;
        let currentScore = 0;
        let gameState = 'loggedOut'; // Start as logged out
        let rotationSensitivity = 0.02, bounceSpeed = 0.11;
        let currentBallVelocityY = 0, ballPreviousY = 0, lastSafePlatformY = 0;
        const gravity = -0.0035;
        const platformRadius = 2.5, poleRadius = 0.5, gapSize = Math.PI / 2.5;
        const platformSegments = 3, platformSpacingY = 2.0;
        let activePlatforms = [], nextPlatformY = 0;
        let activePoleSegments = {};
        let scoreIncrementedForPlatform = {};
        const ballStartX = 1.5; const ballStartZ = 0; const initialBallY = 8;
        const cameraVerticalOffset = 4.5, cameraLookAtOffset = 1.0;
        const cameraFixedZ = 11; const cameraZoomedInZ = 9.5; const cameraZoomDuration = 600;
        let isCameraZooming = false; let cameraZoomRequestId = null;
        const cameraFollowLerpFactor = 0.08;
        let envMap = null;
        const clock = new THREE.Clock();
        let ballTexture = null;
        const textureLoader = new TextureLoader();
        const particlePool = []; const activeParticles = [];
        const PARTICLE_COUNT = 200;
        const particleBaseMaterial = new THREE.SpriteMaterial({ color: 0xffffff, sizeAttenuation: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        const FADE_DURATION = 200;
        const BOUNCE_PARTICLE_LIFETIME = 0.6;
        const TRAIL_PARTICLE_LIFETIME = 0.35;
        const platformColorPalette = [ 0x00cfde, 0x8e44ad, 0x3498db, 0x2ecc71, 0xe74c3c, 0xf39c12 ];
        let platformColorIndex = 0;
        const DANGER_COLOR = 0xf5d131; const BALL_COLOR = 0xff4081;
        const POLE_COLOR = 0x679b31; const BG_COLOR = 0x0a0a1a; const DANGER_EMISSIVE_COLOR = 0xcc8400;
        const STAR_COLOR = 0xaaaaee;
        let shakeIntensity = 0; const shakeDecreaseFactor = 0.9; const maxShakeOffset = 0.15;
        let isPointerDown = false; let previousPointerX = 0;
        let adTimerIntervalId = null;

        // --- Audio Variables ---
        let audioContext = null;
        let audioBuffers = {};
        let bgMusic = null;
        let isAudioInitialized = false;
        let isBgMusicPlaying = false;
        const SOUND_EFFECT_VOLUME = 0.6;
        const MUSIC_VOLUME = 0.3;

        // --- Element References ---
        const currentScoreEl = document.getElementById('current-score');
        const totalScoreEl = document.getElementById('total-score');
        const scoreWrapper = document.getElementById('score-wrapper');
        const gameOverUI = document.getElementById('game-over-ui');
        const finalScoreEl = document.getElementById('final-score');
        const gameOverMessageP = document.getElementById('game-over-message');
        const restartButton = document.getElementById('restart-button');
        const watchAdButton = document.getElementById('watch-ad-button');
        const gameContainer = document.getElementById('game-container');
        const authContainer = document.getElementById('auth-container');
        const loginView = document.getElementById('login-view');
        const signupView = document.getElementById('signup-view');
        const loginEmailInput = document.getElementById('login-email');
        const loginPasswordInput = document.getElementById('login-password');
        const loginButton = document.getElementById('login-button');
        const signupEmailInput = document.getElementById('signup-email');
        const signupPasswordInput = document.getElementById('signup-password');
        const signupButton = document.getElementById('signup-button');
        const showSignupButton = document.getElementById('show-signup-button');
        const showLoginButton = document.getElementById('show-login-button');
        const authMessage = document.getElementById('auth-message');
        const profileButton = document.getElementById('profile-button');
        const profilePanel = document.getElementById('profile-panel');
        const userEmailDisplay = document.getElementById('user-email-display');
        const logoutButton = document.getElementById('logout-button');
        const withdrawalButton = document.getElementById('withdrawal-button');
        const withdrawalModal = document.getElementById('withdrawal-modal');
        const closeWithdrawalModalButton = document.getElementById('close-withdrawal-modal-button');
        const pauseButton = document.getElementById('pause-button');
        const pauseModal = document.getElementById('pause-modal');
        const resumeButton = document.getElementById('resume-button');
        const pauseCurrentScoreEl = document.getElementById('pause-current-score');
        const telegramButton = document.getElementById('telegram-button');
        const socialButtonsWrapper = document.getElementById('social-buttons-wrapper'); // UPDATED ID
        const telegramModal = document.getElementById('telegram-modal');
        const closeTelegramModalButton = document.getElementById('close-telegram-modal-button');
        const followXButton = document.getElementById('follow-x-button'); // NEW
        const xModal = document.getElementById('x-modal'); // NEW
        const closeXModalButton = document.getElementById('close-x-modal-button'); // NEW
        // NOTE: Audio element refs obtained later in initAudioContext

        // --- Firebase Setup ---
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // !!! IMPORTANT: REPLACE ALL VALUES BELOW WITH YOUR ACTUAL FIREBASE CONFIG !!!
        // !!!   Get these from your Firebase Project Settings > General > Your apps  !!!
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        const firebaseConfig = {
            apiKey: "AIzaSyCIYBPkVduy16dcYQ9PaSIc58BsNVamsO0", // Replace with your actual API Key
            authDomain: "helix-cryptodrop.firebaseapp.com",
            databaseURL: "https://helix-cryptodrop-default-rtdb.firebaseio.com", // Replace if different
            projectId: "helix-cryptodrop",
            storageBucket: "helix-cryptodrop.firebasestorage.app", // Replace if different
            messagingSenderId: "981063831600",
            appId: "1:981063831600:web:2628901c5186a635e65df5" // Replace if different
        };
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // !!!     END OF FIREBASE CONFIG - MAKE SURE YOU REPLACED THE VALUES     !!!
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        let app, auth, db;
        let currentUserUid = null;
        let currentUserTotalScore = 0;
        let userScoreRef = null;
        let userScoreListener = null;

        // --- UI Update Helpers ---
        function updateScoreUI() {
            if (currentScoreEl) currentScoreEl.textContent = currentScore;
            if (pauseModal && pauseModal.style.display === 'block' && pauseCurrentScoreEl) {
                 pauseCurrentScoreEl.textContent = currentScore;
            }
        }
        function updateTotalScoreUI(score) {
            if (totalScoreEl) totalScoreEl.textContent = String(score);
        }

        // --- Audio Functions ---
        async function initAudioContext() {
            if (isAudioInitialized) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') {
                    console.log("AudioContext suspended, attempting to resume...");
                    await audioContext.resume();
                }
                console.log("AudioContext Initialized/Resumed. State:", audioContext.state);
                isAudioInitialized = true;
                bgMusic = document.getElementById('bg-music');
                if (bgMusic) {
                    bgMusic.volume = MUSIC_VOLUME;
                    console.log("Background music element found.");
                } else {
                    console.error("Background music element (#bg-music) not found!");
                }
                await loadSoundEffects();
            } catch (e) {
                console.error("Error initializing AudioContext:", e);
                isAudioInitialized = false;
            }
        }

        async function loadSoundEffects() {
            if (!audioContext) {
                console.error("Cannot load sound effects: AudioContext not available.");
                return;
            }
            const soundFiles = {
                tap: 'uitapping.mp3',
                destroy: 'platformdestruction.mp3',
                bounce: 'bounce.mp3',
                start: 'game-start-.mp3', // Verify filename
                over: 'game-over.mp3' // Verify filename
            };
            console.log("Loading sound effects...");
            const loadPromises = Object.entries(soundFiles).map(async ([key, path]) => {
                try {
                    const response = await fetch(path);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status} for ${path}`);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await new Promise((resolve, reject) => {
                         audioContext.decodeAudioData(arrayBuffer, resolve, reject);
                    });
                    audioBuffers[key] = audioBuffer;
                    console.log(`Loaded sound: ${key} from ${path}`);
                } catch (error) {
                    console.error(`Failed to load or decode sound '${key}' from ${path}:`, error);
                    audioBuffers[key] = null;
                }
            });
            await Promise.all(loadPromises);
            console.log("Sound effect loading process complete.");
        }

        function playSound(key, volume = SOUND_EFFECT_VOLUME) {
            if (!isAudioInitialized || !audioContext || audioContext.state !== 'running' || !audioBuffers[key]) {
                return; // Silently fail if audio not ready
            }
            try {
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffers[key];
                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                source.start(0);
                source.onended = () => {
                    source.disconnect();
                    gainNode.disconnect();
                };
            } catch (e) {
                console.error(`Error playing sound '${key}':`, e);
            }
        }

        function playTapSound() { playSound('tap', 0.5); }
        function playBackgroundMusic() {
            if (bgMusic && !isBgMusicPlaying && isAudioInitialized && audioContext?.state === 'running') {
                bgMusic.play().then(() => { isBgMusicPlaying = true; console.log("Background music started."); })
                    .catch(error => { isBgMusicPlaying = false; console.warn("Error playing background music:", error); });
            }
        }
        function stopBackgroundMusic() {
            if (bgMusic) { bgMusic.pause(); bgMusic.currentTime = 0; }
            if (isBgMusicPlaying) { isBgMusicPlaying = false; console.log("Background music stopped."); }
        }
        function pauseBackgroundMusic() {
            if (bgMusic && isBgMusicPlaying) { bgMusic.pause(); isBgMusicPlaying = false; console.log("Background music paused."); }
        }

        // --- Firebase Functions ---
        function initializeFirebaseApp() {
            try {
                // Check for placeholder values
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey.startsWith("YOUR_") || firebaseConfig.apiKey.length < 10) {
                     throw new Error("Firebase config is missing or contains placeholder values! Please replace them in the script.");
                }

                if (!firebase.apps.length) {
                    app = firebase.initializeApp(firebaseConfig);
                } else {
                    app = firebase.app(); // Get default app if already initialized
                }
                auth = firebase.auth();
                db = firebase.database();
                console.log("Firebase Initialized OK");
                setupAuthListeners(); // Setup listeners after successful init
            } catch (e) {
                console.error("Firebase Initialization Failed:", e); // Log the actual error object
                const errorMessage = e.message || "Service Connection Error."; // Get specific message if available
                authMessage.textContent = `Init Error: ${errorMessage}`;
                updateTotalScoreUI("Error");
                // Set UI to logged-out state robustly
                authContainer.classList.remove('logged-in');
                authContainer.classList.add('logged-out');
                loginView.style.display = 'block';
                signupView.style.display = 'none';
                scoreWrapper.style.display = 'none';
                if (socialButtonsWrapper) socialButtonsWrapper.style.display = 'none'; // UPDATED ID
                profileButton.style.display = 'none';
                profilePanel.style.display = 'none';
                pauseButton.style.display = 'none';
                gameState = 'loggedOut'; // Set game state
            }
        }

        function setupAuthListeners() {
            if (!auth) {
                console.warn("Firebase Auth not available, skipping listeners.");
                gameState = 'loggedOut';
                stopBackgroundMusic();
                return;
            }

            auth.onAuthStateChanged(async user => {
                if (user) { // Logged In
                    console.log("Auth State Changed: Logged In -", user.uid);
                    currentUserUid = user.uid;
                    authMessage.textContent = '';
                    await initAudioContext(); // Init audio on login

                    loginView.style.display = 'none';
                    signupView.style.display = 'none';
                    scoreWrapper.style.display = 'flex';
                    if (socialButtonsWrapper) socialButtonsWrapper.style.display = 'flex'; // UPDATED ID + use flex
                    profileButton.style.display = 'block';
                    profilePanel.style.display = 'none';
                    userEmailDisplay.textContent = user.email || 'User';
                    authContainer.classList.remove('logged-out');
                    authContainer.classList.add('logged-in');
                    pauseButton.style.display = 'none';

                    listenToUserScore(currentUserUid);
                    console.log("Resetting game on login...");
                    await resetGame(); // Async reset

                    setTimeout(() => {
                        onWindowResize();
                        console.log("Triggering camera zoom...");
                        animateCameraZoom(cameraZoomedInZ, cameraZoomDuration);
                    }, 100);

                } else { // Logged Out
                    console.log("Auth State Changed: Logged Out");
                    currentUserUid = null;
                    currentUserTotalScore = 0;
                    gameState = 'loggedOut';
                    stopBackgroundMusic();

                    if (userScoreRef && userScoreListener) {
                        userScoreRef.off('value', userScoreListener);
                        userScoreRef = null; userScoreListener = null;
                        console.log("Firebase score listener detached.");
                    }
                    authMessage.textContent = '';

                    loginView.style.display = 'block';
                    signupView.style.display = 'none';
                    profilePanel.style.display = 'none';
                    if(withdrawalModal) withdrawalModal.style.display = 'none';
                    if (telegramModal) telegramModal.style.display = 'none';
                    if (xModal) xModal.style.display = 'none'; // Hide X modal on logout
                    if(pauseModal) pauseModal.style.display = 'none';
                    pauseButton.style.display = 'none';
                    if (socialButtonsWrapper) socialButtonsWrapper.style.display = 'none'; // UPDATED ID
                    authContainer.classList.remove('logged-in');
                    authContainer.classList.add('logged-out');

                    updateTotalScoreUI('...');
                    currentScore = 0; updateScoreUI();
                    if(gameOverUI) gameOverUI.style.display = 'none';
                    if (restartButton) restartButton.disabled = true;
                    if (watchAdButton) watchAdButton.style.display = 'none';

                    if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId); cameraZoomRequestId = null;
                    if (camera) camera.position.z = cameraFixedZ; isCameraZooming = false;
                    console.log("Game inactive on logout.");

                    setTimeout(onWindowResize, 50);
                }
            });

            // --- Button Event Listeners ---
            loginButton.addEventListener('click', handleLogin);
            signupButton.addEventListener('click', handleSignup);
            showSignupButton.addEventListener('click', () => {
                loginView.style.display = 'none'; signupView.style.display = 'block'; authMessage.textContent = '';
            });
            showLoginButton.addEventListener('click', () => {
                signupView.style.display = 'none'; loginView.style.display = 'block'; authMessage.textContent = '';
            });
            logoutButton.addEventListener('click', handleLogout);
            withdrawalButton.addEventListener('click', handleWithdrawal);
            profileButton.addEventListener('click', (e) => {
                e.stopPropagation();
                profilePanel.style.display = profilePanel.style.display === 'block' ? 'none' : 'block';
                // Close other modals if profile is opened
                if (profilePanel.style.display === 'block') {
                     if (pauseModal.style.display === 'block') { resumeGame(); } // Resume if paused
                     if (telegramModal) telegramModal.style.display = 'none';
                     if (xModal) xModal.style.display = 'none';
                     if (withdrawalModal) withdrawalModal.style.display = 'none';
                }
            });
            document.addEventListener('click', (e) => {
                if (profilePanel.style.display === 'block' && !profilePanel.contains(e.target) && !profileButton.contains(e.target)) { profilePanel.style.display = 'none'; }
                // Close pause modal on outside click (if not clicking the button)
                if (pauseModal.style.display === 'block' && !pauseModal.contains(e.target) && !pauseButton.contains(e.target)) { resumeGame(); }
                // Close other modals on outside click (optional, uncomment if desired)
                // if (telegramModal && telegramModal.style.display === 'block' && !telegramModal.contains(e.target)) { telegramModal.style.display = 'none'; }
                // if (xModal && xModal.style.display === 'block' && !xModal.contains(e.target)) { xModal.style.display = 'none'; }
                // if (withdrawalModal && withdrawalModal.style.display === 'block' && !withdrawalModal.contains(e.target)) { withdrawalModal.style.display = 'none'; }
            });
            // Prevent clicks inside panels/modals from closing them
            profilePanel.addEventListener('click', (e) => e.stopPropagation());
            pauseModal.addEventListener('click', (e) => e.stopPropagation());
            withdrawalModal.addEventListener('click', (e) => e.stopPropagation());
            if (telegramModal) telegramModal.addEventListener('click', (e) => e.stopPropagation());
            if (xModal) xModal.addEventListener('click', (e) => e.stopPropagation()); // NEW

            if (closeWithdrawalModalButton && withdrawalModal) {
                closeWithdrawalModalButton.addEventListener('click', () => { withdrawalModal.style.display = 'none'; });
            } else { console.error("Could not find Withdrawal Modal or its close button."); }

            if (pauseButton) { pauseButton.addEventListener('click', pauseGame); } else { console.error("Pause button element not found!"); }
            if (resumeButton) { resumeButton.addEventListener('click', resumeGame); } else { console.error("Resume button element not found!"); }
            if (watchAdButton) { watchAdButton.addEventListener('click', handleWatchAd); } else { console.error("Watch Ad button element not found!"); }

            // --- Telegram Button Listener ---
            if (telegramButton && telegramModal && closeTelegramModalButton) {
                telegramButton.addEventListener('click', () => {
                    console.log("Telegram button clicked");
                    profilePanel.style.display = 'none'; // Close profile panel
                    if (gameState === 'playing') { pauseGame(); } // Pause the game
                    if (xModal) xModal.style.display = 'none'; // Close X modal if open
                    if (withdrawalModal) withdrawalModal.style.display = 'none'; // Close withdrawal modal
                    telegramModal.style.display = 'block';
                });

                closeTelegramModalButton.addEventListener('click', () => {
                     telegramModal.style.display = 'none';
                     // Do NOT automatically resume game here
                });
            } else {
                console.error("Could not find Telegram button or modal elements.");
            }

            // --- X Button Listener - NEW ---
            if (followXButton && xModal && closeXModalButton) {
                 followXButton.addEventListener('click', () => {
                     console.log("Follow X button clicked");
                     profilePanel.style.display = 'none'; // Close profile panel
                     if (gameState === 'playing') { pauseGame(); } // Pause the game
                     if (telegramModal) telegramModal.style.display = 'none'; // Close Telegram modal if open
                     if (withdrawalModal) withdrawalModal.style.display = 'none'; // Close withdrawal modal
                     xModal.style.display = 'block';
                 });

                 closeXModalButton.addEventListener('click', () => {
                     xModal.style.display = 'none';
                     // Do NOT automatically resume game here
                 });
            } else {
                 console.error("Could not find X button or modal elements.");
            }


         } // End of setupAuthListeners

        function handleLogin() {
             if (!auth) { authMessage.textContent = "Auth Service Unavailable"; return; }
             const email = loginEmailInput.value.trim();
             const password = loginPasswordInput.value;
             if (!email || !password) { authMessage.textContent = 'Email and Password required.'; return; }
             authMessage.textContent = 'Logging in...';
             auth.signInWithEmailAndPassword(email, password)
                 .then((userCredential) => {
                     console.log("Login Successful:", userCredential.user.uid);
                     authMessage.textContent = '';
                     loginEmailInput.value = '';
                     loginPasswordInput.value = '';
                     // onAuthStateChanged handles rest
                 })
                 .catch((error) => {
                     console.error("Login Error:", error);
                     authMessage.textContent = `Login Failed: ${error.message}`;
                 });
        }

        function handleSignup() {
             if (!auth) { authMessage.textContent = "Auth Service Unavailable"; return; }
             const email = signupEmailInput.value.trim();
             const password = signupPasswordInput.value;
             if (!email || !password) { authMessage.textContent = 'Email and Password required.'; return; }
             if (password.length < 6) { authMessage.textContent = 'Password must be at least 6 characters.'; return; }
             authMessage.textContent = 'Signing up...';
             auth.createUserWithEmailAndPassword(email, password)
                 .then((userCredential) => {
                     const user = userCredential.user;
                     console.log("Signup Successful:", user.uid);
                     authMessage.textContent = 'Signup Successful! Logging in...';
                     signupEmailInput.value = '';
                     signupPasswordInput.value = '';
                     // Create initial user data
                     if (db) {
                         const userRef = db.ref('users/' + user.uid);
                         userRef.set({
                             email: user.email,
                             createdAt: firebase.database.ServerValue.TIMESTAMP,
                             totalScore: 0
                         })
                         .then(() => console.log("User data created in DB."))
                         .catch(dbError => console.error("Error creating user data in DB:", dbError));
                     } else {
                         console.warn("Database service unavailable, skipping initial data creation.");
                     }
                     // onAuthStateChanged handles rest
                 })
                 .catch((error) => {
                     console.error("Signup Error:", error);
                     authMessage.textContent = `Signup Failed: ${error.message}`;
                 });
        }

        function handleLogout() {
             if (!auth) { authMessage.textContent = "Auth Service Unavailable"; return; }
             authMessage.textContent = 'Logging out...';
             profilePanel.style.display = 'none';
             auth.signOut()
                 .then(() => {
                     console.log("Logout Successful");
                     authMessage.textContent = '';
                      // onAuthStateChanged handles rest
                 })
                 .catch((error) => {
                     console.error("Logout Error:", error);
                     authMessage.textContent = `Logout Failed: ${error.message}`;
                 });
        }

        function handleWithdrawal() {
             console.log("Withdrawal button clicked");
             profilePanel.style.display = 'none';
             if (withdrawalModal) {
                 if (gameState === 'playing') { pauseGame(); } // Pause the game first
                 if (telegramModal) telegramModal.style.display = 'none'; // Close others
                 if (xModal) xModal.style.display = 'none'; // Close others
                 withdrawalModal.style.display = 'block';
             } else {
                 console.error("Withdrawal modal element not found!");
                 authMessage.textContent = 'Withdrawal info unavailable.';
             }
        }

        function listenToUserScore(uid) {
            if (!db) { console.warn("Database service unavailable, cannot listen to score."); updateTotalScoreUI("N/A"); return; }
            if (userScoreRef && userScoreListener) { userScoreRef.off('value', userScoreListener); console.log("Detached previous score listener."); }
            userScoreRef = db.ref('users/' + uid + '/totalScore');
            console.log("Setting up score listener for user:", uid);
            userScoreListener = userScoreRef.on('value', (snapshot) => {
                let score = 0;
                if (snapshot.exists()) {
                    const val = snapshot.val();
                    // Check type and NaN robustly
                    if (typeof val === 'number' && !isNaN(val)) {
                        score = Math.floor(val); // Ensure integer score
                    } else {
                         console.warn("Invalid score format in DB:", val, "- resetting to 0.");
                         // Attempt to fix in DB
                         snapshot.ref.set(0).catch(e => console.error("Error resetting invalid score in DB:", e));
                         score = 0;
                    }
                } else {
                    console.log("Score node doesn't exist for user, initializing to 0.");
                    // Create node in DB
                     snapshot.ref.set(0).catch(e => console.error("Error initializing score node in DB:", e));
                     score = 0;
                }
                currentUserTotalScore = score;
                console.log("Total Score Updated from DB:", currentUserTotalScore);
                updateTotalScoreUI(currentUserTotalScore);
            }, (error) => {
                console.error("Error listening to score:", error);
                updateTotalScoreUI("DB Err");
                userScoreRef = null; userScoreListener = null; // Reset on error
            });
        }

        function updateUserTotalScore(scoreToAdd) {
            if (!db || !currentUserUid || typeof scoreToAdd !== 'number' || isNaN(scoreToAdd) || scoreToAdd <= 0) {
                console.warn("Invalid conditions for updating score in DB:", { db: !!db, uid: currentUserUid, scoreToAdd });
                return Promise.resolve(); // Resolve immediately if conditions not met
            }
            // Calculate new score based on the potentially updated currentUserTotalScore from listener
            const newTotalScore = Math.floor(currentUserTotalScore + scoreToAdd); // Ensure integer

            // --- IMPORTANT: Update local state FIRST for immediate UI feedback ---
            // Even if DB write fails, the UI shows the attempted update.
            // The listener will eventually correct it if the write fails and reads the old value.
            currentUserTotalScore = newTotalScore;
            updateTotalScoreUI(currentUserTotalScore);
            // ---

            const userTotalScoreRef = db.ref('users/' + currentUserUid + '/totalScore');
            console.log(`Attempting to update Firebase totalScore to: ${newTotalScore}`);
            return userTotalScoreRef.set(newTotalScore)
                .then(() => { console.log("Firebase totalScore updated successfully."); })
                .catch((error) => {
                    console.error("Error updating totalScore in Firebase:", error);
                    // Optional: You could try to revert the local UI update here, but the listener
                    // should eventually correct it by reading the actual DB value.
                    return Promise.reject(error); // Propagate the error
                });
        }


        // --- Core Game Logic ---

        function init() {
            console.log("Initializing Game...");
            // Scene, Camera, Renderer
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = cameraFixedZ;

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true, alpha: true });
            renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

            // Post Processing
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            bloomPass = new UnrealBloomPass(new THREE.Vector2(gameContainer.clientWidth, gameContainer.clientHeight), 0.6, 0.5, 0.8);
            composer.addPass(bloomPass);

            // Lighting
            scene.add(new THREE.HemisphereLight(0xccccff, 0x555599, 0.7));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(5, 8, 6);
            scene.add(dirLight);
            scene.add(new THREE.AmbientLight(0x404040, 0.6));

            // Environment & Textures
            // Replace 'back.hdr' with your actual HDR file path if you have one
            new RGBELoader().load('back.hdr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture; envMap = texture; if (ball) createBall(); console.log("Environment map loaded.");
            }, undefined, (error) => {
                console.warn("HDR map not found or failed to load, using fallback background.", error);
                if (!scene.background) scene.background = new THREE.Color(BG_COLOR);
            });
            // Replace 'ball.jpg' with your actual texture path if you have one
            textureLoader.load('ball.jpg', (texture) => {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping; ballTexture = texture; if (ball) { ball.material.map = ballTexture; ball.material.needsUpdate = true; } console.log("Ball texture loaded.");
            }, undefined, (error) => { console.warn("Ball texture not found or failed to load.", error); });

            // Initial Game Objects
            createStarfield();
            createParticlePool();
            createBall();
            platformGroup = new THREE.Group(); scene.add(platformGroup);
            poleGroup = new THREE.Group(); scene.add(poleGroup);

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('pointerdown', onPointerDown, { passive: false });
            document.addEventListener('pointermove', onPointerMove, { passive: false });
            document.addEventListener('pointerup', onPointerUp, false);
            document.addEventListener('pointerleave', onPointerUp, false); // Treat leaving the window like pointer up

            // Add tap sounds to UI elements
            restartButton.addEventListener('click', () => { playTapSound(); resetGame(); }); // Tap sound + reset
            const tappableButtons = [
                loginButton, signupButton, showSignupButton, showLoginButton,
                logoutButton, withdrawalButton, profileButton, closeWithdrawalModalButton,
                pauseButton, resumeButton, watchAdButton,
                telegramButton, closeTelegramModalButton,
                followXButton, closeXModalButton // NEW Buttons added
            ];
            tappableButtons.forEach(button => {
                if (button) { button.addEventListener('click', playTapSound); } // Add tap sound
            });

            // Final Setup
            initializeFirebaseApp(); // Initialize Firebase and sets up auth listeners
            onWindowResize();        // Initial size adjustment
            animate();               // Start the animation loop
            console.log("Initialization sequence complete.");
        }

        function createStarfield() {
            if (starField) scene.remove(starField);
            const count = 7000;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const geometry = new THREE.BufferGeometry();
            const baseColor = new THREE.Color(STAR_COLOR);
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const radius = 60 + Math.random() * 60; // Position stars further out
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.random() * Math.PI * 2;
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.cos(phi);
                positions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
                // Add color variance
                const variance = Math.random() * 0.4 - 0.2;
                colors[i3] = baseColor.r + variance;
                colors[i3 + 1] = baseColor.g + variance;
                colors[i3 + 2] = baseColor.b + variance;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({
                size: 0.1, vertexColors: true, sizeAttenuation: true,
                transparent: true, opacity: 0.8, depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            starField = new THREE.Points(geometry, material);
            scene.add(starField);
            if (!scene.background) scene.background = new THREE.Color(BG_COLOR); // Fallback background
         }

        function createParticlePool() {
             if (particlePool.length > 0) { particlePool.forEach(p => scene.remove(p)); particlePool.length = 0; }
             activeParticles.length = 0;
             for (let i = 0; i < PARTICLE_COUNT; i++) {
                 const particle = new THREE.Sprite(particleBaseMaterial.clone());
                 particle.scale.set(0.05, 0.05, 0.05);
                 particle.visible = false;
                 particle.userData = { lifetime: 0, velocity: new THREE.Vector3(), type: 'none' };
                 particlePool.push(particle); scene.add(particle);
             }
        }

        function spawnParticle(position, type) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const particle = particlePool[i];
                if (!particle.visible) {
                    particle.visible = true; particle.position.copy(position); particle.userData.type = type;
                    if (type === 'bounce') {
                        particle.userData.lifetime = BOUNCE_PARTICLE_LIFETIME;
                        particle.userData.velocity.set( (Math.random() - 0.5) * 0.6, Math.random() * 0.6 + 0.3, (Math.random() - 0.5) * 0.6 ).normalize().multiplyScalar(Math.random() * 1.8 + 0.6);
                        particle.material.opacity = 0.9; particle.scale.set(0.06, 0.06, 0.06);
                    } else if (type === 'trail') {
                        particle.userData.lifetime = TRAIL_PARTICLE_LIFETIME;
                        particle.userData.velocity.set( (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1, (Math.random() - 0.5) * 0.1 );
                        particle.material.opacity = 0.6; particle.scale.set(0.03, 0.03, 0.03);
                    }
                    activeParticles.push(particle); return true;
                }
            } return false;
         }

        function updateParticles(deltaTime) {
            if (gameState !== 'playing') return;
            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const particle = activeParticles[i];
                if (!particle.visible) { activeParticles.splice(i, 1); continue; }
                particle.userData.lifetime -= deltaTime;
                if (particle.userData.lifetime <= 0) { particle.visible = false; activeParticles.splice(i, 1); }
                else {
                    const effectiveGravity = (particle.userData.type === 'bounce') ? gravity * 12 : gravity * 2; // Stronger gravity for bounce particles
                    particle.userData.velocity.y += effectiveGravity * deltaTime;
                    particle.position.addScaledVector(particle.userData.velocity, deltaTime);
                    // Fade out based on lifetime
                    const initialLifetime = (particle.userData.type === 'bounce') ? BOUNCE_PARTICLE_LIFETIME : TRAIL_PARTICLE_LIFETIME;
                    const lifeRatio = Math.max(0, particle.userData.lifetime / initialLifetime);
                    particle.material.opacity = lifeRatio * (particle.userData.type === 'bounce' ? 0.9 : 0.6);
                    // Shrink based on lifetime
                    const initialScale = (particle.userData.type === 'bounce' ? 0.06 : 0.03);
                    const scale = initialScale * lifeRatio;
                    particle.scale.set(scale, scale, scale);
                }
            }
        }

        function createBall() {
            if (ball) scene.remove(ball);
            const geometry = new THREE.SphereGeometry(0.25, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: BALL_COLOR,
                map: ballTexture, // Use loaded texture if available
                metalness: 0.8,
                roughness: 0.3,
                envMap: envMap, // Use loaded environment map if available
                envMapIntensity: 0.7
            });
            ball = new THREE.Mesh(geometry, material);
            ball.userData.isBall = true;
            ball.position.set(ballStartX, initialBallY, ballStartZ);
            ballPreviousY = ball.position.y; // Initialize previous Y
            scene.add(ball);
         }

        function createPoleSegment(yPos) {
            const segmentHeight = platformSpacingY;
            const geometry = new THREE.CylinderGeometry(poleRadius, poleRadius, segmentHeight, 16);
            const material = new THREE.MeshStandardMaterial({ color: POLE_COLOR, roughness: 0.6, metalness: 0.2, transparent: true, opacity: 1.0 });
            const segment = new THREE.Mesh(geometry, material);
            segment.position.y = yPos;
            segment.userData = { y: yPos, isPoleSegment: true, fadeOut: false, fadeProgress: 0, material: material };
            poleGroup.add(segment);
            activePoleSegments[yPos] = segment;
        }

        function createPlatform(yPos) {
            const platform = new THREE.Group();
            platform.position.y = yPos;
            platform.rotation.y = Math.random() * Math.PI * 2; // Random initial rotation

            const totalCircumference = 2 * Math.PI;
            if (platformSegments <= 0) return; // Avoid division by zero

            const segmentAngle = (totalCircumference - gapSize) / platformSegments;
            const gapStartAngle = Math.random() * totalCircumference; // Randomize gap position
            const gapEndAngle = (gapStartAngle + gapSize) % totalCircumference;

            const hasDanger = Math.random() < 0.25; // 25% chance of a danger segment
            const dangerIndex = hasDanger ? Math.floor(Math.random() * platformSegments) : -1;

            platform.userData = {
                y: yPos, isSafe: !hasDanger, segmentAngles: [], isPlatformGroup: true,
                gapStartAngle: gapStartAngle, gapEndAngle: gapEndAngle, gapSize: gapSize,
                fadeOut: false, fadeProgress: 0
            };

            const innerRadius = poleRadius + 0.05; // Slightly larger than pole
            const outerRadius = platformRadius;
            let currentAngle = gapEndAngle; // Start placing segments after the gap

            const safeColor = platformColorPalette[platformColorIndex % platformColorPalette.length];
            platformColorIndex++; // Cycle through palette

            for (let i = 0; i < platformSegments; i++) {
                const isDangerSegment = (i === dangerIndex);
                const materialOptions = {
                    roughness: isDangerSegment ? 0.5 : 0.7,
                    metalness: 0.1,
                    side: THREE.DoubleSide, // Render both sides
                    transparent: true,
                    opacity: 1.0
                };
                if (isDangerSegment) {
                    materialOptions.color = DANGER_COLOR;
                    materialOptions.emissive = DANGER_EMISSIVE_COLOR; // Glow for danger
                    materialOptions.emissiveIntensity = 0.7;
                } else {
                    materialOptions.color = safeColor;
                }
                const segmentMaterial = new THREE.MeshStandardMaterial(materialOptions);

                // Use RingGeometry for segments
                const segmentGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 32, 1, 0, segmentAngle);
                segmentGeometry.rotateX(-Math.PI / 2); // Rotate to be horizontal

                const segmentMesh = new THREE.Mesh(segmentGeometry, segmentMaterial);
                segmentMesh.rotation.y = currentAngle; // Position segment angularly

                // Store segment angle data for collision checks
                const segmentStart = currentAngle % totalCircumference;
                const segmentEnd = (currentAngle + segmentAngle) % totalCircumference;
                const segmentData = {
                    type: 'platform_segment', isDanger: isDangerSegment, parentPlatform: platform, index: i,
                    startAngle: segmentStart, endAngle: segmentEnd, mesh: segmentMesh, material: segmentMaterial
                };
                platform.userData.segmentAngles.push(segmentData);
                segmentMesh.userData = segmentData; // Link data to mesh

                platform.add(segmentMesh);
                currentAngle = (currentAngle + segmentAngle) % totalCircumference; // Move to next segment position
            }
            platformGroup.add(platform);
            activePlatforms.push(platform);
         }

        function generatePlatforms() {
            if (!ball || !camera || gameState !== 'playing') return;

            // Generate new platforms below the current view
            const generationTriggerY = nextPlatformY + platformSpacingY * 8; // Generate ahead
            while (ball.position.y < generationTriggerY && nextPlatformY > -1000) { // Add a depth limit
                createPlatform(nextPlatformY);
                createPoleSegment(nextPlatformY);
                nextPlatformY -= platformSpacingY;
            }

            // Remove platforms far above the camera (start fade out)
            const removalThresholdY_Above = camera.position.y + 15;
            activePlatforms.forEach(p => {
                if (p.position.y > removalThresholdY_Above && !p.userData.fadeOut) {
                    startFadeOut(p);
                }
            });
             // Remove corresponding pole segments
            for (const yPos in activePoleSegments) {
                const seg = activePoleSegments[yPos];
                if (parseFloat(yPos) > removalThresholdY_Above && seg && !seg.userData.fadeOut) {
                    startFadeOut(seg);
                }
            }
         }

        function updateBallPosition() {
            if (!ball || gameState !== 'playing') return;

            currentBallVelocityY += gravity; // Apply gravity
            ball.position.y += currentBallVelocityY; // Update vertical position

            // Keep ball centered horizontally relative to the start position
            ball.position.x = ballStartX;
            ball.position.z = ballStartZ;

            // Check if ball fell too far below generated platforms
            if (ball.position.y < nextPlatformY - platformSpacingY * 5) { // Game over if too far down
                handleGameOver();
            }
        }

        function disposePlatformSegments(platform) {
             if (!platform) return;
             platform.traverse(object => {
                 if (object.isMesh) {
                     if (object.geometry) object.geometry.dispose();
                     if (object.material) {
                         // Dispose textures if they exist on the material
                         ['map', 'emissiveMap', 'aoMap', 'metalnessMap', 'roughnessMap', 'normalMap', 'displacementMap', 'alphaMap', 'envMap'].forEach(prop => {
                             if (object.material[prop] && object.material[prop].dispose) {
                                 object.material[prop].dispose();
                             }
                         });
                         if (Array.isArray(object.material)) {
                             object.material.forEach(material => material.dispose());
                         } else {
                             object.material.dispose();
                         }
                     }
                 }
             });
             if (platform.parent) platform.parent.remove(platform);
        }
        function disposePoleSegment(yPos) {
             const segment = activePoleSegments[yPos];
             if (segment) {
                 if (segment.geometry) segment.geometry.dispose();
                 if (segment.material) segment.material.dispose();
                 if (segment.parent) segment.parent.remove(segment);
                 delete activePoleSegments[yPos];
                 return true;
             }
             return false;
        }
        function startFadeOut(object) {
             if (!object || !object.userData || object.userData.fadeOut) return;
             object.userData.fadeOut = true;
             object.userData.fadeProgress = 0; // Reset progress
        }

        function destroyPlatformAndPole(platform) {
            if (!platform || !platform.userData || platform.userData.fadeOut) return; // Don't destroy if already fading

            const platformY = platform.userData.y;
            // Increment score and play sound only once per platform level passed through
            if (!scoreIncrementedForPlatform[platformY]) {
                currentScore++;
                updateScoreUI();
                scoreIncrementedForPlatform[platformY] = true; // Mark as scored
                playSound('destroy'); // Play destruction sound
            }

            startFadeOut(platform); // Start fade animation for platform
            const poleSegment = activePoleSegments[platformY];
            if (poleSegment) {
                startFadeOut(poleSegment); // Start fade animation for corresponding pole
            }
        }

        function updateFadingObjects(deltaTime) {
             if (gameState !== 'playing') return; // Only fade during gameplay

             const fadeSpeed = 1.0 / (FADE_DURATION / 1000); // Fade speed based on duration
             const platformsToRemoveIndexes = [];
             const poleYPositionsToRemove = [];

             // Process platforms
             for (let i = activePlatforms.length - 1; i >= 0; i--) {
                  const p = activePlatforms[i];
                  if (p.userData.fadeOut) {
                      p.userData.fadeProgress += fadeSpeed * deltaTime;
                      const progress = Math.min(p.userData.fadeProgress, 1); // Clamp progress to 1
                      // Scale down and fade out
                      const scale = 1.0 - progress * 0.5; // Scale effect
                      p.scale.set(scale, 1, scale); // Only scale horizontally
                      p.userData.segmentAngles.forEach(segmentData => {
                          if (segmentData.material) {
                              segmentData.material.opacity = 1.0 - progress; // Fade opacity
                          }
                      });
                      // Mark for removal when fade is complete
                      if (progress >= 1) {
                          platformsToRemoveIndexes.push(i);
                      }
                  }
              }
              // Remove fully faded platforms (iterate backwards to avoid index issues)
              for (let i = platformsToRemoveIndexes.length - 1; i >= 0; i--) {
                  const index = platformsToRemoveIndexes[i];
                  disposePlatformSegments(activePlatforms[index]); // Dispose resources
                  activePlatforms.splice(index, 1); // Remove from active list
              }

             // Process pole segments
             for (const y in activePoleSegments) {
                  const segment = activePoleSegments[y];
                  if (segment && segment.userData.fadeOut) {
                      segment.userData.fadeProgress += fadeSpeed * deltaTime;
                      const progress = Math.min(segment.userData.fadeProgress, 1);
                      if (segment.material) segment.material.opacity = 1.0 - progress; // Fade opacity
                      const scale = 1.0 - progress; // Scale effect
                      segment.scale.set(scale, scale, scale); // Scale uniformly
                      // Mark for removal when fade is complete
                      if (progress >= 1) {
                          poleYPositionsToRemove.push(parseFloat(y));
                      }
                  }
              }
              // Remove fully faded pole segments
              poleYPositionsToRemove.forEach(y => disposePoleSegment(y));
          }

        function checkCollisions() {
            if (!ball || gameState !== 'playing' || currentBallVelocityY >= 0) {
                 return; // Only check collisions when falling and playing
            }

            const ballRadius = 0.25;
            const ballBottomY = ball.position.y - ballRadius;
            let collisionOccurred = false;
            let candidatePlatform = null; // Platform most likely to be hit
            let highestCandidateY = -Infinity;

            // Find the highest platform the ball might be passing through
            for (let i = 0; i < activePlatforms.length; i++) {
                const platform = activePlatforms[i];
                if (!platform || !platform.userData || platform.userData.fadeOut) continue; // Skip fading platforms

                const platformSurfaceY = platform.position.y;
                // Check if the ball was above the platform last frame and is at or below it now
                if (ballPreviousY - ballRadius >= platformSurfaceY && ballBottomY <= platformSurfaceY) {
                    // If this platform is higher than the current candidate, it's the new candidate
                    if (platformSurfaceY > highestCandidateY) {
                        highestCandidateY = platformSurfaceY;
                        candidatePlatform = platform;
                    }
                }
            }

            if (!candidatePlatform) return; // No potential collision found

            // Check collision against the candidate platform
            const platformData = candidatePlatform.userData;
            const collisionY = platformData.y; // The Y level of the collision

            // Calculate ball's angle relative to the center of the tower
            const ballAngle = Math.atan2(ball.position.z - platformGroup.position.z, ball.position.x - platformGroup.position.x);
            // Account for the tower's rotation and the platform's individual rotation
            const towerRotation = platformGroup.rotation.y;
            const platformInternalRotation = candidatePlatform.rotation.y;
            // Normalize the angle relative to the platform's coordinate system
            let angleRelativeToPlatform = THREE.MathUtils.euclideanModulo(
                ballAngle - towerRotation - platformInternalRotation, 2 * Math.PI
            );

            // Check if the ball's angle falls within the platform's gap
            const gapStart = platformData.gapStartAngle;
            const gapEnd = platformData.gapEndAngle;
            let isInGap;
            if (gapStart < gapEnd) { // Normal case (gap doesn't cross 0/2PI)
                isInGap = angleRelativeToPlatform >= gapStart && angleRelativeToPlatform < gapEnd;
            } else { // Gap wraps around 0/2PI
                isInGap = angleRelativeToPlatform >= gapStart || angleRelativeToPlatform < gapEnd;
            }

            // Also check if the ball is too close to the center (inside the pole radius)
            const ballDistFromCenter = Math.hypot(ball.position.x, ball.position.z);
            const isInsidePoleRadius = ballDistFromCenter < poleRadius;

            // --- Collision Logic ---
            if (isInGap || isInsidePoleRadius) {
                // Fell through gap or hit pole area - Destroy platform below
                destroyPlatformAndPole(candidatePlatform);
            } else {
                // Potentially hit a segment, find which one
                let hitSegmentData = null;
                for (const segmentData of platformData.segmentAngles) {
                    let segStart = segmentData.startAngle;
                    let segEnd = segmentData.endAngle;
                    let angleFallsInSegment;
                    // Check if angle is within segment bounds (handling wrap around 0/2PI)
                    if (segStart < segEnd) {
                        angleFallsInSegment = angleRelativeToPlatform >= segStart && angleRelativeToPlatform < segEnd;
                    } else {
                        angleFallsInSegment = angleRelativeToPlatform >= segStart || angleRelativeToPlatform < segEnd;
                    }
                    if (angleFallsInSegment) {
                        hitSegmentData = segmentData;
                        break; // Found the hit segment
                    }
                }

                if (hitSegmentData) {
                    if (hitSegmentData.isDanger) {
                        // Hit DANGER zone - Game Over
                        lastSafePlatformY = collisionY - platformSpacingY; // Record platform above as last safe
                        handleGameOver(); // Trigger game over sequence
                        collisionOccurred = true;
                        startShake(0.7); // Stronger shake for danger hit
                    } else {
                        // Hit SAFE zone - Bounce
                        playSound('bounce'); // Play bounce sound
                        lastSafePlatformY = collisionY; // Update last safe platform
                        ball.position.y = collisionY + ballRadius + 0.01; // Place ball slightly above platform
                        currentBallVelocityY = bounceSpeed; // Apply upward bounce velocity
                        collisionOccurred = true;
                        // Spawn bounce particles
                        let count = 0;
                        while (count < 10 && spawnParticle(ball.position, 'bounce')) count++;
                        // Reset score increment flags for platforms below the bounce point
                        Object.keys(scoreIncrementedForPlatform).forEach(keyY => {
                            if (parseFloat(keyY) < collisionY) {
                                delete scoreIncrementedForPlatform[keyY];
                            }
                        });
                        startShake(0.3); // Small shake for bounce
                    }
                } else {
                     // This case should ideally not happen if not in gap, but handle defensively
                     console.warn("Collision check: Ball not in gap, but no segment hit?", { angleRelativeToPlatform, platformData });
                     destroyPlatformAndPole(candidatePlatform); // Treat as falling through
                }
            }
         } // End checkCollisions

        function handleGameOver() {
            if (gameState !== 'playing') return; // Prevent multiple game overs

            console.log("Game Over Triggered!");
            gameState = 'gameOver';
            playSound('over'); // Play game over sound
            stopBackgroundMusic(); // Stop music

            finalScoreEl.textContent = currentScore;
            gameOverMessageP.innerHTML = `Score: <span id="final-score">${currentScore}</span>`; // Reset message content
            gameOverUI.style.display = 'block';
            pauseButton.style.display = 'none'; // Hide pause button

            // Enable/disable buttons appropriately
            if (restartButton) restartButton.disabled = false;
            if (watchAdButton) {
                // Show "Watch Ad" button only if logged in and scored > 0
                if (currentUserUid && currentScore > 0) {
                    watchAdButton.style.display = 'block';
                    watchAdButton.disabled = false;
                } else {
                    watchAdButton.style.display = 'none';
                }
            }

            startShake(0.5); // Trigger screen shake
        }

        function handleWatchAd() {
            if (gameState !== 'gameOver' || !currentUserUid || currentScore <= 0 || adTimerIntervalId) {
                console.warn("Watch ad conditions not met or already running.");
                return;
            }

            console.log("Watch Ad button clicked. Saving score and starting timer...");

            if (restartButton) restartButton.disabled = true; // Disable restart during ad process
            if (watchAdButton) watchAdButton.disabled = true; // Disable ad button itself

            // ---- AD SCRIPT INTEGRATION POINT ----
            // Call your ad network's function here to show a rewarded ad.
            // Example: if (typeof adNetwork !== 'undefined' && adNetwork.showRewardedAd) { adNetwork.showRewardedAd({ onReward: onAdReward, onError: onAdError }); }
            // For this example, we'll just simulate the ad process with updateUserTotalScore and a timer.
            // Make sure the *actual* ad script (from the <head>) is correctly placed.
            // ------------------------------------

            updateUserTotalScore(currentScore) // Attempt to save score
                .then(() => {
                    console.log("Score save initiated successfully via Ad button.");
                    // Start countdown timer visually
                    let adCountdown = 5; // Simulate ad duration + processing
                    gameOverMessageP.textContent = `Score Saved! Restarting in ${adCountdown}s`; // Update message

                    adTimerIntervalId = setInterval(() => {
                        adCountdown--;
                        if (adCountdown > 0) {
                            gameOverMessageP.textContent = `Score Saved! Restarting in ${adCountdown}s`;
                        } else {
                            clearInterval(adTimerIntervalId);
                            adTimerIntervalId = null;
                            console.log("Ad timer finished. Restarting game.");
                            resetGame(); // Restart the game (async)
                        }
                    }, 1000);
                })
                .catch((error) => {
                    // Handle score saving failure after ad attempt
                    console.error("Failed to save score after clicking Watch Ad:", error);
                    gameOverMessageP.textContent = "Error saving score. Please restart.";
                     if (restartButton) restartButton.disabled = false; // Re-enable restart
                     if (watchAdButton) watchAdButton.disabled = false; // Re-enable ad btn? Maybe not.
                     if (adTimerIntervalId) { clearInterval(adTimerIntervalId); adTimerIntervalId = null; } // Clear timer if running
                });
        }

        function startShake(intensity) {
            shakeIntensity = Math.max(shakeIntensity, intensity); // Don't reduce shake if a stronger one is requested
         }

        async function resetGame() {
            console.log("Attempting Reset Game...");

            // Ensure AudioContext is ready (important if restarting without login/logout)
            if (!isAudioInitialized) {
                 await initAudioContext();
                 if (!isAudioInitialized) { // Check again if init failed
                    console.error("Audio context failed to initialize. Game cannot start with audio.");
                    // Potentially show an error message to the user
                    return;
                 }
                 // Small delay might help ensure context is fully running
                 // await new Promise(resolve => setTimeout(resolve, 50));
            }

            // Clear any pending ad timer
            if (adTimerIntervalId) {
                clearInterval(adTimerIntervalId);
                adTimerIntervalId = null;
                console.log("Ad timer cleared due to reset.");
            }

            // If user is not logged in, prevent full game start
            if (!currentUserUid) {
                console.log("Reset skipped: User not logged in.");
                gameState = 'loggedOut';
                gameOverUI.style.display = 'none';
                pauseModal.style.display = 'none';
                pauseButton.style.display = 'none';
                if (telegramModal) telegramModal.style.display = 'none'; // Hide modals
                if (xModal) xModal.style.display = 'none';
                if (withdrawalModal) withdrawalModal.style.display = 'none';
                if (restartButton) restartButton.disabled = true;
                if (watchAdButton) watchAdButton.style.display = 'none';
                if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId); cameraZoomRequestId = null;
                if (camera) camera.position.z = cameraFixedZ; isCameraZooming = false;
                // Minimal cleanup
                if (platformGroup) { while(platformGroup.children.length > 0) disposePlatformSegments(platformGroup.children[0]); }
                Object.keys(activePoleSegments).forEach(y => disposePoleSegment(parseFloat(y)));
                activePlatforms = []; activePoleSegments = {};
                activeParticles.forEach(p => p.visible = false); activeParticles.length = 0;
                stopBackgroundMusic(); // Ensure music is stopped
                return; // Exit reset early
            }

            // --- Proceed with full reset for logged-in user ---
            console.log("Resetting game for user:", currentUserUid);
            playSound('start'); // Play game start sound
            playBackgroundMusic(); // Start or resume background music

            // Stop any ongoing camera zoom
            if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId); cameraZoomRequestId = null; isCameraZooming = false;

            // Reset Ball
            if (!ball) createBall(); // Create if it doesn't exist
            ball.position.set(ballStartX, initialBallY, ballStartZ);
            ballPreviousY = ball.position.y;
            currentBallVelocityY = 0;

            // Clear existing platforms and poles
            activePlatforms.forEach(p => disposePlatformSegments(p)); activePlatforms = [];
            if (platformGroup) { while(platformGroup.children.length > 0) platformGroup.remove(platformGroup.children[0]); platformGroup.rotation.y = 0; } // Reset rotation
            else { platformGroup = new THREE.Group(); scene.add(platformGroup); } // Recreate if needed

            Object.keys(activePoleSegments).forEach(y => disposePoleSegment(parseFloat(y))); activePoleSegments = {};
            if (poleGroup) { while(poleGroup.children.length > 0) poleGroup.remove(poleGroup.children[0]); }
            else { poleGroup = new THREE.Group(); scene.add(poleGroup); } // Recreate if needed

            // Clear particles
            activeParticles.forEach(p => p.visible = false); activeParticles.length = 0;

            // Reset Score & State
            currentScore = 0; updateScoreUI();
            scoreIncrementedForPlatform = {}; // Clear scored platforms map
            platformColorIndex = 0; // Reset color cycle
            shakeIntensity = 0;

            // Regenerate initial platforms
            nextPlatformY = initialBallY - platformSpacingY * 2; // Start platforms below the ball
            lastSafePlatformY = nextPlatformY + platformSpacingY; // Initial safe platform reference
            for (let i = 0; i < 15; i++) { // Generate initial stack
                createPlatform(nextPlatformY);
                createPoleSegment(nextPlatformY);
                nextPlatformY -= platformSpacingY;
            }

            // Reset UI elements
            gameOverUI.style.display = 'none';
            pauseModal.style.display = 'none';
            if (telegramModal) telegramModal.style.display = 'none'; // Also hide info modals
            if (xModal) xModal.style.display = 'none';
            if (withdrawalModal) withdrawalModal.style.display = 'none';

            // Reset Camera position smoothly (especially Y, keep Z)
             if (camera && ball) {
                const initialCameraY = ball.position.y + cameraVerticalOffset;
                const initialLookAtY = ball.position.y + cameraLookAtOffset;
                // Use current camera Z to maintain zoomed state if applicable
                camera.position.set(0, initialCameraY, camera.position.z);
                camera.lookAt(0, initialLookAtY, 0);
            }

            // Set game state to playing
            gameState = 'playing';
            pauseButton.style.display = 'block'; // Show pause button
            console.log("Reset complete. Game state:", gameState);
            setTimeout(onWindowResize, 50); // Adjust layout after reset
        }

        function pauseGame() {
             if (gameState === 'playing') {
                 gameState = 'paused';
                 console.log("Game Paused");
                 pauseBackgroundMusic(); // Pause music

                 // Close other UI elements that shouldn't overlay pause
                 if (profilePanel) profilePanel.style.display = 'none';
                 if (telegramModal) telegramModal.style.display = 'none';
                 if (xModal) xModal.style.display = 'none';
                 if (withdrawalModal) withdrawalModal.style.display = 'none';

                 if(pauseCurrentScoreEl) pauseCurrentScoreEl.textContent = currentScore; // Update score display in pause modal
                 pauseModal.style.display = 'block';
                 pauseButton.style.display = 'none'; // Hide button while modal is shown
             }
        }

        function resumeGame() {
             if (gameState === 'paused') {
                 gameState = 'playing';
                 console.log("Game Resumed");
                 playBackgroundMusic(); // Resume music

                 pauseModal.style.display = 'none';
                 pauseButton.style.display = 'block'; // Show button again
                 clock.getDelta(); // Reset clock delta to avoid large jump in physics/animation after pause
             }
        }

        // --- Input Handling ---
        function onPointerDown(e){
            let target = e.target;
            let isUIInteraction = false;

            // Check if click is on any UI element that should prevent game interaction
            if (authContainer.contains(target) ||
                (gameOverUI.style.display === 'block' && gameOverUI.contains(target)) ||
                (withdrawalModal.style.display === 'block' && withdrawalModal.contains(target)) ||
                (pauseModal.style.display === 'block' && pauseModal.contains(target)) ||
                (telegramModal && telegramModal.style.display === 'block' && telegramModal.contains(target)) ||
                (xModal && xModal.style.display === 'block' && xModal.contains(target)) || // Check X modal
                target.tagName === 'BUTTON' ||
                target.tagName === 'A' ||
                target.tagName === 'INPUT' ||
                target.classList.contains('toggle-link') ||
                (profileButton.contains(target) && target !== profileButton && !profileButton.contains(target.closest('svg'))) ||
                (profilePanel.style.display === 'block' && profilePanel.contains(target)) ||
                (pauseButton.contains(target) && target !== pauseButton && !pauseButton.contains(target.closest('svg')))
             ) {
                 isUIInteraction = true;
            }

             // Prevent starting drag if UI interaction or not playing/game over
             if (isUIInteraction || (gameState !== 'playing' && gameState !== 'gameOver')) {
                 // console.log("Pointer down ignored (UI or wrong state)");
                 return; // Prevent starting a drag
             }
              // If game is over, only allow interaction within the game over UI itself
              if (gameState === 'gameOver' && !gameOverUI.contains(target)) {
                   // console.log("Pointer down ignored (Game over outside UI)");
                  return;
              }

             // Start drag only if playing
             if (gameState === 'playing') {
                 isPointerDown = true;
                 previousPointerX = e.clientX ?? e.touches?.[0]?.clientX;
                 if (previousPointerX === undefined) { isPointerDown = false; return; } // No coords available

                 document.body.style.cursor = 'grabbing'; // Change cursor

                 // Prevent default touch actions like scrolling/zooming only if actively dragging in game area
                 if (e.cancelable && e.touches && gameContainer.contains(target)) {
                    e.preventDefault();
                 }
             }
        }

        function onPointerMove(e){
            if (!isPointerDown || gameState !== 'playing') return; // Only rotate if dragging and playing

            const currentX = e.clientX ?? e.touches?.[0]?.clientX;
            if (currentX === undefined) return; // No coords

            const deltaX = currentX - previousPointerX;
            if (platformGroup) {
                platformGroup.rotation.y += deltaX * rotationSensitivity; // Rotate the tower
            }
            previousPointerX = currentX; // Update previous position

            // Prevent default touch actions during move as well
            if (e.cancelable && e.touches) {
                e.preventDefault();
            }
        }

        function onPointerUp(e){
            if (isPointerDown) { // Only act if a drag was in progress
                isPointerDown = false;
                document.body.style.cursor = 'default'; // Reset cursor
            }
        }

        // --- Window Resize Handling ---
        function onWindowResize() {
            if (camera && renderer && gameContainer && composer) {
                const width = gameContainer.clientWidth;
                const height = gameContainer.clientHeight;

                // Ensure dimensions are valid before resizing
                if (width > 0 && height > 0) {
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix(); // Update camera projection
                    renderer.setSize(width, height); // Update renderer size
                    composer.setSize(width, height); // Update composer size (for post-processing)
                     // console.log(`Resized to: ${width}x${height}`); // Reduce console noise
                } else {
                    // console.warn("Resize event with zero dimensions detected.");
                }
            }
        }

        // --- Camera Zoom Animation ---
        function animateCameraZoom(targetZ, duration) {
            if (!camera || isCameraZooming) return; // Don't start if no camera or already zooming

            if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId); // Cancel previous zoom if any
            isCameraZooming = true;
            const startZ = camera.position.z;
            const startTime = performance.now();

            function zoomStep(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1); // Normalize progress 0-1
                // Use an easing function for smoother zoom (easeOutQuad)
                const easeOutQuad = t => t * (2 - t);
                const newZ = startZ + (targetZ - startZ) * easeOutQuad(progress);
                camera.position.z = newZ;

                if (progress < 1) {
                    // Continue animation if not finished
                    cameraZoomRequestId = requestAnimationFrame(zoomStep);
                } else {
                    // Snap to final position and clean up
                    camera.position.z = targetZ;
                    isCameraZooming = false;
                    cameraZoomRequestId = null;
                    console.log("Camera zoom finished.");
                }
            }
            cameraZoomRequestId = requestAnimationFrame(zoomStep); // Start the animation
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate); // Loop the animation

            const deltaTime = clock.getDelta(); // Time since last frame (for smooth animation)

            // Update visual effects that run regardless of game state
            if (starField) starField.rotation.y += deltaTime * 0.01; // Slow rotation

            // --- Game State Specific Updates ---
            let baseCameraTargetY = camera ? camera.position.y : (initialBallY + cameraVerticalOffset);
            let baseLookAtTargetY = ball ? (ball.position.y + cameraLookAtOffset) : (initialBallY + cameraLookAtOffset);

            if (gameState === 'playing') {
                updateBallPosition();   // Includes gravity
                checkCollisions();      // Handles bounces, gaps, game over
                generatePlatforms();    // Adds/removes platforms
                updateFadingObjects(deltaTime); // Update fade animations
                updateParticles(deltaTime);     // Update particle physics & lifetime

                // Smooth camera follow logic
                if (ball && camera) {
                    const targetCameraY = ball.position.y + cameraVerticalOffset;
                    // Lerp (linear interpolate) for smooth follow
                    const lerpedY = THREE.MathUtils.lerp(camera.position.y, targetCameraY, cameraFollowLerpFactor);
                    // Prevent camera from going up unless ball is moving up significantly (avoids jitter on bounce)
                    // But allow instant drop if target is lower
                    if (lerpedY < camera.position.y || currentBallVelocityY > 0.01) {
                         baseCameraTargetY = lerpedY;
                    } else if (targetCameraY < camera.position.y) {
                         baseCameraTargetY = targetCameraY; // Allow camera to drop instantly
                    }
                    // Adjust lookAt target as well
                    baseLookAtTargetY = ball.position.y + cameraLookAtOffset;
                }

                 // Update ball's previous Y position AFTER collision checks/adjustments
                 if (ball) { ballPreviousY = ball.position.y; }

                 // Spawn trail particles when falling fast
                 if (ball && currentBallVelocityY < -0.02 && Math.random() < 0.35) { // Adjust threshold/probability as needed
                     spawnParticle(ball.position, 'trail');
                 }
            }

            // Apply Camera Shake (runs even if paused/game over to finish shake)
            let shakeOffsetX = 0, shakeOffsetY = 0;
            if (shakeIntensity > 0.01) { // Apply shake if intensity is noticeable
                shakeOffsetX = (Math.random() - 0.5) * 2 * maxShakeOffset * shakeIntensity;
                shakeOffsetY = (Math.random() - 0.5) * 2 * maxShakeOffset * shakeIntensity;
                // Decrease shake intensity over time, but only when game is active or over
                if (gameState === 'playing' || gameState === 'gameOver') {
                     shakeIntensity *= shakeDecreaseFactor; // Exponential decay
                }
            } else {
                shakeIntensity = 0; // Clamp to zero if negligible
            }

            // Update Camera Position and LookAt (always update to apply follow/shake)
             if (camera) {
                 camera.position.y = baseCameraTargetY + shakeOffsetY;
                 camera.position.x = 0 + shakeOffsetX; // Keep centered horizontally + shake
                 // camera.position.z remains unchanged by shake/follow, controlled by zoom
                 camera.lookAt(0 + shakeOffsetX, baseLookAtTargetY + shakeOffsetY, 0); // Look at target + shake
             }

            // Render scene using composer (includes post-processing like bloom)
            if (composer) {
                composer.render(deltaTime);
            } else if (renderer && scene && camera) { // Fallback basic rendering if composer fails
                renderer.render(scene, camera);
            }
        } // --- End of animate() ---

        // --- Start ---
        // Wait for the DOM to be fully loaded before initializing
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
