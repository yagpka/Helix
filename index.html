
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Helix Point Drop - Telegram Mini App (Supabase Debug)</title> <!-- Changed Title -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <!-- ADDED: Real Telegram Web App Script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- REMOVED: Firebase Scripts -->
    <style>
        /* --- Theming Variables --- */
        :root {
            /* --- Dark Mode (Default / Night) --- */
            --bg-gradient-start: #0a0a1a;
            --bg-gradient-end: #111122;
            --bg-header-bar: rgba(10, 10, 25, 0.85);
            --bg-ui-panel: rgba(15, 15, 35, 0.9);
            --bg-overlay: rgba(11, 11, 34, 0.98);
            --bg-menu: rgba(20, 20, 45, 0.97);
            --bg-modal: rgba(15, 15, 35, 0.95);
            --bg-input: rgba(255, 255, 255, 0.08);
            --bg-select: var(--bg-input); /* Style select like input */
            --bg-button-info: #00cfde;
            --bg-button-info-hover: #00b3bf;
            --bg-button-action: #ff4081;
            --bg-button-action-hover: #d81b60;
            --bg-button-special: #f5d131;
            --bg-button-special-hover: #dbc02b;
            --bg-button-watch-ad: #4CAF50; /* Green for watch ad */
            --bg-button-watch-ad-hover: #45a049;
            --bg-button-x: #000000;
            --bg-button-x-hover: #333333;
            --bg-toggle-track: #555;
            --bg-toggle-track-active: var(--accent-cyan);
            --bg-link-button: rgba(255, 255, 255, 0.05);
            --bg-link-button-hover: rgba(255, 255, 255, 0.1);
            --bg-copy-button: rgba(255, 255, 255, 0.1);
            --bg-copy-button-hover: rgba(255, 255, 255, 0.2);
            --bg-difficulty-button: rgba(255, 255, 255, 0.08); /* Replaced timer button bg */
            --bg-difficulty-button-active: var(--accent-cyan); /* Replaced timer button active bg */
            --bg-difficulty-button-hover: rgba(255, 255, 255, 0.15); /* Replaced timer button hover bg */
            --bg-initial-controls: rgba(15, 15, 35, 0.92);
            --bg-withdrawal-section: rgba(255, 255, 255, 0.03); /* Subtle background for sections */


            --text-light: #ffffff;
            --text-medium: #cccccc;
            --text-dark: #111122;
            --text-link: var(--accent-cyan);
            --text-link-hover: var(--accent-cyan-hover);
            --text-heading-accent: var(--accent-yellow);
            --text-error: var(--accent-pink);
            --text-placeholder: rgba(255, 255, 255, 0.4);
            --text-copy-button: var(--text-medium);
            --text-copy-button-hover: var(--text-light);
            --text-difficulty-button: var(--text-medium); /* Replaced timer button text */
            --text-difficulty-button-active: var(--text-dark); /* Replaced timer button active text */
            --text-label: var(--text-medium);

            --border-color: rgba(255, 255, 255, 0.15);
            --border-input: rgba(255, 255, 255, 0.15);
            --border-select: var(--border-input);
            --border-menu-item: rgba(255, 255, 255, 0.1);
            --border-link-button: rgba(255, 255, 255, 0.1);
            --border-copy-button: rgba(255, 255, 255, 0.2);
            --border-difficulty-button: rgba(255, 255, 255, 0.15); /* Replaced timer button border */
            --border-initial-controls: rgba(255, 255, 255, 0.1);
            --border-withdrawal-section: rgba(255, 255, 255, 0.1);


            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-header-bar: 0 3px 12px var(--shadow-color);
            --shadow-panel: 0 6px 20px var(--shadow-color);
            --shadow-modal: 0 8px 25px var(--shadow-color);
            --shadow-button: 0 2px 5px rgba(0, 0, 0, 0.2);
            --shadow-button-hover: 0 4px 8px rgba(0, 0, 0, 0.25);
            --shadow-initial-controls: 0 6px 20px var(--shadow-color);

            --backdrop-blur: 4px;
            --backdrop-blur-heavy: 6px;

            /* Accents & Game Colors */
            --accent-cyan: #00cfde;
            --accent-cyan-hover: #00b3bf;
            --accent-pink: #ff4081;
            --accent-pink-hover: #d81b60;
            --accent-yellow: #f5d131;
            --accent-yellow-hover: #dbc02b;
            --danger-glow: #cc8400;
            --danger-color: var(--accent-yellow);
            --ball-color: var(--accent-pink);
            --pole-color: #679b31;
            --star-color: #aaaaee;
            --x-color: #000000;
            --x-color-hover: #333333;

            --menu-width: 260px;
            --transition-speed: 0.4s;
            --transition-timing: ease;
        }

        body.light-mode {
            /* --- Light Mode Overrides (Day) --- */
            --bg-gradient-start: #87CEEB;
            --bg-gradient-end: #FFB347;
            --bg-gradient-stop: #FF6F61;

            --bg-header-bar: rgba(255, 255, 255, 0.85);
            --bg-ui-panel: rgba(255, 255, 255, 0.9);
            --bg-overlay: rgba(245, 245, 250, 0.98);
            --bg-menu: rgba(250, 250, 255, 0.97);
            --bg-modal: rgba(250, 250, 255, 0.95);
            --bg-input: rgba(0, 0, 0, 0.05);
            --bg-select: var(--bg-input);
            --bg-button-info: #00a8b5;
            --bg-button-info-hover: #008a96;
            --bg-button-action: #e91e63;
            --bg-button-action-hover: #c2185b;
            --bg-button-special: #fbc02d;
            --bg-button-special-hover: #f9a825;
            --bg-button-watch-ad: #8BC34A;
            --bg-button-watch-ad-hover: #7CB342;
            --bg-button-x: #333333;
            --bg-button-x-hover: #555555;
            --bg-toggle-track: #ccc;
            --bg-toggle-track-active: var(--accent-cyan);
            --bg-link-button: rgba(0, 0, 0, 0.03);
            --bg-link-button-hover: rgba(0, 0, 0, 0.06);
            --bg-copy-button: rgba(0, 0, 0, 0.05);
            --bg-copy-button-hover: rgba(0, 0, 0, 0.1);
            --bg-difficulty-button: rgba(0, 0, 0, 0.05); /* Replaced timer button bg */
            --bg-difficulty-button-active: var(--accent-cyan); /* Replaced timer button active bg */
            --bg-difficulty-button-hover: rgba(0, 0, 0, 0.1); /* Replaced timer button hover bg */
            --bg-initial-controls: rgba(250, 250, 255, 0.92);
            --bg-withdrawal-section: rgba(0, 0, 0, 0.03);

            --text-light: #212121;
            --text-medium: #555555;
            --text-dark: #ffffff;
            --text-link: var(--accent-cyan);
            --text-link-hover: var(--accent-cyan-hover);
            --text-heading-accent: #ff8f00;
            --text-error: var(--accent-pink);
            --text-placeholder: rgba(0, 0, 0, 0.4);
             --text-copy-button: var(--text-medium);
             --text-copy-button-hover: var(--text-light);
            --text-difficulty-button: var(--text-medium); /* Replaced timer button text */
            --text-difficulty-button-active: var(--text-light); /* Replaced timer button active text */
            --text-label: var(--text-medium);

            --border-color: rgba(0, 0, 0, 0.1);
            --border-input: rgba(0, 0, 0, 0.15);
            --border-select: var(--border-input);
            --border-menu-item: rgba(0, 0, 0, 0.08);
            --border-link-button: rgba(0, 0, 0, 0.1);
            --border-copy-button: rgba(0, 0, 0, 0.15);
            --border-difficulty-button: rgba(0, 0, 0, 0.1); /* Replaced timer button border */
            --border-initial-controls: rgba(0, 0, 0, 0.1);
            --border-withdrawal-section: rgba(0, 0, 0, 0.1);

            --shadow-color: rgba(0, 0, 0, 0.1);
            --shadow-header-bar: 0 3px 12px var(--shadow-color);
            --shadow-panel: 0 6px 20px var(--shadow-color);
            --shadow-modal: 0 8px 25px var(--shadow-color);
            --shadow-button: 0 2px 5px rgba(0, 0, 0, 0.1);
            --shadow-button-hover: 0 4px 8px rgba(0, 0, 0, 0.15);
            --shadow-initial-controls: 0 6px 20px var(--shadow-color);

            --star-color: rgba(170, 170, 238, 0.3);
        }

        * { box-sizing: border-box; }
        html { height: 100%; }
        body {
            margin: 0; overflow: hidden; font-family: 'Poppins', sans-serif;
             background: linear-gradient(180deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 60%, var(--bg-gradient-stop, var(--bg-gradient-end)) 100%);
            color: var(--text-light); touch-action: none; -webkit-user-select: none;
            -ms-user-select: none; user-select: none; height: 100%; min-height: 100%;
            display: flex; flex-direction: column; align-items: center;
            justify-content: flex-start;
            transition: background var(--transition-speed) var(--transition-timing),
                        color var(--transition-speed) var(--transition-timing);
            position: relative;
        }

        /* Ensure transitions apply to difficulty buttons */
        #header-bar, #side-menu, #settings-popup, .fullscreen-overlay, .modal, input, button, a.link-button, .score-display, h2, h3, p, #game-canvas, .task-group, .task-item, #referral-list-container, #referral-link-container, #initial-controls-container, #header-timer-display, select, .difficulty-button {
             transition: background-color var(--transition-speed) var(--transition-timing),
                         color var(--transition-speed) var(--transition-timing),
                         border-color var(--transition-speed) var(--transition-timing),
                         box-shadow var(--transition-speed) var(--transition-timing),
                         opacity var(--transition-speed) var(--transition-timing),
                         fill var(--transition-speed) var(--transition-timing),
                         display var(--transition-speed) var(--transition-timing),
                         transform var(--transition-speed) var(--transition-timing);
        }
        .star-color-target {}

        #header-bar { padding: 10px 15px 5px 15px; background-color: var(--bg-header-bar); backdrop-filter: blur(var(--backdrop-blur)); color: var(--text-light); z-index: 200; box-shadow: var(--shadow-header-bar); display: flex; flex-direction: column; align-items: center; position: static; border-radius: 0 0 10px 10px; width: 100%; max-width: 500px; margin: 0 auto; flex-shrink: 0; position: relative; }
        #score-wrapper { display: flex; width: 100%; max-width: 350px; justify-content: space-around; align-items: center; padding: 8px 0 4px 0; }
        .score-display { font-size: 1.8em; font-weight: 700; text-shadow: 0 1px 2px var(--shadow-color); text-align: center; color: var(--text-light); }
        .score-label { font-size: 0.55em; display: block; opacity: 0.7; font-weight: 400; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-medium); }

        /* --- Centered Initial Game Controls --- */
        #initial-controls-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1);
            width: 90%; max-width: 350px; display: flex; flex-direction: column; align-items: center;
            padding: 25px 20px; background-color: var(--bg-initial-controls); border: 1px solid var(--border-initial-controls);
            border-radius: 15px; box-shadow: var(--shadow-initial-controls); z-index: 150; opacity: 1;
            pointer-events: auto; backdrop-filter: blur(var(--backdrop-blur));
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s linear 0s; visibility: visible;
        }
        #initial-controls-container.hidden {
            opacity: 0; transform: translate(-50%, -50%) scale(0.8); pointer-events: none; visibility: hidden;
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0s linear 0.3s;
        }
        #initial-controls-container h3 { font-size: 1.4em; color: var(--text-heading-accent); margin-top: 0; margin-bottom: 20px; font-weight: 700; }
        /* Difficulty Options replaces Timer Options */
        #difficulty-options { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; }
        .difficulty-button { /* New class for difficulty buttons */
            padding: 8px 15px; border: 1px solid var(--border-difficulty-button); border-radius: 20px; background-color: var(--bg-difficulty-button);
            color: var(--text-difficulty-button); font-family: inherit; font-size: 0.9em; font-weight: 600; cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease, transform 0.1s ease;
        }
        .difficulty-button:hover { background-color: var(--bg-difficulty-button-hover); transform: translateY(-1px); }
        .difficulty-button.active { background-color: var(--bg-difficulty-button-active); color: var(--text-difficulty-button-active); border-color: var(--bg-difficulty-button-active); font-weight: 700; }
        /* End Difficulty Options */
        #start-game-button {
            padding: 12px 30px; border: none; border-radius: 8px; background-color: var(--bg-button-special); color: var(--text-dark);
            font-family: inherit; font-weight: 700; font-size: 1.1em; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            box-shadow: var(--shadow-button); width: 70%; max-width: 250px; text-transform: uppercase; letter-spacing: 1px;
        }
        #start-game-button:hover:not(:disabled) { background-color: var(--bg-button-special-hover); transform: scale(1.03); box-shadow: var(--shadow-button-hover); }
        #start-game-button:active:not(:disabled) { transform: scale(0.98); }
        #start-game-button:disabled { background-color: #777; color: #bbb; cursor: not-allowed; transform: none; box-shadow: none; }
        /* --- END: Centered Initial Game Controls --- */

        /* --- Header Timer Display --- */
         #header-timer-display {
             font-size: 1.6em; font-weight: 700; color: var(--text-heading-accent); margin-top: 5px; margin-bottom: 5px; display: block;
             opacity: 0; text-shadow: 0 1px 2px var(--shadow-color); transition: opacity 0.3s ease, visibility 0s linear 0.3s, height 0s linear 0.3s;
             visibility: hidden; height: 0; overflow: hidden;
         }
         #header-timer-display.visible { opacity: 1; visibility: visible; height: auto; transition: opacity 0.3s ease, height 0s linear 0s, visibility 0s linear 0s; }
        /* --- END: Header Timer Display --- */

        /* --- Input/Select/Label Styles (Used in Withdrawal) --- */
        .input-group { margin-bottom: 15px; text-align: left; }
        .input-group label { display: block; margin-bottom: 5px; font-size: 0.9em; font-weight: 600; color: var(--text-label); }
        .input-group input[type="number"],
        .input-group input[type="text"],
        .input-group select {
            display: block; width: 100%; padding: 10px 12px; border: 1px solid var(--border-input); background-color: var(--bg-input);
            color: var(--text-light); border-radius: 5px; font-family: inherit; font-size: 1em; appearance: none; -webkit-appearance: none; -moz-appearance: none;
        }
        .input-group input::placeholder { color: var(--text-placeholder); opacity: 1; }
        .input-group select {
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23cccccc%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat; background-position: right 10px center; background-size: 10px 10px; padding-right: 30px;
            cursor: pointer;
        }
        body.light-mode .input-group select {
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23555555%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
        }
        /* --- End Input Styles --- */


        .modal input[type="number"] { display: block; width: 100%; padding: 10px 12px; margin-bottom: 10px; border: 1px solid var(--border-input); background-color: var(--bg-input); color: var(--text-light); border-radius: 5px; font-family: inherit; font-size: 1em; }
        .modal input::placeholder { color: var(--text-placeholder); opacity: 1; }
        .standard-button { padding: 10px 15px; border: none; border-radius: 5px; background-color: var(--bg-button-info); color: var(--text-dark); font-family: inherit; font-weight: 700; font-size: 1em; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; display: inline-block; margin-top: 5px; }
        .standard-button:hover:not(:disabled) { background-color: var(--bg-button-info-hover); transform: scale(1.03); }
        .standard-button:active:not(:disabled) { transform: scale(0.98); }
        .standard-button.action-button { background-color: var(--bg-button-action); }
        .standard-button.action-button:hover:not(:disabled) { background-color: var(--bg-button-action-hover); }
        .standard-button.special-button { background-color: var(--bg-button-special); }
        .standard-button.special-button:hover:not(:disabled) { background-color: var(--bg-button-special-hover); }
        .standard-button:disabled { background-color: #777; color: #bbb; cursor: not-allowed; transform: none; }

        .icon-button { position: absolute; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--accent-cyan); cursor: pointer; padding: 5px; border-radius: 50%; width: 40px; height: 40px; transition: background-color 0.2s ease, transform 0.2s ease, color 0.2s ease; z-index: 210; display: block; font-size: 24px; line-height: 30px; text-align: center; }
        .icon-button:hover { background-color: rgba(128, 128, 128, 0.1); transform: translateY(-50%) scale(1.1); }
        .icon-button svg { width: 100%; height: 100%; vertical-align: middle; fill: var(--accent-cyan); transition: fill var(--transition-speed) var(--transition-timing); }
        #menu-button { left: 15px; top: 27.5px; }
        #settings-button { right: 15px; top: 27.5px; color: var(--accent-cyan); }
        #side-menu { position: fixed; top: 0; left: calc(var(--menu-width) * -1); width: var(--menu-width); height: 100%; background-color: var(--bg-menu); backdrop-filter: blur(var(--backdrop-blur-heavy)); box-shadow: 4px 0 15px var(--shadow-color); z-index: 400; transition: left var(--transition-speed) cubic-bezier(0.25, 0.8, 0.25, 1), background-color var(--transition-speed) var(--transition-timing); padding: 60px 0 20px 0; display: flex; flex-direction: column; overflow-y: auto; }
        #side-menu.open { left: 0; }
        .menu-item-button { display: block; width: 100%; padding: 15px 25px; text-align: left; background: none; border: none; border-bottom: 1px solid var(--border-menu-item); color: var(--text-light); font-family: inherit; font-size: 1.1em; font-weight: 400; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color var(--transition-speed) var(--transition-timing); }
        .menu-item-button:first-of-type { border-top: 1px solid var(--border-menu-item); }
        .menu-item-button:hover { background-color: rgba(128, 128, 128, 0.08); color: var(--accent-cyan); }
        #settings-popup { display: none; position: absolute; top: 60px; right: 15px; background-color: var(--bg-ui-panel); backdrop-filter: blur(var(--backdrop-blur)); border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; box-shadow: var(--shadow-panel); z-index: 350; min-width: 180px; text-align: left; }
        #settings-popup .setting-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        #settings-popup .setting-item p { margin: 0; font-size: 0.95em; color: var(--text-medium); }
        .theme-switch { position: relative; display: inline-block; width: 50px; height: 26px; flex-shrink: 0; }
        .theme-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-toggle-track); transition: background-color var(--transition-speed) var(--transition-timing); border-radius: 26px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: transform var(--transition-speed) var(--transition-timing), background-color var(--transition-speed) var(--transition-timing); border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        input:checked + .slider { background-color: var(--bg-toggle-track-active); }
        input:focus + .slider { box-shadow: 0 0 1px var(--bg-toggle-track-active); }
        input:checked + .slider:before { transform: translateX(24px); }
        .fullscreen-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-overlay); backdrop-filter: blur(var(--backdrop-blur-heavy)); z-index: 500; display: none; padding: 80px 20px 20px 20px; overflow-y: auto; color: var(--text-light); align-items: center; justify-content: flex-start; flex-direction: column; text-align: center; animation: fadeInOverlay 0.3s ease-out; }
        @keyframes fadeInOverlay { from { opacity: 0; } to { opacity: 1; } }
        .overlay-close-button { position: absolute; top: 15px; right: 15px; padding: 8px 12px; background-color: var(--bg-button-action); color: var(--text-dark); border: none; border-radius: 5px; font-size: 1em; font-weight: 700; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease, color var(--transition-speed) var(--transition-timing); z-index: 510; }
        .overlay-close-button:hover { background-color: var(--bg-button-action-hover); transform: scale(1.05); }
        .overlay-title { font-size: 2em; font-weight: 700; color: var(--text-heading-accent); margin-bottom: 20px; margin-top: 20px; }
        .overlay-content { width: 100%; max-width: 450px; padding: 25px; background-color: var(--bg-ui-panel); border-radius: 10px; box-shadow: var(--shadow-panel); color: var(--text-light); display: flex; flex-direction: column; gap: 15px; }
        .overlay-content p { font-size: 1.1em; color: var(--text-medium); margin-bottom: 0; line-height: 1.6; }
        .overlay-content p strong { color: var(--accent-cyan); word-break: break-all; }
        .overlay-content p strong.highlight { color: var(--accent-yellow); font-weight: 700; }
        #profile-overlay .profile-info-item { display: flex; justify-content: space-between; align-items: center; font-size: 1.1em; color: var(--text-medium); padding: 5px 0; border-bottom: 1px solid var(--border-color); }
        #profile-overlay .profile-info-item:last-child { border-bottom: none; }
        #profile-overlay .profile-info-item span { margin-right: 15px; }
        #profile-overlay .profile-info-item strong { color: var(--text-light); word-break: break-all; text-align: right; margin-top: 0; }
        #tasks-overlay .overlay-content { background-color: transparent; box-shadow: none; padding: 0; max-width: 500px; display: flex; flex-direction: column; gap: 30px; }
        .task-group { background-color: var(--bg-ui-panel); border-radius: 10px; box-shadow: var(--shadow-panel); padding: 20px; width: 100%; }
        .task-group h3 { font-size: 1.4em; color: var(--text-heading-accent); margin-top: 0; margin-bottom: 20px; text-align: center; font-weight: 700; }
        .task-group .task-list { display: flex; flex-direction: column; gap: 15px; }
        .task-item { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; background-color: var(--bg-link-button); padding: 10px 15px; border-radius: 8px; border: 1px solid var(--border-link-button); }
        .task-item span { font-size: 1em; color: var(--text-medium); margin-right: 15px; flex-grow: 1; text-align: left; margin-bottom: 5px; }
        .task-item .link-button { display: inline-flex; align-items: center; padding: 8px 18px; border-radius: 20px; background-color: var(--bg-button-info); color: var(--text-dark); text-decoration: none; font-weight: 700; font-size: 0.9em; transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; box-shadow: var(--shadow-button); cursor: pointer; white-space: nowrap; border: none; flex-shrink: 0; }
        .task-item .link-button:hover { background-color: var(--bg-button-info-hover); transform: scale(1.04); box-shadow: var(--shadow-button-hover); }
        .task-item .link-button svg { width: 18px; height: 18px; fill: currentColor; margin-right: 8px; }
        .task-item .link-button.x-link { background-color: var(--bg-button-x); color: white; }
        .task-item .link-button.x-link:hover { background-color: var(--bg-button-x-hover); }
        .task-item .link-button.youtube-link { background-color: #FF0000; color: white; }
        .task-item .link-button.youtube-link:hover { background-color: #CC0000; }
        .task-item .link-button.submit-link { background-color: var(--bg-button-special); color: var(--text-dark); }
        .task-item .link-button.submit-link:hover { background-color: var(--bg-button-special-hover); }
        #sponsor-contact-button { display: block; width: fit-content; margin: 10px auto 0 auto; padding: 10px 20px; }

        /* --- Withdrawal Overlay Styles --- */
        #withdrawal-overlay .overlay-content { gap: 25px; }
        .withdrawal-section {
            background-color: var(--bg-withdrawal-section); border: 1px solid var(--border-withdrawal-section);
            border-radius: 8px; padding: 20px; text-align: left;
        }
        .withdrawal-section h3 {
            font-size: 1.3em; color: var(--text-heading-accent); margin-top: 0; margin-bottom: 15px; text-align: center; font-weight: 700;
        }
        .withdrawal-section ul { list-style: none; padding-left: 0; margin: 0; }
        .withdrawal-section li {
            font-size: 1em; color: var(--text-medium); margin-bottom: 10px; line-height: 1.5; padding-left: 20px; position: relative;
        }
        .withdrawal-section li::before { content: "•"; position: absolute; left: 0; color: var(--accent-cyan); font-weight: bold; display: inline-block; width: 20px; }
        .withdrawal-section li strong { color: var(--accent-yellow); font-weight: 600; }
        #withdraw-main-button {
            padding: 12px 25px; border: none; border-radius: 8px; background-color: #999; color: #eee; font-family: inherit;
            font-weight: 700; font-size: 1.1em; cursor: not-allowed; opacity: 0.6; margin-top: 20px; display: block; width: 100%;
        }
        /* --- End Withdrawal Overlay Styles --- */

        #friends-overlay .overlay-content { gap: 20px; }
        #friends-overlay .referral-info { display: flex; flex-direction: column; gap: 10px; text-align: center; margin-bottom: 15px; }
        #referral-link-container { display: flex; align-items: center; gap: 10px; background-color: var(--bg-input); padding: 8px 12px; border-radius: 6px; margin-top: 10px; border: 1px solid var(--border-input); }
        #referral-link-display { flex-grow: 1; font-size: 0.9em; color: var(--text-medium); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: left; }
        #copy-referral-link-button { padding: 6px 10px; font-size: 0.85em; font-weight: 600; background-color: var(--bg-copy-button); color: var(--text-copy-button); border: 1px solid var(--border-copy-button); border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
        #copy-referral-link-button:hover { background-color: var(--bg-copy-button-hover); color: var(--text-copy-button-hover); }
        #friends-overlay .referral-count { font-size: 1.2em; font-weight: 700; color: var(--text-light); margin-bottom: 10px; padding-bottom: 10px; text-align: center; border-bottom: 1px solid var(--border-color); }
        #friends-overlay .referral-count strong { color: var(--accent-yellow); }
        #referral-list-container { width: 100%; max-height: 280px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; background-color: rgba(0,0,0,0.1); padding: 10px; scrollbar-width: thin; scrollbar-color: var(--accent-cyan) rgba(0,0,0,0.1); }
        #referral-list-container::-webkit-scrollbar { width: 6px; }
        #referral-list-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 3px;}
        #referral-list-container::-webkit-scrollbar-thumb { background-color: var(--accent-cyan); border-radius: 3px; }
        #referral-list { display: flex; flex-direction: column; gap: 10px; }
        .referral-item { display: flex; align-items: center; justify-content: space-between; background-color: var(--bg-link-button); padding: 10px 15px; border-radius: 6px; border: 1px solid var(--border-link-button); }
        .referral-item span { font-size: 1em; color: var(--text-medium); flex-grow: 1; margin-right: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; order: -1; z-index: 1; }
        #game-canvas { display: block; width: 100%; height: 100%; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; }


        /* --- Generic Modal Styles (Apply First) --- */
        .modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: var(--bg-modal); backdrop-filter: blur(var(--backdrop-blur-heavy));
            padding: 30px 40px; border-radius: 15px; text-align: center;
            z-index: 600; display: none; box-shadow: var(--shadow-modal);
            width: 90%; max-width: 400px; border: 1px solid var(--border-color);
            pointer-events: auto; color: var(--text-light);
        }
        /* Generic Title Style (Top, Centered) */
        .modal h2 {
            margin: 0 0 20px 0; /* Space below title */
            font-size: 2.1em; /* Larger title */
            font-weight: 700;
            color: var(--text-heading-accent);
            text-align: center; /* Explicitly center */
        }
        /* Generic Paragraph Style (Below Title, Centered) */
        .modal p {
            font-size: 1.1em;
            margin-bottom: 25px; /* Space below paragraph, above buttons */
            font-weight: 400;
            color: var(--text-medium);
            line-height: 1.5;
            text-align: center; /* Explicitly center */
        }
        /* Generic Button Container (Bottom) */
        .modal-buttons {
            margin-top: 20px; /* Space above buttons */
            display: flex;
            justify-content: space-between; /* Buttons pushed to left/right */
            gap: 15px; /* Space between buttons */
            flex-wrap: nowrap; /* Prevent wrapping */
        }
        /* Generic Button Style (Inside Container) */
        .modal-button {
            padding: 12px 15px; /* Adjust padding */
            font-size: 1em; /* Adjust font size */
            flex-grow: 1; /* Allow buttons to take available space */
            flex-basis: 0; /* Distribute space evenly */
            min-width: 100px; /* Minimum button width */
            text-align: center;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: var(--bg-button-info);
            color: var(--text-dark);
            font-weight: 700;
            transition: all .2s ease;
            pointer-events: auto;
            text-transform: uppercase;
            letter-spacing: 0.5px; /* Adjust letter spacing */
            box-shadow: var(--shadow-button);
        }
        .modal-button:disabled {
            opacity: 0.5; cursor: not-allowed; background-color: #999; color: #eee;
            transform: none; box-shadow: none;
        }
        .modal-button:hover:not(:disabled) {
            background-color: var(--bg-button-info-hover);
            transform: translateY(-2px) scale(1.02); box-shadow: var(--shadow-button-hover);
        }
        .modal-button:active:not(:disabled) {
            transform: translateY(0px) scale(0.98); box-shadow: 0 1px 3px var(--shadow-color);
        }
        .modal-button.boost-button { background-color: var(--bg-button-watch-ad); }
        .modal-button.boost-button:hover:not(:disabled) { background-color: var(--bg-button-watch-ad-hover); }
        .modal-button.special-button { background-color: var(--bg-button-special); } /* Added for Watch Ad */
        .modal-button.special-button:hover:not(:disabled) { background-color: var(--bg-button-special-hover); }


        /* --- Game Over Modal Specific Styles --- */
        #game-over-ui h2 {
             /* Inherits general .modal h2 styles */
             margin-bottom: 15px; /* Less space below Game Over title */
        }
        #game-over-ui p#game-over-message {
            /* Inherits general .modal p styles */
            font-size: 1.2em; /* Slightly larger than generic p */
            min-height: 1.5em; /* Prevent collapsing if message is short */
            margin-bottom: 25px; /* Space between message and buttons */
        }
        #game-over-buttons {
            /* Inherits general .modal-buttons styles (flex, space-between, gap, nowrap) */
             margin-top: 0; /* Override generic margin as message provides space */
        }
        #game-over-ui .game-over-button {
            /* Inherits general .modal-button styles (flex grow/basis, min-width, etc.) */
            /* Add specific Game Over button colors */
            background-color: var(--bg-button-info); /* Default Play Again */
        }
        #game-over-ui .game-over-button:hover:not(:disabled) {
             background-color: var(--bg-button-info-hover);
        }
        #watch-ad-button.game-over-button {
             background-color: var(--bg-button-special); /* Watch Ad yellow */
        }
        #watch-ad-button.game-over-button:hover:not(:disabled) {
             background-color: var(--bg-button-special-hover);
        }


        /* --- Start Game Modal Specific Styles --- */
        #start-game-modal h2 {
            /* Inherits general .modal h2 styles */
             margin-bottom: 25px; /* More space below Start Game title */
        }
        #start-game-modal p {
            display: none; /* Hide the paragraph */
        }
        #start-game-modal .modal-buttons {
            /* Inherits general .modal-buttons styles (flex, space-between, gap, nowrap) */
            margin-top: 0; /* Place buttons directly below title */
        }
        #start-game-modal .modal-button {
            /* Inherits general .modal-button styles (flex grow/basis, min-width, etc.) */
             /* Specific colors are handled by boost-button class */
        }
        /* Style for the "Normally" button in start game */
        #start-normal-button.modal-button {
             background-color: var(--bg-button-info);
        }
         #start-normal-button.modal-button:hover:not(:disabled) {
             background-color: var(--bg-button-info-hover);
        }


        #menu-overlay-dimmer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 399; display: none; opacity: 0; transition: opacity var(--transition-speed) ease-in-out; }
        #menu-overlay-dimmer.visible { display: block; opacity: 1; }
    </style>

    <!-- Ad SDK Script Tag (Only for Game Over "Watch Ad & Save" AND Start Game "2x Boost") -->
    <script src='//whephiwums.com/sdk.js' data-zone='9292240' data-sdk='show_9292240'></script>
</head>
<body>

    <!-- Header Bar -->
    <div id="header-bar">
        <div id="score-wrapper">
            <div class="score-display"> <span class="score-label">Current</span> <span id="current-score">0</span> </div>
            <div class="score-display"> <span class="score-label">Total</span> <span id="total-score">...</span> </div>
        </div>
        <!-- Header Timer Display (Still used during gameplay) -->
        <div id="header-timer-display">0:00</div>
        <!-- Menu/Settings Buttons -->
        <button id="menu-button" class="icon-button" aria-label="Open Menu">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path fill-rule="evenodd" d="M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z" clip-rule="evenodd" /> </svg>
        </button>
        <button id="settings-button" class="icon-button" aria-label="Settings"> ⚙️ </button>
        <div id="settings-popup">
             <div class="setting-item">
                 <p>Light Mode</p>
                 <label class="theme-switch"> <input type="checkbox" id="theme-toggle-checkbox"> <span class="slider round"></span> </label>
             </div>
        </div>
    </div>

    <!-- Side Menu -->
    <div id="side-menu">
        <button class="menu-item-button" data-action="show-profile">Profile</button>
        <button class="menu-item-button" data-action="show-withdrawal">Withdrawal</button>
        <button class="menu-item-button" data-action="show-friends">Friends</button>
        <button class="menu-item-button" data-action="show-tasks">Tasks</button>
    </div>
    <div id="menu-overlay-dimmer"></div>

    <!-- Fullscreen Overlays -->
    <div id="profile-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="profile-overlay">Close</button>
        <h2 class="overlay-title">Profile</h2>
        <div class="overlay-content">
             <div class="profile-info-item"> <span>Telegram ID:</span> <strong id="user-id-overlay">...</strong> </div>
             <div class="profile-info-item"> <span>Username:</span> <strong id="username-overlay">...</strong> </div>
             <div class="profile-info-item"> <span>Total Score:</span> <strong id="profile-total-score-display">...</strong> </div>
        </div>
    </div>

    <!-- Withdrawal Overlay (Revised Structure) -->
    <div id="withdrawal-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="withdrawal-overlay">Close</button>
        <h2 class="overlay-title">Withdrawal</h2>
        <div class="overlay-content"> <!-- Single overlay content container -->

            <!-- Rules Section -->
            <div class="withdrawal-section" id="withdrawal-rules-section">
                <h3>Rules</h3>
                <ul>
                    <li>Withdrawals will be enabled in <strong>early or late July</strong>.</li>
                    <li>Minimum <strong>10 referrals</strong> required.</li>
                    <li>Withdrawal amount: Min <strong>100,000</strong> points, Max <strong>10,000,000</strong> points per request.</li>
                    <li>Conversion: <strong>1000</strong> points = <strong>0.001 TON</strong> | <strong>1000</strong> points = <strong>0.00004 SOL</strong>.</li>
                    <li>Provide your <strong>TON</strong> (The Open Network) address for TON withdrawals.</li>
                    <li>Provide your <strong>SOL</strong> (BEP-20 Network) address for SOL withdrawals.</li>
                </ul>
            </div>

            <!-- Withdrawal Details Section -->
            <div class="withdrawal-section" id="withdrawal-details-section">
                 <h3>Withdrawal Details</h3>
                 <div class="input-group">
                     <label for="withdrawal-points">Points to Withdraw:</label>
                     <input type="number" id="withdrawal-points" name="withdrawal-points" placeholder="100,000 - 10,000,000" min="100000" max="10000000" step="1">
                 </div>
                 <div class="input-group">
                     <label for="withdrawal-crypto">Select Crypto:</label>
                     <select id="withdrawal-crypto" name="withdrawal-crypto">
                         <option value="ton">TON (The Open Network)</option>
                         <option value="sol">SOL (BEP-20 Network)</option>
                     </select>
                 </div>
                 <div class="input-group">
                     <label for="withdrawal-address">Wallet Address:</label>
                     <input type="text" id="withdrawal-address" name="withdrawal-address" placeholder="Enter your wallet address">
                 </div>
                 <button id="withdraw-main-button" disabled>Withdraw (Coming Soon)</button>
            </div>

        </div>
    </div>
    <!-- End Withdrawal Overlay -->

    <div id="friends-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="friends-overlay">Close</button>
        <h2 class="overlay-title">Friends</h2>
        <div class="overlay-content">
            <div class="referral-info">
                <p>Invite your friends using your unique referral link!</p>
                 <div id="referral-link-container">
                     <span id="referral-link-display">Generating link...</span>
                     <button id="copy-referral-link-button">Copy</button>
                 </div>
            </div>
            <div class="referral-count"> Total Referrals: <strong id="referral-count-display">0</strong> </div>
            <div id="referral-list-container">
                <div id="referral-list"> <p style="text-align: center; opacity: 0.7;">Loading referrals...</p> </div>
            </div>
        </div>
    </div>
    <div id="tasks-overlay" class="fullscreen-overlay">
         <button class="overlay-close-button" data-overlay-id="tasks-overlay">Close</button>
         <h2 class="overlay-title">Tasks</h2>
         <div class="overlay-content" style="gap: 20px;">
            <div class="task-group">
                <h3>Follow Social Accounts</h3>
                <div class="task-list">
                    <div class="task-item"> <span>Join Telegram Channel</span> <a href="https://t.me/helix_cryptodrop" target="_blank" rel="noopener noreferrer" class="link-button"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.17.91-.497 1.208-.82 1.23-.696.047-1.225-.46-1.9-.91-.546-.353-1.075-.688-1.758-1.104l-.108-.061c-1.218-.78-1.896-1.182-1.736-1.889.05-.212.333-.717.333-.717l.11-.24s4.17-3.8 4.576-4.18c.07-.07.12-.15.05-.23-.07-.08-.18-.05-.25-.02-.11.04-1.88 1.16-5.36 3.34-.47.29-.88.43-1.28.42-.49-.01-.97-.13-1.42-.25-1.03-.28-1.88-.42-1.79-.93.04-.22.31-.42.88-.63 3.41-1.22 5.68-2.07 6.94-2.51.3-.11.56-.2.78-.2z"/></svg> Join </a> </div>
                    <div class="task-item"> <span>Follow on X (Twitter)</span> <a href="https://x.com/drop_official89?t=lJ9kaQKLwWQk41avHSJdhw&s=08" target="_blank" rel="noopener noreferrer" class="link-button x-link"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg> Follow </a> </div>
                    <div class="task-item"> <span>Subscribe on YouTube</span> <a href="https://youtube.com/@YourChannelName" target="_blank" rel="noopener noreferrer" class="link-button youtube-link"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" > <path fill-rule="evenodd" d="M19.802 5.578a3.75 3.75 0 0 0-2.652-2.652C15.547 2.5 12 2.5 12 2.5s-3.547 0-5.15.426A3.75 3.75 0 0 0 4.198 5.578C3.773 7.18 3.773 12 3.773 12s0 4.82.425 6.422a3.75 3.75 0 0 0 2.652 2.652C8.453 21.5 12 21.5 12 21.5s3.547 0 5.15-.426a3.75 3.75 0 0 0 2.652-2.652C20.227 16.82 20.227 12 20.227 12s0-4.82-.425-6.422ZM9.75 15.5V8.5l6 3.5-6 3.5Z" clip-rule="evenodd" /> </svg> Subscribe </a> </div>
                </div>
            </div>
            <div class="task-group">
                <h3>Creator Media Rewards</h3>
                 <div class="task-list">
                     <div class="task-item"> <span>Created Instagram Content? Submit Proof for Rewards</span> <a href="#creator-submission" class="link-button submit-link"> Submit Proof </a> </div>
                     <div class="task-item"> <span>Created YouTube Content? Submit Proof for Rewards</span> <a href="#creator-submission" class="link-button submit-link"> Submit Proof </a> </div>
                     <div class="task-item"> <span>Created Facebook Content? Submit Proof for Rewards</span> <a href="#creator-submission" class="link-button submit-link"> Submit Proof </a> </div>
                 </div>
            </div>
             <div class="task-group">
                 <h3>Sponsorship & Partnership</h3>
                 <p style="font-size: 1em; text-align: center; margin-bottom: 15px;">Are you interested in sponsoring or partnering with Helix Point Drop?</p>
                 <a href="mailto:youremail@example.com?subject=Sponsorship Inquiry - Helix Point Drop" id="sponsor-contact-button" class="standard-button special-button">Contact Us</a>
             </div>
         </div>
     </div>

    <!-- Game Over UI -->
    <div id="game-over-ui" class="modal">
        <h2>Game Over!</h2>
        <p id="game-over-message">Score: <span id="final-score">0</span></p>
        <div id="game-over-buttons" class="modal-buttons"> <!-- Use generic class -->
            <button id="watch-ad-button" class="game-over-button modal-button special-button">Watch Ad & Save</button> <!-- Use generic + specific class -->
            <button id="restart-button" class="game-over-button modal-button">Play Again</button> <!-- Use generic + specific class -->
        </div>
    </div>

    <!-- Start Game Modal -->
    <div id="start-game-modal" class="modal">
        <h2>Start Game</h2>
        <p>Start normally or watch an ad for a points boost!</p> <!-- This is hidden by CSS -->
        <div class="modal-buttons"> <!-- Use generic class -->
            <button id="start-boost-button" class="modal-button boost-button">2x Points</button> <!-- Use generic + boost class -->
            <button id="start-normal-button" class="modal-button">Normally</button> <!-- Use generic class -->
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container"> <canvas id="game-canvas"></canvas> </div>

    <!-- Initial Controls Container (Centered) -->
    <div id="initial-controls-container">
        <h3>Select Difficulty & Start</h3>
         <!-- Difficulty Options replaces Timer Options -->
         <div id="difficulty-options">
             <button class="difficulty-button active" data-difficulty="easy">Easy</button>
             <button class="difficulty-button" data-difficulty="medium">Medium</button>
             <button class="difficulty-button" data-difficulty="hard">Hard</button>
         </div>
         <button id="start-game-button">Start Game (1 Min)</button>
    </div>

    <!-- *********************************************************** -->
    <!-- * MOCK TELEGRAM OBJECT SCRIPT REMOVED                     * -->
    <!-- *********************************************************** -->


    <!-- Libraries & SDKs -->
    <script type="importmap">{
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js",
            "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/",
            "@supabase/supabase-js": "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm"
        }
    }</script>
    <!-- ADDED: Supabase Client (via importmap) -->


    <!-- Game Logic (as module) -->
    <script type="module">

        // --- Imports ---
        import * as THREE from 'three';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { TextureLoader } from 'three';
        import { createClient } from '@supabase/supabase-js'; // Import Supabase

        // --- Constants ---
        const BOT_USERNAME = "Crypto_drop_ya_bot"; // !! UPDATE WITH YOUR BOT USERNAME
        const MINI_APP_NAME = ""; // Optional: If your app isn't at the root, e.g., "myapp" for t.me/bot/myapp
        const FADE_DURATION = 500;
        // !! IMPORTANT: Replace with your Supabase Project URL and Anon Key
        const SUPABASE_URL = 'https://ihoguaucknakkmywqunm.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imlob2d1YXVja25ha2tteXdxdW5tIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY0NTk4MzgsImV4cCI6MjA2MjAzNTgzOH0.GjX0iJnQWrdD1-T2H1cMG9yXOeHfo3eQK5Sk8F3NN6w';
        const GAME_DURATION_SECONDS = 60; // Fixed duration for all modes


        // --- Global Variables ---
        let scene, camera, renderer, composer, bloomPass;
        let ball, platformGroup, poleGroup, starField;
        let currentScore = 0;
        let gameState = 'initializing'; // States: initializing, ready, playing, gameOver, error
        let internalPauseState = false;
        let rotationSensitivity = 0.02, bounceSpeed = 0.11;
        let currentBallVelocityY = 0, ballPreviousY = 0, lastSafePlatformY = 0;
        const gravity = -0.0035;
        const platformRadius = 2.5, poleRadius = 0.5, gapSize = Math.PI / 2.5;
        const platformSegments = 3, platformSpacingY = 2.0;
        let activePlatforms = [], nextPlatformY = 0;
        let activePoleSegments = {};
        let scoreIncrementedForPlatform = {};
        const ballStartX = 1.5; const ballStartZ = 0; const initialBallY = 8;
        const cameraVerticalOffset = 4.5, cameraLookAtOffset = 1.0;
        const cameraFixedZ = 11; const cameraZoomedInZ = 9.5; const cameraZoomDuration = 600;
        let isCameraZooming = false; let cameraZoomRequestId = null;
        const cameraFollowLerpFactor = 0.08;
        let envMap = null;
        const clock = new THREE.Clock();
        let ballTexture = null;
        const textureLoader = new TextureLoader();
        const platformColorPalette = [ 0x00cfde, 0x8e44ad, 0x3498db, 0x2ecc71, 0xe74c3c, 0xf39c12 ];
        let platformColorIndex = 0;
        let shakeIntensity = 0; const shakeDecreaseFactor = 0.9; const maxShakeOffset = 0.15;
        let isPointerDown = false; let previousPointerX = 0;
        let adTimerIntervalId = null;

        // --- Difficulty & Game Start Variables ---
        let selectedDifficulty = 'easy'; // Default difficulty: 'easy', 'medium', 'hard'
        let currentGameCountdown = 0;
        let gameTimerIntervalId = null;
        let scoreMultiplier = 1;
        let isTimedGameActive = false; // Renamed from isGameActive for clarity

        // --- Element References ---
        const currentScoreEl = document.getElementById('current-score');
        const totalScoreEl = document.getElementById('total-score');
        const scoreWrapper = document.getElementById('score-wrapper');
        const gameOverUI = document.getElementById('game-over-ui');
        const finalScoreEl = document.getElementById('final-score');
        const gameOverMessageP = document.getElementById('game-over-message');
        const restartButton = document.getElementById('restart-button');
        const watchAdButton = document.getElementById('watch-ad-button');
        const gameContainer = document.getElementById('game-container');
        const headerBar = document.getElementById('header-bar');
        const menuButton = document.getElementById('menu-button');
        const settingsButton = document.getElementById('settings-button');
        const sideMenu = document.getElementById('side-menu');
        const menuOverlayDimmer = document.getElementById('menu-overlay-dimmer');
        const settingsPopup = document.getElementById('settings-popup');
        const profileOverlay = document.getElementById('profile-overlay');
        const profileTotalScoreDisplay = document.getElementById('profile-total-score-display');
        const userIdOverlay = document.getElementById('user-id-overlay');
        const usernameOverlay = document.getElementById('username-overlay');
        const withdrawalOverlay = document.getElementById('withdrawal-overlay');
        const friendsOverlay = document.getElementById('friends-overlay');
        const tasksOverlay = document.getElementById('tasks-overlay');
        const sponsorContactButton = document.getElementById('sponsor-contact-button');
        const overlayCloseButtons = document.querySelectorAll('.overlay-close-button');
        const menuItemButtons = sideMenu.querySelectorAll('.menu-item-button');
        const themeToggleCheckbox = document.getElementById('theme-toggle-checkbox');
        const referralLinkDisplay = document.getElementById('referral-link-display');
        const copyReferralLinkButton = document.getElementById('copy-referral-link-button');
        const referralCountDisplay = document.getElementById('referral-count-display');
        const referralList = document.getElementById('referral-list');
        // --- Control and Timer/Difficulty Elements ---
        const initialControlsContainer = document.getElementById('initial-controls-container');
        const difficultyOptionsDiv = initialControlsContainer.querySelector('#difficulty-options'); // Changed ID
        const difficultyButtons = difficultyOptionsDiv.querySelectorAll('.difficulty-button'); // Changed class
        const startGameButton = initialControlsContainer.querySelector('#start-game-button');
        const headerTimerDisplayEl = document.getElementById('header-timer-display');
        const startGameModal = document.getElementById('start-game-modal');
        const startNormalButton = document.getElementById('start-normal-button');
        const startBoostButton = document.getElementById('start-boost-button');
        // --- Withdrawal Elements ---
        const withdrawMainButton = document.getElementById('withdraw-main-button'); // Reference the button


        // --- Supabase Setup ---
        let supabase = null; // Supabase client instance
        let telegramUserId = null; // Will be a number (BigInt)
        let telegramUserData = null; // Telegram user object
        let currentUserTotalScore = 0n; // Use BigInt literal for score cache
        let currentUserReferralCount = 0;
        // No need for currentUserReferrals global variable, fetch on demand
        let userRealtimeChannel = null; // For listening to user's own score/ref count changes
        let hasProcessedReferral = false;


        // --- Utility Functions ---
        function getCssVariable(varName) { return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
        function parseColorHex(colorString) { if (colorString.startsWith('#')) { return parseInt(colorString.substring(1), 16); } console.warn(`Could not parse color hex: ${colorString}`); return 0xffffff; }
        function formatNumber(num) { try { // Add try-catch for safety during BigInt conversion
             if (typeof num !== 'number' && typeof num !== 'bigint' && typeof num !== 'string') return num; // Handle non-numeric types gracefully
             return BigInt(num).toLocaleString(); // Handle BigInt from Supabase or currentScore
             } catch (e) { console.warn("formatNumber error:", e, "Input:", num); return String(num); /* Fallback to string */ }
        }
        function maskUsername(username) { if (!username || username.length <= 3) return "***"; return username.substring(0, 3) + '*'.repeat(username.length - 3); }
      
  function generateReferralLink(userId) {
    // CORRECTED: Removed the check for the specific bot name string
    if (!userId) {
        console.warn("generateReferralLink called without a userId."); // Added a warning for missing ID
        return "Link Unavailable";
    }
    // Keep the console warning for the specific bot name just in case, but it won't block execution now.
    if (BOT_USERNAME === "Crypto_drop_ya_bot") {
        console.warn("Note: Your BOT_USERNAME is set to 'Crypto_drop_ya_bot'. Ensure this is correct.");
    }
    const appPath = MINI_APP_NAME ? `/${MINI_APP_NAME}` : '';
    return `https://t.me/${BOT_USERNAME}${appPath}?startapp=${userId}`;
}
        async function copyToClipboard(text) { if (!navigator.clipboard) { console.warn("Clipboard API missing"); return false; } try { await navigator.clipboard.writeText(text); return true; } catch (err) { console.error('Copy fail: ', err); return false; } }
        function formatTime(seconds) {
            if (typeof seconds !== 'number' || seconds < 0) seconds = 0;
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }


        // --- UI Update & State Management ---
        function updateScoreUI() { if (currentScoreEl) currentScoreEl.textContent = formatNumber(currentScore); }
        function updateTotalScoreUI(score) { try { // Add try-catch here too
              const fmt = formatNumber(score); // Format using the safe function
              if (totalScoreEl) totalScoreEl.textContent = String(fmt);
              if (profileTotalScoreDisplay) profileTotalScoreDisplay.textContent = String(fmt);
              currentUserTotalScore = BigInt(score); // Update local cache, ensure it's BigInt
            } catch(e) { console.error("Error updating total score UI:", e, "Score:", score); if (totalScoreEl) totalScoreEl.textContent = "Error"; if (profileTotalScoreDisplay) profileTotalScoreDisplay.textContent = "Error"; currentUserTotalScore = 0n; /* Reset cache on error */ }
        }
        function updateReferralCountUI(count) { const fmt = formatNumber(count || 0); if(referralCountDisplay) referralCountDisplay.textContent = String(fmt); currentUserReferralCount = Number(count || 0); // Update local cache
        }
        function updateReferralLinkUI(userId) { if (referralLinkDisplay) referralLinkDisplay.textContent = generateReferralLink(userId); }

        async function populateReferralListUI() {
             if (!referralList || !telegramUserId) return;
             referralList.innerHTML = '<p style="text-align: center; opacity: 0.7;">Loading referrals...</p>'; // Show loading state

             try {
                const { data, error } = await supabase.rpc('get_user_referrals', { p_user_id: telegramUserId });

                if (error) {
                    console.error("Error fetching referrals:", error);
                    referralList.innerHTML = '<p style="text-align: center; color: var(--text-error);">Could not load referrals.</p>';
                    return;
                }

                referralList.innerHTML = ''; // Clear loading/previous state
                if (!data || data.length === 0) {
                    referralList.innerHTML = '<p style="text-align: center; opacity: 0.7;">No referrals yet.</p>';
                    return;
                }

                data.forEach(ref => {
                    const li = document.createElement('div');
                    li.className = 'referral-item';
                    const span = document.createElement('span');
                    // Use first_name if username is null/empty, otherwise use masked username
                    const displayName = ref.ref_username ? maskUsername(ref.ref_username) : (ref.ref_first_name || 'User');
                    span.textContent = displayName;
                    li.appendChild(span);
                    referralList.appendChild(li);
                });

             } catch(e) {
                 console.error("Exception fetching referrals:", e);
                 referralList.innerHTML = '<p style="text-align: center; color: var(--text-error);">Error loading referrals.</p>';
             }
         }

        function setInternalPause(pause) {
            if (internalPauseState === pause) return;
            internalPauseState = pause;
            if (!pause && gameState === 'playing' && isTimedGameActive) {
                 clock.getDelta(); // Reset delta on resume
            }
            console.log("Internal Pause State:", internalPauseState);
         }
        function isAnyUIOverlayOpen() {
             return sideMenu.classList.contains('open') ||
                    settingsPopup.style.display === 'block' ||
                    profileOverlay.style.display === 'flex' ||
                    withdrawalOverlay.style.display === 'flex' ||
                    friendsOverlay.style.display === 'flex' ||
                    tasksOverlay.style.display === 'flex' ||
                    gameOverUI.style.display === 'block' ||
                    startGameModal.style.display === 'block' ||
                    (initialControlsContainer && !initialControlsContainer.classList.contains('hidden'));
         }
        function pauseGameForUI() {
            if (gameState === 'playing') {
                 setInternalPause(true);
                 console.log("Paused for UI (Physics/Input only)");
            }
        }
        function resumeGameFromUI() {
            // Resume only if NO overlays/UI are open
            if (!isAnyUIOverlayOpen()) {
                if (gameState === 'playing' && internalPauseState) {
                    setInternalPause(false);
                    console.log("Resumed from UI (Physics/Input only)");
                } else if (gameState === 'ready') {
                    // If going back to ready state, ensure initial controls are shown
                    showInitialControls();
                }
            }
        }


        // --- Supabase Functions ---
        function initializeSupabaseClient() {
            if (!SUPABASE_URL || !SUPABASE_ANON_KEY || SUPABASE_URL === 'YOUR_SUPABASE_URL') {
                console.error("Supabase URL or Anon Key is not configured. Please update the constants.");
                alert("Service Configuration Error. Cannot connect to the database.");
                gameState = 'error';
                setInternalPause(true);
                updateTotalScoreUI("Config Error");
                updateReferralCountUI("Config Error");
                return false;
            }
            try {
                supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log("Supabase Client Initialized OK");
                return true;
            } catch (e) {
                console.error("Supabase Client Init Failed:", e);
                alert("Service Initialization Error.");
                updateTotalScoreUI("Init Error");
                updateReferralCountUI("Init Error");
                gameState='error';
                setInternalPause(true);
                return false;
            }
        }

        function subscribeToUserData(tgUserId) {
            if (!supabase || !tgUserId) {
                console.warn("Supabase client or User ID not available for subscription.");
                return;
            }
            if (userRealtimeChannel) {
                supabase.removeChannel(userRealtimeChannel)
                    .then(() => console.log("Removed existing user data channel."))
                    .catch(e => console.warn("Error removing previous channel:", e));
                userRealtimeChannel = null;
            }

            console.log(`Subscribing to updates for user: ${tgUserId}`);
            userRealtimeChannel = supabase
               .channel(`user-data-${tgUserId}`)
               .on( // Main listener for table changes
                   'postgres_changes',
                   {
                       event: 'UPDATE',
                       schema: 'public',
                       table: 'users',
                       filter: `telegram_id=eq.${tgUserId}`
                   },
                   (payload) => {
                       console.log('User data UPDATE received:', payload);
                       const updatedUserData = payload.new;
                       if (updatedUserData) {
                           updateTotalScoreUI(updatedUserData.total_score ?? currentUserTotalScore);
                           updateReferralCountUI(updatedUserData.referral_count ?? currentUserReferralCount);
                       }
                   }
               )
               .on('SYSTEM', { event: 'error' }, (payload) => { // Listen for SYSTEM 'error' events
                   console.error(`Realtime channel error for user ${tgUserId}:`, payload);
               })
               .on('SYSTEM', { event: 'close' }, () => { // Listen for SYSTEM 'close' events
                   console.log(`Realtime channel explicitly closed for user ${tgUserId}.`);
               });


            // Now, call subscribe() and handle its callback for status updates
            userRealtimeChannel.subscribe((status, err) => {
                    if (status === 'SUBSCRIBED') {
                        console.log(`Successfully subscribed to channel: user-data-${tgUserId}`);
                    } else if (status === 'CHANNEL_ERROR') {
                        console.error(`Realtime channel error during subscribe for user ${tgUserId}:`, err);
                    } else if (status === 'TIMED_OUT') {
                         console.warn(`Realtime subscription timed out for user ${tgUserId}. Retrying might be needed.`);
                    } else if (status === 'CLOSED') {
                         console.log(`Realtime channel subscription stream closed for user ${tgUserId}.`)
                    } else {
                         console.log(`Realtime channel status update for user ${tgUserId}:`, status);
                    }
               });
        }

        // ========================================================================
        // START: fetchAndInitializeUser function (Unchanged from previous version)
        // ========================================================================
        async function fetchAndInitializeUser(tgUserId, tgUser) {
            if (!supabase || !tgUserId) {
                console.error("Cannot fetch user: Supabase client or User ID missing.");
                updateTotalScoreUI("Config Error");
                updateReferralCountUI("Config Error");
                gameState = 'error';
                setInternalPause(true);
                return null;
            }

            try {
                console.log(`Fetching/Initializing user: ${tgUserId}`);
                let { data: userData, error: fetchError } = await supabase
                    .from('users')
                    .select('total_score, referral_count, referred_by')
                    .eq('telegram_id', tgUserId)
                    .single();

                if (fetchError && fetchError.code !== 'PGRST116') {
                    console.error("Error during fetch (excluding not found):", fetchError);
                    throw fetchError;
                }

                if (userData) {
                    console.log(`User ${tgUserId} found. Data:`, userData);
                    const { error: updateError } = await supabase
                        .from('users')
                        .update({
                            last_seen_at: new Date().toISOString(),
                            username: tgUser?.username || userData.username || null,
                            first_name: tgUser?.first_name || userData.first_name || 'User'
                        })
                        .eq('telegram_id', tgUserId);
                    if (updateError) console.warn("Error updating last_seen (non-critical):", updateError);
                    updateTotalScoreUI(userData.total_score ?? 0);
                    updateReferralCountUI(userData.referral_count ?? 0);
                    subscribeToUserData(tgUserId);
                    return userData;

                } else {
                    console.log(`User ${tgUserId} not found. Attempting to create.`);
                    const newUserRecord = {
                        telegram_id: tgUserId,
                        username: tgUser?.username || null,
                        first_name: tgUser?.first_name || 'User',
                        first_seen_at: new Date().toISOString(),
                        last_seen_at: new Date().toISOString()
                    };
                    const { data: insertedData, error: insertError } = await supabase
                        .from('users')
                        .insert(newUserRecord)
                        .select('total_score, referral_count, referred_by')
                        .single();

                    if (insertError) {
                        console.error("Error creating new user:", insertError);
                        if (insertError.code === '42501') console.error("RLS policy might be blocking INSERT. Check 'Allow anon insert access' policy.");
                        throw insertError;
                    }
                    if (insertedData) {
                        console.log("New user created successfully. Inserted Data:", insertedData);
                        updateTotalScoreUI(insertedData.total_score ?? 0);
                        updateReferralCountUI(insertedData.referral_count ?? 0);
                        subscribeToUserData(tgUserId);
                        return insertedData;
                    } else {
                        console.error("Insert succeeded but no data returned.");
                        throw new Error("Insert operation failed to return data.");
                    }
                }
            } catch (error) {
                console.error("Failed to fetch or initialize user:", error);
                updateTotalScoreUI("DB Err");
                updateReferralCountUI("DB Err");
                gameState = 'error';
                setInternalPause(true);
                alert("Database connection error. Please refresh or try again later.");
                return null;
            }
        }
        // ========================================================================
        // END: fetchAndInitializeUser function
        // ========================================================================

        async function processReferralOnLoad(currentUserId, currentUserTgData, initialUserData) {
             if (hasProcessedReferral || !supabase || !currentUserId) return;

             if (initialUserData?.referred_by) {
                 console.log(`User ${currentUserId} already referred by ${initialUserData.referred_by}. Skipping.`);
                 hasProcessedReferral = true;
                 return;
             }

             const startParam = window.Telegram?.WebApp?.initDataUnsafe?.start_param;
             if (!startParam) {
                 console.log("No start_param found for referral.");
                 hasProcessedReferral = true;
                 return;
             }

             const referrerId = parseInt(startParam, 10);
             if (!referrerId || isNaN(referrerId) || referrerId === currentUserId) {
                 console.warn(`Invalid or self-referral attempt: start_param=${startParam}, currentId=${currentUserId}`);
                 hasProcessedReferral = true;
                 return;
             }

             console.log(`Referral detected: Referrer ${referrerId}, Current ${currentUserId}. Attempting to process...`);
             hasProcessedReferral = true; // Assume processing attempt, prevents re-entry

             try {
                 const { data, error } = await supabase.rpc('process_referral', {
                     p_referrer_id: referrerId,
                     p_referred_id: currentUserId,
                     p_referred_username: currentUserTgData?.username || null,
                     p_referred_first_name: currentUserTgData?.first_name || 'User'
                 });

                 if (error) {
                     console.error('Error calling process_referral RPC:', error);
                     return;
                 }

                 if (data === true) {
                     console.log(`Referral successfully processed: ${currentUserId} referred by ${referrerId}`);
                     // Optional: Refresh UI/data if needed immediately
                 } else {
                     console.log(`Referral not processed (RPC returned false): User ${currentUserId} might already be referred or self-referral attempt.`);
                 }

             } catch (e) {
                 console.error('Exception calling process_referral RPC:', e);
             }
         }

        async function updateUserTotalScore(scoreToAdd) {
             if (!supabase || !telegramUserId || typeof scoreToAdd !== 'number' || isNaN(scoreToAdd) || scoreToAdd <= 0) {
                 console.warn("Invalid score update request:", { supabase: !!supabase, telegramUserId, scoreToAdd });
                 return Promise.reject("Invalid score input or missing context");
             }

             console.log(`Calling RPC increment_total_score for user ${telegramUserId} with score ${scoreToAdd}`);
             const { error } = await supabase.rpc('increment_total_score', {
                 user_id: telegramUserId,
                 score_to_add: Math.floor(scoreToAdd) // Ensure it's an integer
             });

             if (error) {
                 console.error("Error updating total score via RPC:", error);
                 return Promise.reject(error);
             } else {
                 console.log(`Score update RPC successful for ${telegramUserId}.`);
                 try {
                    currentUserTotalScore += BigInt(Math.floor(scoreToAdd));
                    updateTotalScoreUI(currentUserTotalScore); // Update UI from new cache
                 } catch (bigIntError) {
                    console.error("Error updating local score cache:", bigIntError);
                 }
                 return Promise.resolve();
             }
         }


        // --- Theme Handling ---
        function applyTheme(theme) { const isLight = theme === 'light'; document.body.classList.toggle('light-mode', isLight); themeToggleCheckbox.checked = isLight; localStorage.setItem('theme', theme); updateMaterialsTheme(); try { if (window.Telegram?.WebApp) { const hc = getCssVariable('--bg-header-bar'); window.Telegram.WebApp.setHeaderColor(hc); } } catch (e) { console.warn("TG theme color set fail:", e); } console.log(`Theme: ${theme}`); }
        function updateMaterialsTheme() { const isLight = document.body.classList.contains('light-mode'); if (ball?.material) { const bc = parseColorHex(getCssVariable('--ball-color')); ball.material.color.setHex(bc); } const pc = parseColorHex(getCssVariable('--pole-color')); for (const y in activePoleSegments) { const s = activePoleSegments[y]; if (s?.material) { s.material.color.setHex(pc); } } const dCol = parseColorHex(getCssVariable('--danger-color')); const dEm = parseColorHex(getCssVariable('--danger-glow')); activePlatforms.forEach(p => { if (p?.userData?.segmentAngles) { p.userData.segmentAngles.forEach(sd => { if (sd.isDanger && sd.material) { sd.material.color.setHex(dCol); sd.material.emissive.setHex(dEm); } else if (!sd.isDanger && sd.material && p.userData.colorHex) { sd.material.color.setHex(p.userData.colorHex); } }); } }); if (scene) { if (isLight) { scene.background = null; if (starField) starField.visible = false; } else { scene.background = null; if (starField) { starField.visible = true; const sc = parseColorHex(getCssVariable('--star-color')); starField.material.color.setHex(sc); starField.material.needsUpdate = true; } else { createStarfield(); } } } }
        function setupTheme() { let initTheme = 'dark'; try { initTheme = window.Telegram?.WebApp?.colorScheme || localStorage.getItem('theme') || 'dark'; console.log(`Init theme from TG/LS: ${initTheme}`); } catch (e) { console.warn("Theme fetch err:", e); initTheme = localStorage.getItem('theme') || 'dark'; } applyTheme(initTheme); themeToggleCheckbox.addEventListener('change', () => applyTheme(themeToggleCheckbox.checked ? 'light' : 'dark')); try { window.Telegram?.WebApp?.onEvent('themeChanged', () => { console.log('TG theme changed event'); applyTheme(window.Telegram.WebApp.colorScheme); }); } catch(e) { console.warn("TG theme listener err:", e); } }

        // --- UI Control Functions ---
        function toggleSideMenu() { const open=sideMenu.classList.toggle('open'); menuOverlayDimmer.classList.toggle('visible', open); if(open){ closeSettingsPopup(); pauseGameForUI(); } else { resumeGameFromUI(); }}
        function closeSideMenu() { if(sideMenu.classList.contains('open')){ sideMenu.classList.remove('open'); menuOverlayDimmer.classList.remove('visible'); resumeGameFromUI(); }}
        function toggleSettingsPopup() { const vis=settingsPopup.style.display==='block'; if(vis){ closeSettingsPopup(); } else { openSettingsPopup(); }}
        function openSettingsPopup() { closeSideMenu(); settingsPopup.style.display = 'block'; pauseGameForUI(); }
        function closeSettingsPopup() { if(settingsPopup.style.display === 'block'){ settingsPopup.style.display = 'none'; resumeGameFromUI(); }}

        function showOverlay(el) {
             if (!el) return;
             closeSideMenu();
             closeSettingsPopup();
             closeAllOverlays(el); // Close others first
             hideInitialControls(); // Hide centered controls when showing any overlay

             el.style.display = 'block'; // Use block for modals
             if (el.classList.contains('fullscreen-overlay')) {
                 el.style.display = 'flex'; // Keep flex for fullscreen overlays
             }
             pauseGameForUI();

             // Update overlay content based on which one is shown
             if (el === profileOverlay) {
                 updateTotalScoreUI(currentUserTotalScore); // Update from cached value
             } else if (el === friendsOverlay) {
                 updateReferralCountUI(currentUserReferralCount); // Update count from cache
                 updateReferralLinkUI(telegramUserId);
                 populateReferralListUI(); // Fetch and populate list when overlay opens
             }
             // Add similar logic for withdrawal overlay if needed
         }
        function hideOverlay(el) {
            if(!el || el.style.display === 'none') return;
            el.style.display = 'none';
            // Resume game logic only if no other UI element is open
            resumeGameFromUI();
         }

        function closeAllOverlays(exclude=null) {
             [profileOverlay, withdrawalOverlay, friendsOverlay, tasksOverlay, startGameModal, gameOverUI].forEach(o => {
                 if (o && o !== exclude && o.style.display !== 'none') {
                     o.style.display = 'none'; // Just hide, don't call hideOverlay which has resume logic
                 }
             });
             // After potentially closing everything, check if we should return to 'ready' state display
             if (gameState === 'ready' && !isAnyUIOverlayOpen()) {
                 showInitialControls();
             }
         }

        // --- Game Object Creation ---
        function createStarfield() { if(starField)scene.remove(starField); const c=7000; const p=new Float32Array(c*3); const g=new THREE.BufferGeometry(); const h=parseColorHex(getCssVariable('--star-color')); for(let i=0;i<c;i++){ const i3=i*3; const r=60+Math.random()*60; const ph=Math.acos(-1+(2*Math.random())); const th=Math.random()*Math.PI*2; p[i3]=r*Math.sin(ph)*Math.cos(th); p[i3+1]=r*Math.cos(ph); p[i3+2]=r*Math.sin(ph)*Math.sin(th); } g.setAttribute('position',new THREE.BufferAttribute(p,3)); const m=new THREE.PointsMaterial({size:0.1,color:h,sizeAttenuation:true,transparent:true,opacity:0.8,depthWrite:false,blending:THREE.AdditiveBlending}); starField=new THREE.Points(g,m); starField.userData.isStarfield=true; starField.renderOrder=-1; starField.visible=!document.body.classList.contains('light-mode'); scene.add(starField); }
        function createBall() { if(ball)scene.remove(ball); const g=new THREE.SphereGeometry(0.25,32,32); const h=parseColorHex(getCssVariable('--ball-color')); const m=new THREE.MeshStandardMaterial({color:h,map:ballTexture,metalness:0.8,roughness:0.3,envMap:envMap,envMapIntensity:0.7}); ball=new THREE.Mesh(g,m); ball.userData.isBall=true; ball.position.set(ballStartX,initialBallY,ballStartZ); ballPreviousY=ball.position.y; scene.add(ball); }
        function createPoleSegment(y) { const h=platformSpacingY; const g=new THREE.CylinderGeometry(poleRadius,poleRadius,h,16); const c=parseColorHex(getCssVariable('--pole-color')); const m=new THREE.MeshStandardMaterial({color:c,roughness:0.6,metalness:0.2,transparent:true,opacity:1.0}); const s=new THREE.Mesh(g,m); s.position.y=y; s.userData={y:y,isPoleSegment:true,fadeOut:false,fadeProgress:0,material:m}; poleGroup.add(s); activePoleSegments[y]=s; }

        // --- MODIFIED Platform Creation with Difficulty ---
        function createPlatform(y) {
            const p = new THREE.Group();
            p.position.y = y;
            p.rotation.y = Math.random() * Math.PI * 2;
            const circ = 2 * Math.PI;
            if(platformSegments <= 0) return;

            const segAng = (circ - gapSize) / platformSegments;
            const gapSt = Math.random() * circ;
            const gapEnd = (gapSt + gapSize) % circ;

            // --- Difficulty Logic ---
            let dangerProbability = 0.25; // Default (Easy)
            switch (selectedDifficulty) {
                case 'medium':
                    dangerProbability = 0.55; // Increased chance for Medium
                    break;
                case 'hard':
                    dangerProbability = 0.9; // High chance for Hard
                    break;
                case 'easy':
                default:
                    dangerProbability = 0.25; // Explicitly Easy
                    break;
            }
            const hasD = Math.random() < dangerProbability;
            // --- End Difficulty Logic ---

            const dIdx = hasD ? Math.floor(Math.random() * platformSegments) : -1;
            const sCol = platformColorPalette[platformColorIndex % platformColorPalette.length];
            platformColorIndex++;
            p.userData={y:y,isSafe:!hasD,segmentAngles:[],isPlatformGroup:true,gapStartAngle:gapSt,gapEndAngle:gapEnd,gapSize:gapSize,fadeOut:false,fadeProgress:0,colorHex:sCol};

            const iR=poleRadius+0.05; const oR=platformRadius; let currAng=gapEnd;
            const dColH=parseColorHex(getCssVariable('--danger-color'));
            const dEmH=parseColorHex(getCssVariable('--danger-glow'));

            for(let i=0;i<platformSegments;i++){
                const isD=(i===dIdx);
                const matOpts={roughness:isD?0.5:0.7,metalness:0.1,side:THREE.DoubleSide,transparent:true,opacity:1.0};
                if(isD){matOpts.color=new THREE.Color(dColH);matOpts.emissive=new THREE.Color(dEmH);matOpts.emissiveIntensity=0.7;}
                else{matOpts.color=new THREE.Color(sCol);}
                const segMat=new THREE.MeshStandardMaterial(matOpts);
                const segGeo=new THREE.RingGeometry(iR,oR,32,1,0,segAng); segGeo.rotateX(-Math.PI/2);
                const segMesh=new THREE.Mesh(segGeo,segMat);
                segMesh.rotation.y=currAng;
                const sSt=currAng%circ;
                const sEnd=(currAng+segAng)%circ;
                const segDat={type:'platform_segment',isDanger:isD,parentPlatform:p,index:i,startAngle:sSt,endAngle:sEnd,mesh:segMesh,material:segMat};
                p.userData.segmentAngles.push(segDat);
                segMesh.userData=segDat;
                p.add(segMesh);
                currAng=(currAng+segAng)%circ;
            }
            platformGroup.add(p);
            activePlatforms.push(p);
        }


        // --- Telegram Integration ---
        async function initializeTelegramIntegration() {
             hasProcessedReferral = false;
             if (!window.Telegram?.WebApp) {
                 console.error("Telegram WebApp object not found! Game cannot function.");
                 // REMOVED Mock Check
                 alert("Initialization Error: Critical Telegram object missing.");
                 gameState = 'error'; setInternalPause(true);
                 return Promise.reject("Telegram Env Missing");
             }
             const tg = window.Telegram.WebApp;

             return new Promise(async (resolve, reject) => {
                 tg.ready(); console.log("TG Ready. Data:", tg.initDataUnsafe); tg.expand();

                 if (tg.initDataUnsafe?.user?.id) {
                     telegramUserData = tg.initDataUnsafe.user;
                     telegramUserId = telegramUserData.id; // Store as number
                     console.log("TG User:", telegramUserId, telegramUserData);

                     // Update profile overlay immediately
                     if(userIdOverlay) userIdOverlay.textContent = telegramUserId.toString(); // Convert ID to string for display
                     if(usernameOverlay) usernameOverlay.textContent = telegramUserData?.username ? `@${telegramUserData.username}` : '(Not Set)';

                     // Initialize Supabase
                     if (!initializeSupabaseClient()) {
                         reject("Supabase Init Failed");
                         return;
                     }

                     // Fetch/Create user in Supabase and get initial data
                     const initialUserData = await fetchAndInitializeUser(telegramUserId, telegramUserData);

                     if (initialUserData !== null) { // Check if fetch/init was successful
                         await processReferralOnLoad(telegramUserId, telegramUserData, initialUserData);

                         gameState = 'ready';
                         setInternalPause(false);
                         showInitialControls();
                         updateScoreUI();
                         updateReferralLinkUI(telegramUserId); // Generate referral link
                         setTimeout(() => { onWindowResize(); resolve(); }, 100);
                     } else {
                         reject("User Fetch/Init Failed");
                     }

                 } else {
                     console.error("TG user ID missing!");
                     gameState='error'; setInternalPause(true);
                     alert("User information error. Cannot initialize.");
                     reject("TG User Missing");
                 }
             });
         }

        // --- Core Game Initialization ---
        async function init() {
            console.log("Initializing App..."); gameState = 'initializing'; setInternalPause(true);
            scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 150); camera.position.z = cameraFixedZ; renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true, alpha: true }); renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0; renderer.outputEncoding = THREE.sRGBEncoding; renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); renderer.setClearColor(0x000000, 0);
            setupTheme();
            composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera)); bloomPass = new UnrealBloomPass(new THREE.Vector2(gameContainer.clientWidth, gameContainer.clientHeight), 0.6, 0.5, 0.8); composer.addPass(bloomPass);
            scene.add(new THREE.HemisphereLight(0xccccff, 0x555599, 0.7)); const dirLight = new THREE.DirectionalLight(0xffffff, 0.9); dirLight.position.set(5, 8, 6); scene.add(dirLight); scene.add(new THREE.AmbientLight(0x404040, 0.6));
            new RGBELoader().load('back.hdr', (t) => { t.mapping = THREE.EquirectangularReflectionMapping; scene.environment = t; envMap = t; if (ball?.material) ball.material.needsUpdate = true; }, undefined, e => console.warn("HDR load fail", e));
            textureLoader.load('ball.jpg', (t) => { t.wrapS = t.wrapT = THREE.RepeatWrapping; ballTexture = t; if (ball?.material) { ball.material.map = t; ball.material.needsUpdate = true; } }, undefined, e => console.warn("Ball tex fail.", e));
            createBall();
            platformGroup = new THREE.Group(); scene.add(platformGroup); poleGroup = new THREE.Group(); scene.add(poleGroup);
            window.addEventListener('resize', onWindowResize, false); document.addEventListener('pointerdown', onPointerDown, { passive: false }); document.addEventListener('pointermove', onPointerMove, { passive: false }); document.addEventListener('pointerup', onPointerUp, false); document.addEventListener('pointerleave', onPointerUp, false);
            setupUIListeners();
            try { await initializeTelegramIntegration(); console.log("TG/Supabase Init OK."); } catch (e) { console.error("Initialization failed:", e); gameState = 'error'; setInternalPause(true); /* Error already shown */ return; }
            onWindowResize(); animate(); console.log("Init complete. Ready for user to start.");
        }

        // --- UI Listeners Setup ---
         function setupUIListeners() {
             menuButton.addEventListener('click', (e) => { e.stopPropagation(); toggleSideMenu(); });
             settingsButton.addEventListener('click', (e) => { e.stopPropagation(); toggleSettingsPopup(); });
             menuItemButtons.forEach(b => { b.addEventListener('click', () => {
                 const action = b.getAttribute('data-action');
                 closeSideMenu();
                 switch (action) {
                     case 'show-profile': showOverlay(profileOverlay); break;
                     case 'show-withdrawal': showOverlay(withdrawalOverlay); break;
                     case 'show-friends': showOverlay(friendsOverlay); break; // Fetch referrals done in showOverlay
                     case 'show-tasks': showOverlay(tasksOverlay); break;
                 }
             }); });
             overlayCloseButtons.forEach(b => {
                 b.addEventListener('click', () => {
                     const id = b.getAttribute('data-overlay-id');
                     const o = document.getElementById(id);
                     if (o) {
                        hideOverlay(o);
                        // Special handling for game over close button to behave like Play Again
                        if (id === 'game-over-ui') {
                            handlePlayAgain();
                        }
                     }
                 });
             });
             document.addEventListener('click', (e) => { if (sideMenu.classList.contains('open') && !sideMenu.contains(e.target) && !menuButton.contains(e.target)) { closeSideMenu(); } if (settingsPopup.style.display === 'block' && !settingsPopup.contains(e.target) && !settingsButton.contains(e.target)) { closeSettingsPopup(); } });
             menuOverlayDimmer.addEventListener('click', closeSideMenu);
             settingsPopup.addEventListener('click', e => e.stopPropagation()); sideMenu.addEventListener('click', e => e.stopPropagation());

             // Prevent clicks inside overlays/modals from closing them (unless it's a close button)
             [profileOverlay, withdrawalOverlay, friendsOverlay, tasksOverlay, gameOverUI, startGameModal].forEach(overlay => {
                 if (overlay) {
                     overlay.addEventListener('click', e => {
                        if (e.target.closest('button') || e.target.closest('a') || e.target.closest('input') || e.target.closest('select') || e.target.closest('.theme-switch') || e.target.closest('#referral-list-container')) {
                            // Don't stop propagation if it's an interactive element
                        } else {
                           e.stopPropagation(); // Stop propagation for clicks on the overlay background itself
                        }
                     });
                 }
             });
             if (initialControlsContainer) initialControlsContainer.addEventListener('click', e => e.stopPropagation());


             restartButton.addEventListener('click', handlePlayAgain);
             if (watchAdButton) watchAdButton.addEventListener('click', handleWatchAdForSave);

             // --- Listeners for DIFFICULTY buttons ---
             difficultyButtons.forEach(button => {
                 button.addEventListener('click', () => {
                     if (isTimedGameActive || gameState === 'playing') return; // Don't allow change during game
                     const difficulty = button.getAttribute('data-difficulty');
                     handleDifficultySelection(difficulty);
                 });
             });

             startGameButton.addEventListener('click', () => {
                 if (gameState === 'ready') {
                     startNormalButton.disabled = false;
                     startBoostButton.disabled = false;
                     startBoostButton.textContent = '2x Points';
                     showOverlay(startGameModal);
                 }
             });

             // Listeners for buttons inside #start-game-modal
             startNormalButton.addEventListener('click', () => {
                 hideOverlay(startGameModal);
                 startGame(1); // Start game with 1x multiplier (difficulty already selected)
             });
             startBoostButton.addEventListener('click', handleWatchAdForBoost);

             if (copyReferralLinkButton) { copyReferralLinkButton.addEventListener('click', async () => { const link = referralLinkDisplay.textContent; if (link && link !== "Generating link..." && link !== "Link Unavailable") { const success = await copyToClipboard(link); copyReferralLinkButton.textContent = success ? "Copied!" : "Failed"; } else { copyReferralLinkButton.textContent = "Error"; } setTimeout(() => { copyReferralLinkButton.textContent = "Copy"; }, 1500); }); }

             // Withdrawal button listener (optional, as it's disabled)
             // if (withdrawMainButton) { ... }
         }

        // --- Difficulty and Game Start/End Functions ---
        function handleDifficultySelection(difficulty) {
            selectedDifficulty = difficulty;
            difficultyButtons.forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-difficulty') === difficulty);
            });
            console.log("Selected difficulty:", selectedDifficulty);
        }

        function showInitialControls() {
            if (initialControlsContainer) initialControlsContainer.classList.remove('hidden');
            if (headerTimerDisplayEl) headerTimerDisplayEl.classList.remove('visible');
            if (startGameButton) startGameButton.disabled = false;
            updateScoreUI(); // Reset current game score display
        }

        function hideInitialControls() {
             if (initialControlsContainer) initialControlsContainer.classList.add('hidden');
        }

        function hideInitialControlsAndShowTimer() {
            hideInitialControls();
            if (headerTimerDisplayEl) headerTimerDisplayEl.classList.add('visible');
        }


        function updateHeaderTimerDisplay() {
            if (headerTimerDisplayEl) {
                headerTimerDisplayEl.textContent = formatTime(currentGameCountdown);
            }
        }

        function updateGameTimer() {
            if (internalPauseState) return; // Don't countdown if paused

            if (currentGameCountdown > 0 && isTimedGameActive && gameState === 'playing') {
                currentGameCountdown--;
                updateHeaderTimerDisplay();
            }

            if (currentGameCountdown <= 0 && isTimedGameActive && gameState === 'playing') {
                console.log("Timer ended!");
                handleGameOver("Time's Up!");
            }
        }

        async function startGame(multiplier) {
             console.log(`Starting game with difficulty ${selectedDifficulty}, duration ${GAME_DURATION_SECONDS}s and multiplier ${multiplier}x`);
             if (gameState !== 'ready') {
                 console.warn("Cannot start game, not in ready state.");
                 return;
             }

             scoreMultiplier = multiplier;
             currentGameCountdown = GAME_DURATION_SECONDS; // Use constant duration
             isTimedGameActive = true;

             hideInitialControlsAndShowTimer();
             updateHeaderTimerDisplay();

             await prepareGameForStart(); // Reset board etc.

             gameState = 'playing';
             setInternalPause(false); // Ensure not paused

             if (gameTimerIntervalId) clearInterval(gameTimerIntervalId);
             gameTimerIntervalId = setInterval(updateGameTimer, 1000);

             clock.getDelta(); // Reset clock delta

             animateCameraZoom(cameraZoomedInZ, cameraZoomDuration);
             console.log("Game started!");
         }

        async function prepareGameForStart() {
             console.log("Preparing game board for difficulty:", selectedDifficulty);
             if (adTimerIntervalId) { clearInterval(adTimerIntervalId); adTimerIntervalId = null; }
             if (gameTimerIntervalId) { clearInterval(gameTimerIntervalId); gameTimerIntervalId = null; }

             if (gameState === 'error') {
                 console.error("Prepare skip: Game in error state.");
                 return Promise.reject("Game Error State");
             }

             console.log("Resetting game state for start...");
             if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId); cameraZoomRequestId = null; isCameraZooming = false;

             if (!ball) createBall(); else { const ballColorHex = parseColorHex(getCssVariable('--ball-color')); ball.material.color.setHex(ballColorHex); }
             ball.position.set(ballStartX, initialBallY, ballStartZ);
             ballPreviousY = ball.position.y;
             currentBallVelocityY = 0;

             // --- Platform and Pole Cleanup ---
             activePlatforms.forEach(p => disposePlatformSegments(p));
             activePlatforms = [];
             if (platformGroup) {
                 while(platformGroup.children.length > 0) {
                     disposePlatformSegments(platformGroup.children[0]);
                 }
                 platformGroup.rotation.y = 0;
             } else { platformGroup = new THREE.Group(); scene.add(platformGroup); }
             Object.keys(activePoleSegments).forEach(y => disposePoleSegment(parseFloat(y)));
             activePoleSegments = {};
             if (poleGroup) {
                 while(poleGroup.children.length > 0) {
                      const child = poleGroup.children[0];
                      poleGroup.remove(child);
                      if(child.geometry) child.geometry.dispose();
                      if(child.material) child.material.dispose();
                 }
             } else { poleGroup = new THREE.Group(); scene.add(poleGroup); }
             // --- End Cleanup ---

             currentScore = 0; updateScoreUI(); // Reset current game score
             scoreIncrementedForPlatform = {};
             platformColorIndex = 0;
             shakeIntensity = 0;
             nextPlatformY = initialBallY - platformSpacingY * 2; // Start platforms below initial ball pos
             lastSafePlatformY = nextPlatformY + platformSpacingY; // Set initial safe Y

             // Generate initial platforms (using the selected difficulty)
             for (let i = 0; i < 15; i++) {
                 createPlatform(nextPlatformY);
                 createPoleSegment(nextPlatformY);
                 nextPlatformY -= platformSpacingY;
             }

             hideOverlay(gameOverUI);
             hideOverlay(startGameModal);

             // Reset Camera Position (Instantaneous)
             if (camera && ball) {
                 const camY = ball.position.y + cameraVerticalOffset;
                 const lookY = ball.position.y + cameraLookAtOffset;
                 camera.position.set(0, camY, cameraFixedZ); // Reset zoom immediately
                 camera.lookAt(0, lookY, 0);
             }

             console.log("Game board prepared.");
             setTimeout(onWindowResize, 50); // Ensure resize adjustments happen
             return Promise.resolve();
        }

        function handlePlayAgain() {
             console.log("Play Again clicked.");
             hideOverlay(gameOverUI);
             gameState = 'ready';
             setInternalPause(false);
             isTimedGameActive = false;
             scoreMultiplier = 1;
             currentGameCountdown = 0;
             showInitialControls(); // Show the start screen again
        }


        // --- Game Logic Functions ---
        function generatePlatforms() { if (!ball || !camera || internalPauseState || gameState !== 'playing' || !isTimedGameActive) return; const generationTriggerY = nextPlatformY + platformSpacingY * 8; while (ball.position.y < generationTriggerY && nextPlatformY > -1000) { createPlatform(nextPlatformY); createPoleSegment(nextPlatformY); nextPlatformY -= platformSpacingY; } const removalThresholdY_Above = camera.position.y + 15; activePlatforms.forEach(p => { if (p.position.y > removalThresholdY_Above && !p.userData.fadeOut) startFadeOut(p); }); for (const yPos in activePoleSegments) { const seg = activePoleSegments[yPos]; if (parseFloat(yPos) > removalThresholdY_Above && seg && !seg.userData.fadeOut) startFadeOut(seg); } }
        function updateBallPosition() { if (!ball || internalPauseState || gameState !== 'playing' || !isTimedGameActive) return; currentBallVelocityY += gravity; ball.position.y += currentBallVelocityY; ball.position.x = ballStartX; ball.position.z = ballStartZ; if (ball.position.y < nextPlatformY - platformSpacingY * 5) { handleGameOver("Fell Off!"); } }
        function disposePlatformSegments(platform) { if (!platform) return; platform.traverse(object => { if (object.isMesh) { if (object.geometry) object.geometry.dispose(); if (object.material) { ['map', 'emissiveMap', 'aoMap', 'metalnessMap', 'roughnessMap', 'normalMap', 'displacementMap', 'alphaMap', 'envMap'].forEach(prop => { if (object.material[prop]?.dispose) object.material[prop].dispose(); }); if (Array.isArray(object.material)) { object.material.forEach(m => m.dispose()); } else { object.material.dispose(); } } } } }); if (platform.parent) platform.parent.remove(platform); }
        function disposePoleSegment(yPos) { const segment = activePoleSegments[yPos]; if (segment) { if (segment.geometry) segment.geometry.dispose(); if (segment.material) segment.material.dispose(); if (segment.parent) segment.parent.remove(segment); delete activePoleSegments[yPos]; return true; } return false; }
        function startFadeOut(object) { if (!object || !object.userData || object.userData.fadeOut) return; object.userData.fadeOut = true; object.userData.fadeProgress = 0; }
        function destroyPlatformAndPole(platform) {
            if (!platform || !platform.userData || platform.userData.fadeOut) return;
            const platformY = platform.userData.y;
            if (!scoreIncrementedForPlatform[platformY]) {
                currentScore += (1 * scoreMultiplier); // Increment current game score
                updateScoreUI(); // Update display for current game score
                scoreIncrementedForPlatform[platformY] = true;
            }
            startFadeOut(platform);
            const poleSegment = activePoleSegments[platformY];
            if (poleSegment) startFadeOut(poleSegment);
        }
        function updateFadingObjects(deltaTime) {
             if (gameState !== 'playing' && gameState !== 'gameOver') return;
             const fadeSpeed = 1.0 / (FADE_DURATION / 1000);
             const platformsToRemoveIndexes = []; const poleYPositionsToRemove = [];
             for (let i = activePlatforms.length - 1; i >= 0; i--) {
                 const p = activePlatforms[i];
                 if (p.userData.fadeOut) {
                     p.userData.fadeProgress += fadeSpeed * deltaTime;
                     const progress = Math.min(p.userData.fadeProgress, 1);
                     const scale = 1.0 - progress * 0.5;
                     p.scale.set(scale, 1, scale);
                     p.traverse((child) => {
                         if (child.isMesh && child.material) {
                             child.material.opacity = 1.0 - progress;
                             child.material.transparent = true;
                             child.material.needsUpdate = true;
                         }
                     });
                     if (progress >= 1) platformsToRemoveIndexes.push(i);
                 }
             }
             for (let i = platformsToRemoveIndexes.length - 1; i >= 0; i--) {
                 const index = platformsToRemoveIndexes[i];
                 disposePlatformSegments(activePlatforms[index]);
                 activePlatforms.splice(index, 1);
             }
             for (const y in activePoleSegments) {
                 const segment = activePoleSegments[y];
                 if (segment?.userData.fadeOut) {
                     segment.userData.fadeProgress += fadeSpeed * deltaTime;
                     const progress = Math.min(segment.userData.fadeProgress, 1);
                     if (segment.material) {
                         segment.material.opacity = 1.0 - progress;
                         segment.material.transparent = true;
                         segment.material.needsUpdate = true;
                     }
                     const scale = 1.0 - progress;
                     segment.scale.set(scale, scale, scale);
                     if (progress >= 1) poleYPositionsToRemove.push(parseFloat(y));
                 }
             }
             poleYPositionsToRemove.forEach(y => disposePoleSegment(y));
        }
        function checkCollisions() { if (!ball || internalPauseState || gameState !== 'playing' || !isTimedGameActive || currentBallVelocityY >= 0) return; const ballRadius = 0.25; const ballBottomY = ball.position.y - ballRadius; let candidatePlatform = null; let highestCandidateY = -Infinity; for (let i = 0; i < activePlatforms.length; i++) { const platform = activePlatforms[i]; if (!platform || !platform.userData || platform.userData.fadeOut) continue; const platformSurfaceY = platform.position.y; if (ballPreviousY - ballRadius >= platformSurfaceY && ballBottomY <= platformSurfaceY) { if (platformSurfaceY > highestCandidateY) { highestCandidateY = platformSurfaceY; candidatePlatform = platform; } } } if (!candidatePlatform) return; const platformData = candidatePlatform.userData; const collisionY = platformData.y; const ballAngle = Math.atan2(ball.position.z - platformGroup.position.z, ball.position.x - platformGroup.position.x); const towerRotation = platformGroup.rotation.y; const platformInternalRotation = candidatePlatform.rotation.y; let angleRelativeToPlatform = THREE.MathUtils.euclideanModulo( ballAngle - towerRotation - platformInternalRotation, 2 * Math.PI ); const gapStart = platformData.gapStartAngle; const gapEnd = platformData.gapEndAngle; let isInGap; if (gapStart < gapEnd) { isInGap = angleRelativeToPlatform >= gapStart && angleRelativeToPlatform < gapEnd; } else { isInGap = angleRelativeToPlatform >= gapStart || angleRelativeToPlatform < gapEnd; } const ballDistFromCenter = Math.hypot(ball.position.x, ball.position.z); const isInsidePoleRadius = ballDistFromCenter < poleRadius; if (isInGap || isInsidePoleRadius) { destroyPlatformAndPole(candidatePlatform); } else { let hitSegmentData = null; for (const segmentData of platformData.segmentAngles) { let segStart = segmentData.startAngle; let segEnd = segmentData.endAngle; let angleFallsInSegment; if (segStart < segEnd) { angleFallsInSegment = angleRelativeToPlatform >= segStart && angleRelativeToPlatform < segEnd; } else { angleFallsInSegment = angleRelativeToPlatform >= segStart || angleRelativeToPlatform < segEnd; } if (angleFallsInSegment) { hitSegmentData = segmentData; break; } } if (hitSegmentData) { if (hitSegmentData.isDanger) { lastSafePlatformY = collisionY - platformSpacingY; handleGameOver("Hit Danger Zone!"); startShake(0.7); } else { lastSafePlatformY = collisionY; ball.position.y = collisionY + ballRadius + 0.01; currentBallVelocityY = bounceSpeed; Object.keys(scoreIncrementedForPlatform).forEach(keyY => { if (parseFloat(keyY) < collisionY) delete scoreIncrementedForPlatform[keyY]; }); startShake(0.3); } } else { console.warn("Collision: Not in gap, but no segment hit?", { ballAngle, towerRotation, platformInternalRotation, angleRelativeToPlatform}); destroyPlatformAndPole(candidatePlatform); } } }

        async function handleGameOver(reason = "Unknown Reason") { // Make async for score update
             if (gameState !== 'playing') return;

             console.log(`Game Over! Reason: ${reason}. Difficulty: ${selectedDifficulty}`);
             gameState = 'gameOver';
             setInternalPause(true);
             isTimedGameActive = false;

             if (gameTimerIntervalId) {
                 clearInterval(gameTimerIntervalId);
                 gameTimerIntervalId = null;
                 console.log("Game Timer stopped.");
             }

             if (headerTimerDisplayEl) headerTimerDisplayEl.classList.remove('visible'); // Hide timer

             // Display final score in the modal message
             gameOverMessageP.innerHTML = `${reason}<br>Score: <span id="final-score">${formatNumber(currentScore)}</span>`;

             showOverlay(gameOverUI); // Display the modal

             // Enable/disable buttons based on conditions
             if (restartButton) restartButton.disabled = false;
             if (watchAdButton) {
                 // Show "Watch Ad & Save" only if score > 0, user ID exists, and Ad SDK is loaded
                 if (telegramUserId && currentScore > 0 && typeof show_9292240 === 'function') {
                     watchAdButton.style.display = 'block'; // Use 'block' for flex items
                     watchAdButton.disabled = false;
                 } else {
                     watchAdButton.style.display = 'none';
                 }
             }

             // Save score immediately if NO "Watch Ad" option is available/applicable AND score > 0
             if (watchAdButton.style.display === 'none' && currentScore > 0 && telegramUserId) {
                 console.log("No Ad option or score is zero. Saving score directly.");
                 try {
                     await updateUserTotalScore(currentScore); // Await the score update
                     console.log("Score saved directly on game over.");
                 } catch (error) {
                     console.error("Direct score save failed on game over:", error);
                      gameOverMessageP.innerHTML += "<br><small>(Save Failed)</small>";
                 }
             } else if (currentScore <= 0) {
                 console.log("Game over with zero score, not saving.");
             }

             startShake(0.5); // Shake effect
         }


        function handleWatchAdForBoost() {
            if (gameState !== 'ready') return;

            if (typeof show_9292240 !== 'function') {
                console.error("Ad SDK function 'show_9292240' not found for Boost Ad.");
                alert("Ad service not available right now. Please try starting normally.");
                 startNormalButton.disabled = false;
                 startBoostButton.disabled = false;
                 startBoostButton.textContent = '2x Points'; // Reset button text
                return;
            }

            console.log("Watch Ad for Boost clicked (Using show_9292240).");
            startNormalButton.disabled = true;
            startBoostButton.disabled = true;
            startBoostButton.textContent = 'Loading Ad...';

            show_9292240().then(() => {
                 console.log("Ad watched successfully (Boost - show_9292240). Starting game with 2x.");
                 hideOverlay(startGameModal);
                 startGame(2); // Start game with 2x multiplier
            }).catch((error) => {
                 console.error("Ad failed to show or skipped (Boost - show_9292240):", error);
                 alert("Ad failed or was skipped. Starting game normally (1x points).");
                 startNormalButton.disabled = false; // Re-enable buttons
                 startBoostButton.disabled = false;
                 startBoostButton.textContent = '2x Points'; // Reset text
                 hideOverlay(startGameModal);
                 startGame(1); // Start normally
            });
        }


        function handleWatchAdForSave() {
            if (gameState !== 'gameOver' || !telegramUserId || currentScore <= 0) return;

             if (typeof show_9292240 !== 'function') {
                console.error("Ad SDK function 'show_9292240' not found for Game Over Save Ad.");
                alert("Ad service not ready. Score cannot be saved via Ad.");
                return;
            }

            console.log("Watch Ad & Save clicked (Using show_9292240).");
            if (restartButton) restartButton.disabled = true;
            if (watchAdButton) watchAdButton.disabled = true;
            const originalMessage = gameOverMessageP.innerHTML; // Store original message
            gameOverMessageP.textContent = `Loading Ad to Save Score...`; // Temporarily change message

            show_9292240().then(async () => { // Make the callback async
                 console.log("Ad watched successfully (Game Over Save - show_9292240). Saving score...");
                 try {
                     await updateUserTotalScore(currentScore); // Await the score update
                     console.log("Score save OK via Ad.");
                     gameOverMessageP.textContent = `Score Saved! Final: ${formatNumber(currentScore)}`; // Update message on success
                     if (restartButton) restartButton.disabled = false; // Re-enable play again
                     // Keep watch ad button hidden/disabled after successful use
                     if (watchAdButton) watchAdButton.style.display = 'none';
                 } catch (error) {
                     console.error("Failed score save after Ad:", error);
                     alert("Could not save score after watching the ad. Please try again.");
                     gameOverMessageP.innerHTML = originalMessage; // Restore original message on failure
                     if (restartButton) restartButton.disabled = false;
                     if (watchAdButton) watchAdButton.disabled = false; // Re-enable on failure
                 }
            }).catch((error) => {
                 console.error("Ad failed to show (Game Over Save - show_9292240):", error);
                 alert("Ad failed to load or was skipped. Score not saved.");
                 gameOverMessageP.innerHTML = originalMessage; // Restore original message
                 if (restartButton) restartButton.disabled = false;
                 if (watchAdButton) watchAdButton.disabled = false; // Re-enable watch ad button
            });
        }


        function startShake(intensity) { shakeIntensity = Math.max(shakeIntensity, intensity); }

        // --- Input Handling ---
        function onPointerDown(e){
             let target = e.target; let isUI = false;
              if (headerBar.contains(target) ||
                  (sideMenu.classList.contains('open') && sideMenu.contains(target)) ||
                  (menuOverlayDimmer.classList.contains('visible') && target === menuOverlayDimmer) ||
                  (settingsPopup.style.display === 'block' && settingsPopup.contains(target)) ||
                  (profileOverlay.style.display === 'flex' && profileOverlay.contains(target)) ||
                  (withdrawalOverlay.style.display === 'flex' && withdrawalOverlay.contains(target)) ||
                  (friendsOverlay.style.display === 'flex' && friendsOverlay.contains(target)) ||
                  (tasksOverlay.style.display === 'flex' && tasksOverlay.contains(target)) ||
                  (gameOverUI.style.display === 'block' && gameOverUI.contains(target)) ||
                  (startGameModal.style.display === 'block' && startGameModal.contains(target)) ||
                  (initialControlsContainer && !initialControlsContainer.classList.contains('hidden') && initialControlsContainer.contains(target)) ||
                  target.closest('.icon-button') ||
                  target.closest('button') || // Includes difficulty buttons
                  target.closest('a') ||
                  target.closest('input') ||
                  target.closest('select') ||
                  target.closest('.theme-switch') ||
                  target.closest('#referral-list-container')
             ) { isUI = true; }

             if (target === renderer?.domElement && gameState === 'playing' && isTimedGameActive && !internalPauseState) {
                 isUI = false; // Allow game input
             } else if (target === renderer?.domElement) {
                 isUI = true; // Block game input
             }

             if (isUI) {
                 isPointerDown = false;
             } else {
                 isPointerDown = true;
                 previousPointerX = e.clientX ?? e.touches?.[0]?.clientX;
                 if (previousPointerX === undefined) { isPointerDown = false; return; }
                 document.body.style.cursor = 'grabbing';
                 if (e.cancelable && e.touches && gameContainer.contains(target)) {
                     e.preventDefault();
                 }
             }
         }
        function onPointerMove(e){
             if (!isPointerDown || gameState !== 'playing' || !isTimedGameActive || internalPauseState) return;
             const currentX = e.clientX ?? e.touches?.[0]?.clientX; if (currentX === undefined) return; const deltaX = currentX - previousPointerX; if (platformGroup) { platformGroup.rotation.y += deltaX * rotationSensitivity; } previousPointerX = currentX;
             if (e.cancelable && e.touches) { e.preventDefault(); }
        }
        function onPointerUp(e){ if (isPointerDown) { isPointerDown = false; document.body.style.cursor = 'default'; }
        }

        // --- Window Resize ---
        function onWindowResize() {
            if (!camera || !renderer || !gameContainer || !composer) return;
            const w = window.innerWidth;
            const h = window.innerHeight;

            if (w > 0 && h > 0) {
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
                composer.setSize(w, h);
            } else {
                 console.warn("Window resize called with zero dimensions.");
            }
        }


        // --- Camera Zoom ---
        function animateCameraZoom(targetZ, duration) { if (!camera || isCameraZooming) return; if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId); isCameraZooming = true; const startZ = camera.position.z; const startTime = performance.now(); function step(now) { const elapsed = now - startTime; const prog = Math.min(elapsed / duration, 1); const ease = t => t * (2 - t); // Ease out quad
             const newZ = startZ + (targetZ - startZ) * ease(prog); camera.position.z = newZ; if (prog < 1) { cameraZoomRequestId = requestAnimationFrame(step); } else { camera.position.z = targetZ; isCameraZooming = false; cameraZoomRequestId = null; } } cameraZoomRequestId = requestAnimationFrame(step); }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate); // Loop
            const dt = clock.getDelta(); // Time since last frame

             if (starField && starField.visible) starField.rotation.y += dt * 0.01;

             if (gameState === 'playing' && isTimedGameActive && !internalPauseState) {
                 updateBallPosition();
                 checkCollisions();
                 generatePlatforms();
                 if (ball) { ballPreviousY = ball.position.y; }
             }

             if (gameState === 'playing' || gameState === 'gameOver') {
                 updateFadingObjects(dt);
             }

             let camY = camera ? camera.position.y : (initialBallY + cameraVerticalOffset);
             let lookY = ball ? (ball.position.y + cameraLookAtOffset) : (initialBallY + cameraLookAtOffset);

             if (ball && camera && (gameState === 'playing' || gameState === 'gameOver')) {
                 const targetCamY = ball.position.y + cameraVerticalOffset;
                 const lerpedY = THREE.MathUtils.lerp(camera.position.y, targetCamY, cameraFollowLerpFactor * dt * 60);
                 if (lerpedY < camera.position.y || (currentBallVelocityY > 0.05 && gameState === 'playing' && !internalPauseState) ) {
                     camY = lerpedY;
                 }
                  else if (ball.position.y < camera.position.y - cameraVerticalOffset - 2) {
                      camY = targetCamY;
                 }
                 lookY = ball.position.y + cameraLookAtOffset;
             } else if (camera && gameState === 'ready') {
                 camY = initialBallY + cameraVerticalOffset;
                 lookY = initialBallY + cameraLookAtOffset;
                 camera.position.y = camY;
                 camera.lookAt(0, lookY, 0);
             }

             let shakeX = 0, shakeY = 0;
             if (shakeIntensity > 0.01) {
                 shakeX = (Math.random() - 0.5) * 2 * maxShakeOffset * shakeIntensity;
                 shakeY = (Math.random() - 0.5) * 2 * maxShakeOffset * shakeIntensity;
                 if (gameState === 'playing' && isTimedGameActive && !internalPauseState) {
                     shakeIntensity *= Math.pow(shakeDecreaseFactor, dt * 60);
                 } else if (gameState !== 'playing') {
                     shakeIntensity *= Math.pow(shakeDecreaseFactor * 0.8, dt * 60);
                 }
             } else {
                 shakeIntensity = 0;
             }

             if (camera && gameState !== 'ready') {
                 camera.position.y = camY + shakeY;
                 camera.position.x = 0 + shakeX;
                 camera.lookAt(0 + shakeX, lookY + shakeY, 0);
             } else if (camera && gameState === 'ready') {
                 camera.position.set(0, initialBallY + cameraVerticalOffset, camera.position.z);
                 camera.lookAt(0, initialBallY + cameraLookAtOffset, 0);
             }

            if (composer) { composer.render(dt); }
            else if (renderer && scene && camera) { renderer.render(scene, camera); }
        }

        // --- Start ---
        document.addEventListener('DOMContentLoaded', init);

        // Clean up Supabase subscriptions on unload
        window.addEventListener('beforeunload', () => {
             if (userRealtimeChannel) {
                 supabase.removeChannel(userRealtimeChannel)
                     .then(() => console.log("Removed user channel on unload."))
                     .catch(e => console.warn("Error removing channel on unload:", e));
             }
         });

    </script>

</body>
</html>
