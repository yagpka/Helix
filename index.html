
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Helix Point Drop - Telegram Mini App</title> {/* Changed Title for Production */}
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <!-- UNCOMMENTED: Real Telegram Web App Script -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* --- Theming Variables --- */
        :root {
            /* --- Dark Mode (Default / Night) --- */
            --bg-gradient-start: #0a0a1a;
            --bg-gradient-end: #111122;
            --bg-header-bar: rgba(10, 10, 25, 0.85);
            --bg-ui-panel: rgba(15, 15, 35, 0.9);
            --bg-overlay: rgba(11, 11, 34, 0.98);
            --bg-menu: rgba(20, 20, 45, 0.97);
            --bg-modal: rgba(15, 15, 35, 0.95);
            --bg-input: rgba(255, 255, 255, 0.08);
            --bg-button-info: #00cfde;
            --bg-button-info-hover: #00b3bf;
            --bg-button-action: #ff4081;
            --bg-button-action-hover: #d81b60;
            --bg-button-special: #f5d131;
            --bg-button-special-hover: #dbc02b;
            --bg-button-watch-ad: #4CAF50; /* Green for watch ad */
            --bg-button-watch-ad-hover: #45a049;
            --bg-button-x: #000000;
            --bg-button-x-hover: #333333;
            --bg-toggle-track: #555;
            --bg-toggle-track-active: var(--accent-cyan);
            --bg-link-button: rgba(255, 255, 255, 0.05);
            --bg-link-button-hover: rgba(255, 255, 255, 0.1);
            --bg-copy-button: rgba(255, 255, 255, 0.1);
            --bg-copy-button-hover: rgba(255, 255, 255, 0.2);
            --bg-reward-task-icon: rgba(255, 255, 255, 0.08);
            --bg-reward-task-arrow: rgba(255, 255, 255, 0.1);
            --bg-reward-task-arrow-hover: rgba(255, 255, 255, 0.18);


            --text-light: #ffffff;
            --text-medium: #cccccc;
            --text-dark: #111122; /* Text on buttons */
            --text-link: var(--accent-cyan);
            --text-link-hover: var(--accent-cyan-hover);
            --text-heading-accent: var(--accent-yellow);
            --text-error: var(--accent-pink);
            --text-placeholder: rgba(255, 255, 255, 0.4);
            --text-copy-button: var(--text-medium);
            --text-copy-button-hover: var(--text-light);
            --text-reward-task-primary: var(--text-light);
            --text-reward-task-secondary: var(--text-medium);
            --text-reward-task-points: var(--accent-yellow);
            --icon-reward-task: var(--text-light);
            --icon-reward-task-arrow: var(--text-light);

            --border-color: rgba(255, 255, 255, 0.15);
            --border-input: rgba(255, 255, 255, 0.15);
            --border-menu-item: rgba(255, 255, 255, 0.1);
            --border-link-button: rgba(255, 255, 255, 0.1);
            --border-copy-button: rgba(255, 255, 255, 0.2);
            --border-reward-task: rgba(255, 255, 255, 0.1);


            --shadow-color: rgba(0, 0, 0, 0.4);
            --shadow-header-bar: 0 3px 12px var(--shadow-color);
            --shadow-panel: 0 6px 20px var(--shadow-color);
            --shadow-modal: 0 8px 25px var(--shadow-color);
            --shadow-button: 0 2px 5px rgba(0, 0, 0, 0.2);
            --shadow-button-hover: 0 4px 8px rgba(0, 0, 0, 0.25);

            --backdrop-blur: 4px;
            --backdrop-blur-heavy: 6px;

            /* Accents & Game Colors */
            --accent-cyan: #00cfde;
            --accent-cyan-hover: #00b3bf;
            --accent-pink: #ff4081;
            --accent-pink-hover: #d81b60;
            --accent-yellow: #f5d131;
            --accent-yellow-hover: #dbc02b;
            --danger-glow: #cc8400;
            --danger-color: var(--accent-yellow);
            --ball-color: var(--accent-pink);
            --pole-color: #679b31;
            --star-color: #aaaaee;
            --x-color: #000000;
            --x-color-hover: #333333;

            --menu-width: 260px;
            --transition-speed: 0.4s;
            --transition-timing: ease;
        }

        body.light-mode {
            /* --- Light Mode Overrides (Day) --- */
            --bg-gradient-start: #87CEEB;
            --bg-gradient-end: #FFB347;
            --bg-gradient-stop: #FF6F61;

            --bg-header-bar: rgba(255, 255, 255, 0.85);
            --bg-ui-panel: rgba(255, 255, 255, 0.9);
            --bg-overlay: rgba(245, 245, 250, 0.98);
            --bg-menu: rgba(250, 250, 255, 0.97);
            --bg-modal: rgba(250, 250, 255, 0.95);
            --bg-input: rgba(0, 0, 0, 0.05);
            --bg-button-info: #00a8b5;
            --bg-button-info-hover: #008a96;
            --bg-button-action: #e91e63;
            --bg-button-action-hover: #c2185b;
            --bg-button-special: #fbc02d;
            --bg-button-special-hover: #f9a825;
            --bg-button-watch-ad: #8BC34A;
            --bg-button-watch-ad-hover: #7CB342;
            --bg-button-x: #333333;
            --bg-button-x-hover: #555555;
            --bg-toggle-track: #ccc;
            --bg-toggle-track-active: var(--accent-cyan);
            --bg-link-button: rgba(0, 0, 0, 0.03);
            --bg-link-button-hover: rgba(0, 0, 0, 0.06);
            --bg-copy-button: rgba(0, 0, 0, 0.05);
            --bg-copy-button-hover: rgba(0, 0, 0, 0.1);
            --bg-reward-task-icon: rgba(0, 0, 0, 0.04);
            --bg-reward-task-arrow: rgba(0, 0, 0, 0.06);
            --bg-reward-task-arrow-hover: rgba(0, 0, 0, 0.12);

            --text-light: #212121;
            --text-medium: #555555;
            --text-dark: #ffffff;
            --text-link: var(--accent-cyan);
            --text-link-hover: var(--accent-cyan-hover);
            --text-heading-accent: #ff8f00;
            --text-error: var(--accent-pink);
            --text-placeholder: rgba(0, 0, 0, 0.4);
             --text-copy-button: var(--text-medium);
             --text-copy-button-hover: var(--text-light);
            --text-reward-task-primary: var(--text-light);
            --text-reward-task-secondary: var(--text-medium);
            --text-reward-task-points: #E65100;
            --icon-reward-task: var(--text-light);
            --icon-reward-task-arrow: var(--text-light);

            --border-color: rgba(0, 0, 0, 0.1);
            --border-input: rgba(0, 0, 0, 0.15);
            --border-menu-item: rgba(0, 0, 0, 0.08);
            --border-link-button: rgba(0, 0, 0, 0.1);
            --border-copy-button: rgba(0, 0, 0, 0.15);
            --border-reward-task: rgba(0, 0, 0, 0.08);


            --shadow-color: rgba(0, 0, 0, 0.1);
            --shadow-header-bar: 0 3px 12px var(--shadow-color);
            --shadow-panel: 0 6px 20px var(--shadow-color);
            --shadow-modal: 0 8px 25px var(--shadow-color);
            --shadow-button: 0 2px 5px rgba(0, 0, 0, 0.1);
            --shadow-button-hover: 0 4px 8px rgba(0, 0, 0, 0.15);

            --star-color: rgba(170, 170, 238, 0.3);
        }

        * { box-sizing: border-box; }
        html { height: 100%; }
        body {
            margin: 0; overflow: hidden; font-family: 'Poppins', sans-serif;
             background: linear-gradient(180deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 60%, var(--bg-gradient-stop, var(--bg-gradient-end)) 100%);
            color: var(--text-light); touch-action: none; -webkit-user-select: none;
            -ms-user-select: none; user-select: none; height: 100%; min-height: 100%;
            display: flex; flex-direction: column; align-items: center;
            justify-content: flex-start;
            transition: background var(--transition-speed) var(--transition-timing),
                        color var(--transition-speed) var(--transition-timing);
        }

        #header-bar, #side-menu, #settings-popup, .fullscreen-overlay, .modal, input, button, a.link-button, .score-display, h2, h3, p, #game-canvas, .task-group, .task-item, #referral-list-container, #referral-link-container, .rewarded-ad-item {
             transition: background-color var(--transition-speed) var(--transition-timing),
                         color var(--transition-speed) var(--transition-timing),
                         border-color var(--transition-speed) var(--transition-timing),
                         box-shadow var(--transition-speed) var(--transition-timing),
                         opacity var(--transition-speed) var(--transition-timing),
                         fill var(--transition-speed) var(--transition-timing);
        }
        .star-color-target {}

        #header-bar { padding: 10px 15px 5px 15px; background-color: var(--bg-header-bar); backdrop-filter: blur(var(--backdrop-blur)); color: var(--text-light); z-index: 200; box-shadow: var(--shadow-header-bar); display: flex; flex-direction: column; align-items: center; position: static; border-radius: 0 0 10px 10px; width: 100%; max-width: 500px; margin: 0 auto; flex-shrink: 0; position: relative; min-height: 55px; }
        .modal input[type="number"] { display: block; width: 100%; padding: 10px 12px; margin-bottom: 10px; border: 1px solid var(--border-input); background-color: var(--bg-input); color: var(--text-light); border-radius: 5px; font-family: inherit; font-size: 1em; }
        .modal input::placeholder { color: var(--text-placeholder); opacity: 1; }
        .standard-button { padding: 10px 15px; border: none; border-radius: 5px; background-color: var(--bg-button-info); color: var(--text-dark); font-family: inherit; font-weight: 700; font-size: 1em; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; display: inline-block; margin-top: 5px; }
        .standard-button:hover:not(:disabled) { background-color: var(--bg-button-info-hover); transform: scale(1.03); }
        .standard-button:active:not(:disabled) { transform: scale(0.98); }
        .standard-button.action-button { background-color: var(--bg-button-action); }
        .standard-button.action-button:hover:not(:disabled) { background-color: var(--bg-button-action-hover); }
        .standard-button.special-button { background-color: var(--bg-button-special); }
        .standard-button.special-button:hover:not(:disabled) { background-color: var(--bg-button-special-hover); }
        .standard-button:disabled { background-color: #777; color: #bbb; cursor: not-allowed; transform: none; }
        #score-wrapper { display: flex; width: 100%; max-width: 350px; justify-content: space-around; align-items: center; padding: 8px 0 4px 0; margin-top: 5px; }
        .score-display { font-size: 1.8em; font-weight: 700; text-shadow: 0 1px 2px var(--shadow-color); text-align: center; color: var(--text-light); }
        .score-label { font-size: 0.55em; display: block; opacity: 0.7; font-weight: 400; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-medium); }
        .icon-button { position: absolute; top: 50%; transform: translateY(-50%); background: none; border: none; color: var(--accent-cyan); cursor: pointer; padding: 5px; border-radius: 50%; width: 40px; height: 40px; transition: background-color 0.2s ease, transform 0.2s ease, color 0.2s ease; z-index: 210; display: block; font-size: 24px; line-height: 30px; text-align: center; }
        .icon-button:hover { background-color: rgba(128, 128, 128, 0.1); transform: translateY(-50%) scale(1.1); }
        .icon-button svg { width: 100%; height: 100%; vertical-align: middle; fill: var(--accent-cyan); transition: fill var(--transition-speed) var(--transition-timing); }
        #menu-button { left: 15px; }
        #settings-button { right: 15px; color: var(--accent-cyan); }
        #side-menu { position: fixed; top: 0; left: calc(var(--menu-width) * -1); width: var(--menu-width); height: 100%; background-color: var(--bg-menu); backdrop-filter: blur(var(--backdrop-blur-heavy)); box-shadow: 4px 0 15px var(--shadow-color); z-index: 400; transition: left var(--transition-speed) cubic-bezier(0.25, 0.8, 0.25, 1), background-color var(--transition-speed) var(--transition-timing); padding: 60px 0 20px 0; display: flex; flex-direction: column; overflow-y: auto; }
        #side-menu.open { left: 0; }
        .menu-item-button { display: block; width: 100%; padding: 15px 25px; text-align: left; background: none; border: none; border-bottom: 1px solid var(--border-menu-item); color: var(--text-light); font-family: inherit; font-size: 1.1em; font-weight: 400; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color var(--transition-speed) var(--transition-timing); }
        .menu-item-button:first-of-type { border-top: 1px solid var(--border-menu-item); }
        .menu-item-button:hover { background-color: rgba(128, 128, 128, 0.08); color: var(--accent-cyan); }
        #settings-popup { display: none; position: absolute; top: 60px; right: 15px; background-color: var(--bg-ui-panel); backdrop-filter: blur(var(--backdrop-blur)); border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; box-shadow: var(--shadow-panel); z-index: 350; min-width: 180px; text-align: left; }
        #settings-popup .setting-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        #settings-popup .setting-item p { margin: 0; font-size: 0.95em; color: var(--text-medium); }
        .theme-switch { position: relative; display: inline-block; width: 50px; height: 26px; flex-shrink: 0; }
        .theme-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-toggle-track); transition: background-color var(--transition-speed) var(--transition-timing); border-radius: 26px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: transform var(--transition-speed) var(--transition-timing), background-color var(--transition-speed) var(--transition-timing); border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        input:checked + .slider { background-color: var(--bg-toggle-track-active); }
        input:focus + .slider { box-shadow: 0 0 1px var(--bg-toggle-track-active); }
        input:checked + .slider:before { transform: translateX(24px); }
        .fullscreen-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-overlay); backdrop-filter: blur(var(--backdrop-blur-heavy)); z-index: 500; display: none; padding: 80px 20px 20px 20px; overflow-y: auto; color: var(--text-light); align-items: center; justify-content: flex-start; flex-direction: column; text-align: center; animation: fadeInOverlay 0.3s ease-out; }
        @keyframes fadeInOverlay { from { opacity: 0; } to { opacity: 1; } }
        .overlay-close-button { position: absolute; top: 15px; right: 15px; padding: 8px 12px; background-color: var(--bg-button-action); color: var(--text-dark); border: none; border-radius: 5px; font-size: 1em; font-weight: 700; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease, color var(--transition-speed) var(--transition-timing); z-index: 510; }
        .overlay-close-button:hover { background-color: var(--bg-button-action-hover); transform: scale(1.05); }
        .overlay-title { font-size: 2em; font-weight: 700; color: var(--text-heading-accent); margin-bottom: 20px; margin-top: 20px; }
        .overlay-content { width: 100%; max-width: 450px; padding: 25px; background-color: var(--bg-ui-panel); border-radius: 10px; box-shadow: var(--shadow-panel); color: var(--text-light); display: flex; flex-direction: column; gap: 15px; }
        .overlay-content p { font-size: 1.1em; color: var(--text-medium); margin-bottom: 0; line-height: 1.6; }
        .overlay-content p strong { color: var(--accent-cyan); word-break: break-all; }
        .overlay-content p strong.highlight { color: var(--accent-yellow); font-weight: 700; }
        #profile-overlay .profile-info-item { display: flex; justify-content: space-between; align-items: center; font-size: 1.1em; color: var(--text-medium); padding: 5px 0; border-bottom: 1px solid var(--border-color); }
        #profile-overlay .profile-info-item:last-child { border-bottom: none; }
        #profile-overlay .profile-info-item span { margin-right: 15px; }
        #profile-overlay .profile-info-item strong { color: var(--text-light); word-break: break-all; text-align: right; margin-top: 0; }
        #tasks-overlay .overlay-content { background-color: transparent; box-shadow: none; padding: 0; max-width: 500px; display: flex; flex-direction: column; gap: 30px; }
        .task-group { background-color: var(--bg-ui-panel); border-radius: 10px; box-shadow: var(--shadow-panel); padding: 20px; width: 100%; }
        .task-group h3 { font-size: 1.4em; color: var(--text-heading-accent); margin-top: 0; margin-bottom: 20px; text-align: center; font-weight: 700; }
        .task-group .task-list { display: flex; flex-direction: column; gap: 15px; }
        .task-item { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; background-color: var(--bg-link-button); padding: 10px 15px; border-radius: 8px; border: 1px solid var(--border-link-button); }
        .task-item span { font-size: 1em; color: var(--text-medium); margin-right: 15px; flex-grow: 1; text-align: left; margin-bottom: 5px; }
        .task-item .link-button { display: inline-flex; align-items: center; padding: 8px 18px; border-radius: 20px; background-color: var(--bg-button-info); color: var(--text-dark); text-decoration: none; font-weight: 700; font-size: 0.9em; transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease; box-shadow: var(--shadow-button); cursor: pointer; white-space: nowrap; border: none; flex-shrink: 0; }
        .task-item .link-button:hover { background-color: var(--bg-button-info-hover); transform: scale(1.04); box-shadow: var(--shadow-button-hover); }
        .task-item .link-button svg { width: 18px; height: 18px; fill: currentColor; margin-right: 8px; }
        .task-item .link-button.x-link { background-color: var(--bg-button-x); color: white; }
        .task-item .link-button.x-link:hover { background-color: var(--bg-button-x-hover); }
        .task-item .link-button.youtube-link { background-color: #FF0000; color: white; }
        .task-item .link-button.youtube-link:hover { background-color: #CC0000; }
        .task-item .link-button.submit-link { background-color: var(--bg-button-special); color: var(--text-dark); }
        .task-item .link-button.submit-link:hover { background-color: var(--bg-button-special-hover); }
        #sponsor-contact-button { display: block; width: fit-content; margin: 10px auto 0 auto; padding: 10px 20px; }
        #withdrawal-overlay .overlay-content p { font-size: 1.1em; margin-bottom: 10px; }
        #withdrawal-overlay .overlay-content strong { color: var(--accent-yellow); }
        #withdrawal-overlay .overlay-content button#withdraw-main-button { padding: 12px 25px; border: none; border-radius: 8px; background-color: #999; color: #eee; font-family: inherit; font-weight: 700; font-size: 1.1em; cursor: not-allowed; opacity: 0.6; margin-top: 10px; display: block; width: 100%; }
        #friends-overlay .overlay-content { gap: 20px; }
        #friends-overlay .referral-info { display: flex; flex-direction: column; gap: 10px; text-align: center; margin-bottom: 15px; }
        #referral-link-container { display: flex; align-items: center; gap: 10px; background-color: var(--bg-input); padding: 8px 12px; border-radius: 6px; margin-top: 10px; border: 1px solid var(--border-input); }
        #referral-link-display { flex-grow: 1; font-size: 0.9em; color: var(--text-medium); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: left; }
        #copy-referral-link-button { padding: 6px 10px; font-size: 0.85em; font-weight: 600; background-color: var(--bg-copy-button); color: var(--text-copy-button); border: 1px solid var(--border-copy-button); border-radius: 4px; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
        #copy-referral-link-button:hover { background-color: var(--bg-copy-button-hover); color: var(--text-copy-button-hover); }
        #friends-overlay .referral-count { font-size: 1.2em; font-weight: 700; color: var(--text-light); margin-bottom: 10px; padding-bottom: 10px; text-align: center; border-bottom: 1px solid var(--border-color); }
        #friends-overlay .referral-count strong { color: var(--accent-yellow); }
        #referral-list-container { width: 100%; max-height: 280px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; background-color: rgba(0,0,0,0.1); padding: 10px; scrollbar-width: thin; scrollbar-color: var(--accent-cyan) rgba(0,0,0,0.1); }
        #referral-list-container::-webkit-scrollbar { width: 6px; }
        #referral-list-container::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 3px;}
        #referral-list-container::-webkit-scrollbar-thumb { background-color: var(--accent-cyan); border-radius: 3px; }
        #referral-list { display: flex; flex-direction: column; gap: 10px; }
        .referral-item { display: flex; align-items: center; justify-content: space-between; background-color: var(--bg-link-button); padding: 10px 15px; border-radius: 6px; border: 1px solid var(--border-link-button); }
        .referral-item span { font-size: 1em; color: var(--text-medium); flex-grow: 1; margin-right: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

        /* Rewarded Tasks Section - NEW FORMAT */
        #rewarded-tasks-overlay .overlay-content { gap: 10px; padding: 15px; max-width: 500px; }
        .rewarded-ad-item { display: flex; align-items: center; justify-content: space-between; background-color: var(--bg-link-button); padding: 12px; border-radius: 10px; border: 1px solid var(--border-reward-task); cursor: pointer; transition: background-color 0.2s ease; }
        .rewarded-ad-item.disabled { opacity: 0.6; cursor: not-allowed; pointer-events: none; }
        .rewarded-ad-item:not(.disabled):hover { background-color: var(--bg-link-button-hover); }
        .rewarded-ad-icon { width: 40px; height: 40px; flex-shrink: 0; background-color: var(--bg-reward-task-icon); border-radius: 8px; margin-right: 15px; display: flex; align-items: center; justify-content: center; }
        .rewarded-ad-icon svg { width: 24px; height: 24px; fill: var(--icon-reward-task); }
        .rewarded-ad-text { flex-grow: 1; display: flex; flex-direction: column; text-align: left; }
        .rewarded-ad-text .title { font-size: 1em; font-weight: 500; color: var(--text-reward-task-primary); margin-bottom: 2px; }
        .rewarded-ad-text .progress { font-size: 0.8em; color: var(--text-reward-task-secondary); margin-bottom: 4px; }
        .rewarded-ad-text .reward { font-size: 0.9em; font-weight: 700; color: var(--text-reward-task-points); }
        .rewarded-ad-text .reward svg { width: 12px; height: 12px; fill: currentColor; margin-right: 3px; vertical-align: -1px; }
        .rewarded-ad-action { width: 36px; height: 36px; flex-shrink: 0; background-color: var(--bg-reward-task-arrow); border-radius: 50%; margin-left: 15px; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s ease; }
        .rewarded-ad-item:not(.disabled):hover .rewarded-ad-action { background-color: var(--bg-reward-task-arrow-hover); }
        .rewarded-ad-action svg { width: 20px; height: 20px; fill: var(--icon-reward-task-arrow); }


        #game-container { position: relative; order: 1; flex-grow: 1; width: 100%; min-height: 150px; overflow: hidden; z-index: 1; }
        #game-canvas { display: block; width: 100%; height: 100%; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; }
        #game-over-ui { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: var(--bg-modal); backdrop-filter: blur(var(--backdrop-blur-heavy)); padding: 30px 40px; border-radius: 15px; text-align: center; z-index: 300; display: none; box-shadow: var(--shadow-modal); width: 90%; max-width: 400px; border: 1px solid var(--border-color); pointer-events: auto; color: var(--text-light); }
        #game-over-ui h2 { margin: 0 0 15px 0; font-size: 2.1em; color: var(--text-heading-accent); font-weight: 700; }
        #game-over-ui p#game-over-message { font-size: 1.4em; margin-bottom: 25px; font-weight: 400; min-height: 1.5em; color: var(--text-medium); }
        #game-over-buttons { margin-top: 20px; display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
        .game-over-button { padding: 12px 20px; cursor: pointer; border: none; border-radius: 8px; background-color: var(--bg-button-info); color: var(--text-dark); font-size: 1.1em; font-weight: 700; transition: all .2s ease; pointer-events: auto; width: auto; text-transform: uppercase; letter-spacing: 1px; box-shadow: var(--shadow-button); flex-grow: 1; min-width: 120px; text-align: center; }
        .game-over-button:disabled { opacity: 0.5; cursor: not-allowed; background-color: #999; color: #eee; transform: none; box-shadow: none; }
        .game-over-button:hover:not(:disabled) { background-color: var(--bg-button-info-hover); transform: translateY(-2px) scale(1.02); box-shadow: var(--shadow-button-hover); }
        .game-over-button:active:not(:disabled) { transform: translateY(0px) scale(0.98); box-shadow: 0 1px 3px var(--shadow-color); }
        #watch-ad-button { background-color: var(--bg-button-special); color: var(--text-dark); }
        #watch-ad-button:hover:not(:disabled) { background-color: var(--bg-button-special-hover); }
        .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: var(--bg-modal); backdrop-filter: blur(var(--backdrop-blur-heavy)); padding: 30px 40px; border-radius: 15px; text-align: center; z-index: 600; display: none; box-shadow: var(--shadow-modal); width: 90%; max-width: 400px; border: 1px solid var(--border-color); pointer-events: auto; color: var(--text-light); }
        .modal h2 { margin: 0 0 15px 0; font-size: 1.8em; font-weight: 700; color: var(--text-heading-accent);}
        .modal p { font-size: 1.1em; margin-bottom: 20px; font-weight: 400; color: var(--text-medium); line-height: 1.5;}
        .modal-buttons { margin-top: 20px; display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
        .modal-button { padding: 12px 20px; font-size: 1.05em; }
        #menu-overlay-dimmer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 399; display: none; opacity: 0; transition: opacity var(--transition-speed) ease-in-out; }
        #menu-overlay-dimmer.visible { display: block; opacity: 1; }
    </style>
    <!-- Ad SDK Script Tag -->
    <script src='//whephiwums.com/sdk.js' data-zone='9292240' data-sdk='show_9292240'></script>
</head>
<body>

    <!-- Header Bar -->
    <div id="header-bar">
        <div id="score-wrapper">
            <div class="score-display"> <span class="score-label">Current</span> <span id="current-score">0</span> </div>
            <div class="score-display"> <span class="score-label">Total</span> <span id="total-score">...</span> </div>
        </div>
        <button id="menu-button" class="icon-button" aria-label="Open Menu">
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path fill-rule="evenodd" d="M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z" clip-rule="evenodd" /> </svg>
        </button>
        <button id="settings-button" class="icon-button" aria-label="Settings"> ⚙️ </button>
        <div id="settings-popup">
             <div class="setting-item">
                 <p>Light Mode</p>
                 <label class="theme-switch"> <input type="checkbox" id="theme-toggle-checkbox"> <span class="slider round"></span> </label>
             </div>
        </div>
    </div>

    <!-- Side Menu -->
    <div id="side-menu">
        <button class="menu-item-button" data-action="show-profile">Profile</button>
        <button class="menu-item-button" data-action="show-withdrawal">Withdrawal</button>
        <button class="menu-item-button" data-action="show-friends">Friends</button>
        <button class="menu-item-button" data-action="show-tasks">Tasks</button>
        <button class="menu-item-button" data-action="show-rewarded-tasks">Rewarded Tasks</button>
    </div>
    <div id="menu-overlay-dimmer"></div>

    <!-- Fullscreen Overlays -->
    <div id="profile-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="profile-overlay">Close</button>
        <h2 class="overlay-title">Profile</h2>
        <div class="overlay-content">
             <div class="profile-info-item"> <span>Telegram ID:</span> <strong id="user-id-overlay">...</strong> </div>
             <div class="profile-info-item"> <span>Username:</span> <strong id="username-overlay">...</strong> </div>
             <div class="profile-info-item"> <span>Total Score:</span> <strong id="profile-total-score-display">...</strong> </div>
        </div>
    </div>
    <div id="withdrawal-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="withdrawal-overlay">Close</button>
        <h2 class="overlay-title">Withdrawal</h2>
        <div class="overlay-content">
            <!-- MODIFIED: Updated withdrawal condition text -->
            <p>Withdrawal functionality will be activated from <strong>early or late July</strong>. You must have at least <strong class="highlight">5 referrals</strong> to be eligible. Other conditions may apply and will be announced later. Stay tuned!</p>
            <button id="withdraw-main-button" disabled>Withdrawal (Coming Soon)</button>
        </div>
    </div>
    <div id="friends-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="friends-overlay">Close</button>
        <h2 class="overlay-title">Friends</h2>
        <div class="overlay-content">
            <div class="referral-info">
                <p>Invite your friends using your unique referral link!</p>
                <!-- MODIFIED: Removed point bonus info, added withdrawal requirement info -->
                <p>You need at least <strong class="highlight">5 referrals</strong> to be eligible for withdrawal.</p>
                 <div id="referral-link-container">
                     <span id="referral-link-display">Generating link...</span>
                     <button id="copy-referral-link-button">Copy</button>
                 </div>
            </div>

            <div class="referral-count">
                Total Referrals: <strong id="referral-count-display">0</strong>
            </div>
            <div id="referral-list-container">
                <div id="referral-list">
                    <p style="text-align: center; opacity: 0.7;">Your referrals will appear here.</p>
                </div>
            </div>
        </div>
    </div>
    <div id="tasks-overlay" class="fullscreen-overlay">
         <button class="overlay-close-button" data-overlay-id="tasks-overlay">Close</button>
         <h2 class="overlay-title">Tasks</h2>
         <div class="overlay-content" style="gap: 20px;">
            <div class="task-group">
                <h3>Follow Social Accounts</h3>
                <div class="task-list">
                    <div class="task-item"> <span>Join Telegram Channel</span> <a href="https://t.me/helix_cryptodrop" target="_blank" rel="noopener noreferrer" class="link-button"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.17.91-.497 1.208-.82 1.23-.696.047-1.225-.46-1.9-.91-.546-.353-1.075-.688-1.758-1.104l-.108-.061c-1.218-.78-1.896-1.182-1.736-1.889.05-.212.333-.717.333-.717l.11-.24s4.17-3.8 4.576-4.18c.07-.07.12-.15.05-.23-.07-.08-.18-.05-.25-.02-.11.04-1.88 1.16-5.36 3.34-.47.29-.88.43-1.28.42-.49-.01-.97-.13-1.42-.25-1.03-.28-1.88-.42-1.79-.93.04-.22.31-.42.88-.63 3.41-1.22 5.68-2.07 6.94-2.51.3-.11.56-.2.78-.2z"/></svg> Join </a> </div>
                    <div class="task-item"> <span>Follow on X (Twitter)</span> <a href="https://x.com/drop_official89?t=lJ9kaQKLwWQk41avHSJdhw&s=08" target="_blank" rel="noopener noreferrer" class="link-button x-link"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg> Follow </a> </div>
                    <div class="task-item"> <span>Subscribe on YouTube</span> <a href="https://youtube.com/@YourChannelName" target="_blank" rel="noopener noreferrer" class="link-button youtube-link"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" > <path fill-rule="evenodd" d="M19.802 5.578a3.75 3.75 0 0 0-2.652-2.652C15.547 2.5 12 2.5 12 2.5s-3.547 0-5.15.426A3.75 3.75 0 0 0 4.198 5.578C3.773 7.18 3.773 12 3.773 12s0 4.82.425 6.422a3.75 3.75 0 0 0 2.652 2.652C8.453 21.5 12 21.5 12 21.5s3.547 0 5.15-.426a3.75 3.75 0 0 0 2.652-2.652C20.227 16.82 20.227 12 20.227 12s0-4.82-.425-6.422ZM9.75 15.5V8.5l6 3.5-6 3.5Z" clip-rule="evenodd" /> </svg> Subscribe </a> </div>
                </div>
            </div>
            <div class="task-group">
                <h3>Creator Media Rewards</h3>
                 <div class="task-list">
                     <div class="task-item"> <span>Created Instagram Content? Submit Proof for Rewards</span> <a href="#creator-submission" class="link-button submit-link"> Submit Proof </a> </div>
                     <div class="task-item"> <span>Created YouTube Content? Submit Proof for Rewards</span> <a href="#creator-submission" class="link-button submit-link"> Submit Proof </a> </div>
                     <div class="task-item"> <span>Created Facebook Content? Submit Proof for Rewards</span> <a href="#creator-submission" class="link-button submit-link"> Submit Proof </a> </div>
                 </div>
            </div>
             <div class="task-group">
                 <h3>Sponsorship & Partnership</h3>
                 <p style="font-size: 1em; text-align: center; margin-bottom: 15px;">Are you interested in sponsoring or partnering with Helix Point Drop?</p>
                 <a href="mailto:youremail@example.com?subject=Sponsorship Inquiry - Helix Point Drop" id="sponsor-contact-button" class="standard-button special-button">Contact Us</a>
             </div>
         </div>
     </div>
    <div id="rewarded-tasks-overlay" class="fullscreen-overlay">
        <button class="overlay-close-button" data-overlay-id="rewarded-tasks-overlay">Close</button>
        <h2 class="overlay-title">Rewarded Tasks</h2>
        <div class="overlay-content" id="rewarded-tasks-list">
             <p style="text-align: center; opacity: 0.7;">Loading tasks...</p>
             <!-- Task items will be generated here by JS -->
        </div>
    </div>

    <!-- Game Over UI -->
    <div id="game-over-ui" class="modal">
        <h2>Game Over!</h2>
        <p id="game-over-message">Score: <span id="final-score">0</span></p>
        <div id="game-over-buttons">
            <button id="watch-ad-button" class="game-over-button">Watch Ad & Save</button>
            <button id="restart-button" class="game-over-button">Restart</button>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container"> <canvas id="game-canvas"></canvas> </div>

    <!-- *********************************************************** -->
    <!-- * MOCK TELEGRAM OBJECT FOR LOCAL TESTING (COMMENTED OUT)  * -->
    <!-- *********************************************************** -->
    <!--
    <script>
        // WARNING: This is ONLY for local browser testing.
        if (!window.Telegram) {
            console.warn("Creating MOCK Telegram.WebApp object for testing. REMOVE THIS SCRIPT FOR PRODUCTION!");
            window.Telegram = {
                WebApp: {
                    // Example with Referral ID (uncomment to test referral)
                    // initData: "mockInitData_QUERYID=MOCKQUERYID&user=%7B%22id%22%3A112233445%2C%22first_name%22%3A%22New%22%2C%22last_name%22%3A%22Player%22%2C%22username%22%3A%22new_player_ref%22%2C%22language_code%22%3A%22en%22%2C%22is_premium%22%3Afalse%7D&auth_date=1678886400&hash=mockhashstring_new_ref&start_param=987654321", // Referrer ID: 987654321
                    // Example without Referral ID
                    initData: "mockInitData_QUERYID=MOCKQUERYID&user=%7B%22id%22%3A987654321%2C%22first_name%22%3A%22Mock%22%2C%22last_name%22%3A%22Tester%22%2C%22username%22%3A%22mock_tester_main%22%2C%22language_code%22%3A%22en%22%2C%22is_premium%22%3Afalse%7D&auth_date=1678886400&hash=mockhashstring_main",
                    initDataUnsafe: {
                        query_id: "MOCKQUERYID_MAIN",
                        user: {
                            id: 987654321, // Example User ID
                            first_name: "Mock",
                            last_name: "Tester",
                            username: "mock_tester_main", // Example username
                            language_code: "en",
                            is_premium: false
                        },
                        // --- MOCK start_param for TESTING ---
                         start_param: null, // Set to null/empty for normal launch
                        // start_param: "123456789", // Uncomment to test referral flow (Referrer ID: 123456789)
                        auth_date: Math.floor(Date.now() / 1000),
                        hash: "mockhashstring_main"
                    },
                    version: "7.2", platform: "browser_mock_ref", colorScheme: "dark",
                    themeParams: { bg_color: "#0a0a1a", text_color: "#ffffff", hint_color: "#aaaaaa", link_color: "#00cfde", button_color: "#00cfde", button_text_color: "#111122", secondary_bg_color: "#111122", },
                    isExpanded: true, viewportHeight: window.innerHeight, viewportStableHeight: window.innerHeight - 50, headerColor: '#0a0a1a', backgroundColor: '#0a0a1a', isClosingConfirmationEnabled: false,
                    ready: () => console.log("Mock Telegram.WebApp.ready() called"),
                    expand: () => console.log("Mock Telegram.WebApp.expand() called"),
                    onEvent: (eventType, callback) => { console.log(`Mock Telegram.WebApp.onEvent('${eventType}') registered`); },
                    offEvent: (eventType, callback) => { console.log(`Mock Telegram.WebApp.offEvent('${eventType}') unregistered`); },
                    sendData: (data) => { console.log(`Mock Telegram.WebApp.sendData called with:`, data); alert(`Mock Send Data: ${data}`); },
                    close: () => { console.log("Mock Telegram.WebApp.close() called"); alert("Mock Close Requested"); },
                    setHeaderColor: (color) => { console.log(`Mock Telegram.WebApp.setHeaderColor('${color}') called`); window.Telegram.WebApp.headerColor = color; },
                    setBackgroundColor: (color) => { console.log(`Mock Telegram.WebApp.setBackgroundColor('${color}') called`); window.Telegram.WebApp.backgroundColor = color; },
                    showAlert: (message) => { console.log(`Mock Telegram.WebApp.showAlert: ${message}`); alert(`TG Alert: ${message}`); },
                    showConfirm: (message, callback) => { console.log(`Mock Telegram.WebApp.showConfirm: ${message}`); const result = confirm(`TG Confirm: ${message}`); if (callback) { callback(result); } },
                }
            };
        }
    </script>
    -->
    <!-- *********************************************************** -->
    <!-- * END OF MOCK TELEGRAM OBJECT SCRIPT                      * -->
    <!-- *********************************************************** -->


    <!-- Libraries & SDKs -->
    <script type="importmap">{ "imports": { "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js", "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/" } }</script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>


    <!-- Game Logic (as module) -->
    <script type="module">

        // --- Imports ---
        import * as THREE from 'three';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { TextureLoader } from 'three';

        // --- Constants ---
        const BOT_USERNAME = "Crypto_drop_ya_bot";
        const MINI_APP_NAME = ""; // Usually empty if served at the bot's root web app URL
        // REMOVED: Referral bonus point constants

        // MODIFIED: Rewarded ad task config with updated ad types for tasks 4 & 5
        const REWARDED_AD_TASKS_CONFIG = {
            'task_1': { title: "Watch video", reward: 50, limit: 50, icon: 'video', adType: 'rewardedInterstitial' },
            'task_2': { title: "Watch video", reward: 40, limit: 40, icon: 'video', adType: 'rewardedPopup' },
            'task_3': { title: "Watch video", reward: 30, limit: 30, icon: 'video', adType: 'inAppInterstitial' },
            'task_4': { title: "Watch video", reward: 20, limit: 20, icon: 'video', adType: 'rewardedInterstitial' }, // Changed from simulation
            'task_5': { title: "Watch video", reward: 10, limit: 10, icon: 'video', adType: 'inAppInterstitial' }      // Changed from simulation
        };


        // --- Global Variables ---
        let scene, camera, renderer, composer, bloomPass;
        let ball, platformGroup, poleGroup, starField;
        let currentScore = 0;
        let gameState = 'initializing';
        let internalPauseState = false;
        let rotationSensitivity = 0.02, bounceSpeed = 0.11;
        let currentBallVelocityY = 0, ballPreviousY = 0, lastSafePlatformY = 0;
        const gravity = -0.0035;
        const platformRadius = 2.5, poleRadius = 0.5, gapSize = Math.PI / 2.5;
        const platformSegments = 3, platformSpacingY = 2.0;
        let activePlatforms = [], nextPlatformY = 0;
        let activePoleSegments = {};
        let scoreIncrementedForPlatform = {};
        const ballStartX = 1.5; const ballStartZ = 0; const initialBallY = 8;
        const cameraVerticalOffset = 4.5, cameraLookAtOffset = 1.0;
        const cameraFixedZ = 11; const cameraZoomedInZ = 9.5; const cameraZoomDuration = 600;
        let isCameraZooming = false; let cameraZoomRequestId = null;
        const cameraFollowLerpFactor = 0.08;
        let envMap = null;
        const clock = new THREE.Clock();
        let ballTexture = null;
        const textureLoader = new TextureLoader();
        const platformColorPalette = [ 0x00cfde, 0x8e44ad, 0x3498db, 0x2ecc71, 0xe74c3c, 0xf39c12 ];
        let platformColorIndex = 0;
        let shakeIntensity = 0; const shakeDecreaseFactor = 0.9; const maxShakeOffset = 0.15;
        let isPointerDown = false; let previousPointerX = 0;
        let adTimerIntervalId = null; // Only for game over countdown
        const FADE_DURATION = 500;

        // --- Element References ---
        const currentScoreEl = document.getElementById('current-score');
        const totalScoreEl = document.getElementById('total-score');
        const scoreWrapper = document.getElementById('score-wrapper');
        const gameOverUI = document.getElementById('game-over-ui');
        const finalScoreEl = document.getElementById('final-score');
        const gameOverMessageP = document.getElementById('game-over-message');
        const restartButton = document.getElementById('restart-button');
        const watchAdButton = document.getElementById('watch-ad-button');
        const gameContainer = document.getElementById('game-container');
        const headerBar = document.getElementById('header-bar');
        const menuButton = document.getElementById('menu-button');
        const settingsButton = document.getElementById('settings-button');
        const sideMenu = document.getElementById('side-menu');
        const menuOverlayDimmer = document.getElementById('menu-overlay-dimmer');
        const settingsPopup = document.getElementById('settings-popup');
        const profileOverlay = document.getElementById('profile-overlay');
        const profileTotalScoreDisplay = document.getElementById('profile-total-score-display');
        const userIdOverlay = document.getElementById('user-id-overlay');
        const usernameOverlay = document.getElementById('username-overlay');
        const withdrawalOverlay = document.getElementById('withdrawal-overlay');
        const friendsOverlay = document.getElementById('friends-overlay');
        const tasksOverlay = document.getElementById('tasks-overlay');
        const rewardedTasksOverlay = document.getElementById('rewarded-tasks-overlay');
        const sponsorContactButton = document.getElementById('sponsor-contact-button');
        const overlayCloseButtons = document.querySelectorAll('.overlay-close-button');
        const menuItemButtons = sideMenu.querySelectorAll('.menu-item-button');
        const themeToggleCheckbox = document.getElementById('theme-toggle-checkbox');
        const referralLinkDisplay = document.getElementById('referral-link-display');
        const copyReferralLinkButton = document.getElementById('copy-referral-link-button');
        const referralCountDisplay = document.getElementById('referral-count-display');
        const referralList = document.getElementById('referral-list');
        const rewardedTasksListContainer = document.getElementById('rewarded-tasks-list');

        // --- Firebase Setup ---
         const firebaseConfig = {
             apiKey: "AIzaSyCIYBPkVduy16dcYQ9PaSIc58BsNVamsO0", // Replace with your actual API key if needed (consider security)
             authDomain: "helix-cryptodrop.firebaseapp.com",
             databaseURL: "https://helix-cryptodrop-default-rtdb.firebaseio.com",
             projectId: "helix-cryptodrop",
             storageBucket: "helix-cryptodrop.appspot.com",
             messagingSenderId: "981063831600",
             appId: "1:981063831600:web:2628901c5186a635e65df5"
         };
         let app, db;
         let telegramUserId = null;
         let telegramUserData = null;
         let currentUserTotalScore = 0;
         let currentUserReferralCount = 0;
         let currentUserReferrals = {};
         let currentUserAdTasks = {};
         let userRef = null;
         let userDataListener = null;
         let hasProcessedReferral = false;

        // --- Utility Functions ---
        function getCssVariable(varName) { return getComputedStyle(document.documentElement).getPropertyValue(varName).trim(); }
        function parseColorHex(colorString) { if (colorString.startsWith('#')) { return parseInt(colorString.substring(1), 16); } console.warn(`Could not parse color hex: ${colorString}`); return 0xffffff; }
        function formatNumber(num) { if (typeof num !== 'number') return num; return num.toLocaleString(); }
        function maskUsername(username) { if (!username || username.length <= 3) return "***"; return username.substring(0, 3) + '*'.repeat(username.length - 3); }
        function generateReferralLink(userId) { if (!userId || BOT_USERNAME === "YOUR_BOT_USERNAME") { if (BOT_USERNAME === "YOUR_BOT_USERNAME") console.warn("Set BOT_USERNAME"); return "Link Unavailable"; } const appPath = MINI_APP_NAME ? `/${MINI_APP_NAME}` : ''; return `https://t.me/${BOT_USERNAME}${appPath}?startapp=${userId}`; }
        async function copyToClipboard(text) { if (!navigator.clipboard) { console.warn("Clipboard API missing"); return false; } try { await navigator.clipboard.writeText(text); return true; } catch (err) { console.error('Copy fail: ', err); return false; } }


        // --- UI Update & State Management ---
        function updateScoreUI() { if (currentScoreEl) currentScoreEl.textContent = formatNumber(currentScore); }
        function updateTotalScoreUI(score) { const fmt = formatNumber(score); if (totalScoreEl) totalScoreEl.textContent = String(fmt); if (profileTotalScoreDisplay) profileTotalScoreDisplay.textContent = String(fmt); }
        function updateReferralCountUI(count) { if(referralCountDisplay) referralCountDisplay.textContent = formatNumber(count || 0); }
        function updateReferralLinkUI(userId) { if (referralLinkDisplay) referralLinkDisplay.textContent = generateReferralLink(userId); }
        function populateReferralListUI(referralsData) {
             if (!referralList) return; referralList.innerHTML = '';
             if (!referralsData || Object.keys(referralsData).length === 0) { referralList.innerHTML = '<p style="text-align: center; opacity: 0.7;">No referrals yet.</p>'; return; }
             Object.keys(referralsData).forEach(refId => { const d = referralsData[refId]; const li = document.createElement('div'); li.className = 'referral-item'; const span = document.createElement('span'); span.textContent = maskUsername(d.username || 'User'); li.appendChild(span); referralList.appendChild(li); });
         }
         function generateAndPopulateRewardedTasksUI(userTaskData) {
             if (!rewardedTasksListContainer) return;
             rewardedTasksListContainer.innerHTML = '';

             Object.entries(REWARDED_AD_TASKS_CONFIG).forEach(([taskId, config]) => {
                 const userData = userTaskData[taskId] || { completed: 0 };
                 const completed = userData.completed || 0;
                 const limit = config.limit;
                 const remaining = limit - completed;
                 const isDisabled = remaining <= 0;

                 const item = document.createElement('div');
                 item.className = `rewarded-ad-item ${isDisabled ? 'disabled' : ''}`;
                 item.id = `rewarded-ad-${taskId}`;
                 item.dataset.taskId = taskId;

                 const iconContainer = document.createElement('div');
                 iconContainer.className = 'rewarded-ad-icon';
                 if (config.icon === 'video') { iconContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 6.47C4 5.66 4.66 5 5.47 5h13.06c.81 0 1.47.66 1.47 1.47v11.06c0 .81-.66 1.47-1.47 1.47H5.47C4.66 19 4 18.34 4 17.53V6.47zm8.38 7.14l4.39-2.63c.36-.21.36-.71 0-.92l-4.39-2.63c-.35-.21-.79.04-.79.46v5.26c0 .42.44.67.79.46z"/></svg>`; }
                 else { iconContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 4H6C4.9 4 4 4.9 4 6v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-4 12h-4v-2h4v2zm0-4h-4v-2h4v2zm0-4h-4V6h4v2z"/></svg>`; }

                 const textContainer = document.createElement('div');
                 textContainer.className = 'rewarded-ad-text';
                 const titleSpan = document.createElement('span'); titleSpan.className = 'title'; titleSpan.textContent = config.title;
                 const progressSpan = document.createElement('span'); progressSpan.className = 'progress'; progressSpan.textContent = `${completed} / ${limit}`;
                 const rewardSpan = document.createElement('span'); rewardSpan.className = 'reward'; rewardSpan.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5.52.832a.5.5 0 0 1 .756.056l8 15a.5.5 0 0 1-.812.387L8.21 13H2.5a.5.5 0 0 1-.4-.8L5.52.832z"/></svg>+${config.reward}`;
                 textContainer.appendChild(titleSpan); textContainer.appendChild(progressSpan); textContainer.appendChild(rewardSpan);

                 const actionContainer = document.createElement('div'); actionContainer.className = 'rewarded-ad-action';
                 actionContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m13.293 12-4.647-4.646a.75.75 0 0 1 1.06-1.06L15.414 12l-5.708 5.707a.75.75 0 1 1-1.06-1.06L13.293 12Z"/></svg>`;

                 item.appendChild(iconContainer); item.appendChild(textContainer); item.appendChild(actionContainer);

                 if (!isDisabled) { item.addEventListener('click', () => { handleWatchRewardedAd(taskId, config.reward, item); }); }
                 rewardedTasksListContainer.appendChild(item);
             });
         }

        function setInternalPause(pause) { if (internalPauseState === pause) return; internalPauseState = pause; if (!pause && gameState === 'playing') { clock.getDelta(); } }
        function isAnyUIOverlayOpen() { return sideMenu.classList.contains('open') || settingsPopup.style.display === 'block' || profileOverlay.style.display === 'flex' || withdrawalOverlay.style.display === 'flex' || friendsOverlay.style.display === 'flex' || tasksOverlay.style.display === 'flex' || rewardedTasksOverlay.style.display === 'flex' || gameOverUI.style.display === 'block'; }
        function pauseGameForUI() { if (gameState === 'playing') { gameState = 'paused_by_ui'; setInternalPause(true); console.log("Paused for UI"); } }
        function resumeGameFromUI() { if (!isAnyUIOverlayOpen() && gameState === 'paused_by_ui') { gameState = 'playing'; setInternalPause(false); console.log("Resumed from UI"); } }

        // --- Firebase Functions ---
        function initializeFirebaseApp() {
            try { if (!firebaseConfig.apiKey || !firebaseConfig.databaseURL) { throw new Error("Firebase config missing."); } if (!firebase.apps.length) { app = firebase.initializeApp(firebaseConfig); } else { app = firebase.app(); } db = firebase.database(); console.log("Firebase Initialized OK"); }
            catch (e) { console.error("Firebase Init Failed:", e); alert("Service Error."); updateTotalScoreUI("Error"); updateReferralCountUI("Error"); gameState='error'; setInternalPause(true); }
        }

        function listenToUserData(tgUserId) {
             if (!db) { console.warn("DB unavailable."); updateTotalScoreUI("N/A"); updateReferralCountUI("N/A"); return; }
             if (!tgUserId) { console.warn("Cannot listen: No User ID."); return; }
             if (userRef && userDataListener) { userRef.off('value', userDataListener); }
             const dbPath = `users/tg_${tgUserId}`; console.log("Listening:", dbPath); userRef = db.ref(dbPath);

             userDataListener = userRef.on('value', (snapshot) => {
                 let score = 0, refCount = 0, refs = {}, refBy = null, adTasks = {};
                 const defaultAdTaskData = {};
                 Object.keys(REWARDED_AD_TASKS_CONFIG).forEach(key => { defaultAdTaskData[key] = { completed: 0 }; });

                 if (snapshot.exists()) {
                     const data = snapshot.val();
                     score = Math.floor(data.totalScore || 0);
                     refCount = data.referrals?.count || 0;
                     refs = data.referrals?.list || {};
                     refBy = data.referredBy || null;
                     adTasks = { ...defaultAdTaskData, ...(data.adTasks || {}) };
                     if (typeof data.totalScore !== 'number') snapshot.ref.child('totalScore').set(0).catch(e=>console.warn("Fix score err", e));
                     if (!data.referrals) snapshot.ref.child('referrals').set({ count: 0, list: {} }).catch(e=>console.warn("Fix ref err", e));
                     if (typeof data.referrals?.count !== 'number' && data.referrals) snapshot.ref.child('referrals/count').set(0).catch(e=>console.warn("Fix ref count err", e));
                     if (!data.adTasks) snapshot.ref.child('adTasks').set(defaultAdTaskData).catch(e=>console.warn("Init adTasks err", e));
                     // Ensure all tasks from config exist in user data, prevents errors if config changes
                     Object.keys(REWARDED_AD_TASKS_CONFIG).forEach(taskId => {
                        if (!adTasks[taskId]) {
                            adTasks[taskId] = { completed: 0 };
                             snapshot.ref.child(`adTasks/${taskId}`).set({ completed: 0 }).catch(e=>console.warn(`Fix missing task ${taskId} err`, e));
                        }
                     });

                 } else {
                     console.log("User data missing, initializing...");
                     const initialData = { totalScore: 0, referrals: { count: 0, list: {} }, firstSeen: firebase.database.ServerValue.TIMESTAMP, firstName: telegramUserData?.first_name || 'User', username: telegramUserData?.username || null, referredBy: null, adTasks: defaultAdTaskData };
                     userRef.set(initialData).then(() => { console.log("Initialized user data."); processReferralOnLoad(tgUserId); }).catch(e => console.error("Init user err", e));
                     score = 0; refCount = 0; refs = {}; refBy = null; adTasks = defaultAdTaskData;
                 }
                 currentUserTotalScore = score;
                 currentUserReferralCount = refCount;
                 currentUserReferrals = refs;
                 currentUserAdTasks = adTasks;

                 updateTotalScoreUI(score);
                 updateReferralCountUI(refCount);
                 populateReferralListUI(refs);
                 updateReferralLinkUI(tgUserId);
                 generateAndPopulateRewardedTasksUI(adTasks);

                 if (!hasProcessedReferral && refBy === null && snapshot.exists()) { processReferralOnLoad(tgUserId); }
                 else if (refBy !== null) { hasProcessedReferral = true; }

             }, (error) => { console.error("User data listener error:", error); updateTotalScoreUI("DB Err"); updateReferralCountUI("DB Err"); userRef = null; userDataListener = null; });
         }

         async function processReferralOnLoad(currentUserId) {
             if (hasProcessedReferral || !window.Telegram?.WebApp?.initDataUnsafe) return;
             const startParam = window.Telegram.WebApp.initDataUnsafe.start_param;
             if (!startParam) { console.log("No start_param."); hasProcessedReferral = true; return; }
             const referrerId = parseInt(startParam, 10);
             if (!referrerId || isNaN(referrerId) || referrerId === currentUserId) { console.warn("Invalid/self referral:", startParam); hasProcessedReferral = true; return; }
             console.log(`Referral detected: Referrer ${referrerId}, Current ${currentUserId}`);
             hasProcessedReferral = true;
             const currentUserRef = db.ref(`users/tg_${currentUserId}`);
             try {
                 const currentUserSnapshot = await currentUserRef.get();
                 if (!currentUserSnapshot.exists()){ console.warn("User data missing during referral check."); hasProcessedReferral = false; return; }
                 if (currentUserSnapshot.val()?.referredBy) { console.log(`User ${currentUserId} already referred.`); return; }

                 const updates = {};
                 const currentUsername = window.Telegram.WebApp.initDataUnsafe.user?.username || `User_${currentUserId}`;
                 const refListPath = `users/tg_${referrerId}/referrals/list/tg_${currentUserId}`;
                 const refCountPath = `users/tg_${referrerId}/referrals/count`;
                 // REMOVED: const newUserScorePath = `users/tg_${currentUserId}/totalScore`;
                 const newUserRefByPath = `users/tg_${currentUserId}/referredBy`;
                 // REMOVED: const referrerScorePath = `users/tg_${referrerId}/totalScore`;

                 updates[refListPath] = { username: currentUsername, timestamp: firebase.database.ServerValue.TIMESTAMP };
                 updates[refCountPath] = firebase.database.ServerValue.increment(1);
                 // REMOVED: updates[newUserScorePath] = firebase.database.ServerValue.increment(INITIAL_REFERRAL_BONUS);
                 updates[newUserRefByPath] = referrerId;
                 // REMOVED: updates[referrerScorePath] = firebase.database.ServerValue.increment(REFERRER_BONUS_POINTS);

                 console.log("Performing referral update (no point bonus):", updates);
                 await db.ref().update(updates);
                 console.log("Referral processed successfully (no point bonus)!");
                 // REMOVED: Point bonus notification
             } catch (error) { console.error("Error checking/processing referral:", error); hasProcessedReferral = false; }
         }

        function updateUserTotalScore(scoreToAdd) {
             if (!db || !telegramUserId || typeof scoreToAdd !== 'number' || isNaN(scoreToAdd)) return Promise.reject("Invalid score input");
             if (scoreToAdd <= 0) return Promise.resolve();
             const ref = db.ref(`users/tg_${telegramUserId}/totalScore`);
             return ref.transaction(curr => (curr || 0) + Math.floor(scoreToAdd))
                .then(()=>console.log(`Score updated by ${scoreToAdd}`))
                .catch((e)=>{console.error("Score update tx err:", e); return Promise.reject(e);});
         }

        // --- Theme Handling ---
        function applyTheme(theme) { const isLight = theme === 'light'; document.body.classList.toggle('light-mode', isLight); themeToggleCheckbox.checked = isLight; localStorage.setItem('theme', theme); updateMaterialsTheme(); try { if (window.Telegram?.WebApp) { const hc = getCssVariable('--bg-header-bar'); window.Telegram.WebApp.setHeaderColor(hc); } } catch (e) { console.warn("TG theme color set fail:", e); } console.log(`Theme: ${theme}`); }
        function updateMaterialsTheme() { const isLight = document.body.classList.contains('light-mode'); if (ball?.material) { const bc = parseColorHex(getCssVariable('--ball-color')); ball.material.color.setHex(bc); } const pc = parseColorHex(getCssVariable('--pole-color')); for (const y in activePoleSegments) { const s = activePoleSegments[y]; if (s?.material) { s.material.color.setHex(pc); } } const dCol = parseColorHex(getCssVariable('--danger-color')); const dEm = parseColorHex(getCssVariable('--danger-glow')); activePlatforms.forEach(p => { if (p?.userData?.segmentAngles) { p.userData.segmentAngles.forEach(sd => { if (sd.isDanger && sd.material) { sd.material.color.setHex(dCol); sd.material.emissive.setHex(dEm); } else if (!sd.isDanger && sd.material && p.userData.colorHex) { sd.material.color.setHex(p.userData.colorHex); } }); } }); if (scene) { if (isLight) { scene.background = null; if (starField) starField.visible = false; } else { scene.background = null; if (starField) { starField.visible = true; const sc = parseColorHex(getCssVariable('--star-color')); starField.material.color.setHex(sc); starField.material.needsUpdate = true; } else { createStarfield(); } } } }
        function setupTheme() { let initTheme = 'dark'; try { initTheme = window.Telegram?.WebApp?.colorScheme || localStorage.getItem('theme') || 'dark'; console.log(`Init theme from TG/LS: ${initTheme}`); } catch (e) { console.warn("Theme fetch err:", e); initTheme = localStorage.getItem('theme') || 'dark'; } applyTheme(initTheme); themeToggleCheckbox.addEventListener('change', () => applyTheme(themeToggleCheckbox.checked ? 'light' : 'dark')); try { window.Telegram?.WebApp?.onEvent('themeChanged', () => { console.log('TG theme changed event'); applyTheme(window.Telegram.WebApp.colorScheme); }); } catch(e) { console.warn("TG theme listener err:", e); } }

        // --- UI Control Functions ---
        function toggleSideMenu() { const open=sideMenu.classList.toggle('open'); menuOverlayDimmer.classList.toggle('visible', open); if(open){ closeSettingsPopup(); pauseGameForUI(); } else { resumeGameFromUI(); }}
        function closeSideMenu() { if(sideMenu.classList.contains('open')){ sideMenu.classList.remove('open'); menuOverlayDimmer.classList.remove('visible'); resumeGameFromUI(); }}
        function toggleSettingsPopup() { const vis=settingsPopup.style.display==='block'; if(vis){ closeSettingsPopup(); } else { openSettingsPopup(); }}
        function openSettingsPopup() { closeSideMenu(); settingsPopup.style.display = 'block'; pauseGameForUI(); }
        function closeSettingsPopup() { if(settingsPopup.style.display === 'block'){ settingsPopup.style.display = 'none'; resumeGameFromUI(); }}
        function showOverlay(el) { if(!el) return; closeSideMenu(); closeSettingsPopup(); closeAllOverlays(el); el.style.display = 'flex'; pauseGameForUI(); if(el===profileOverlay){ updateTotalScoreUI(currentUserTotalScore); } if(el===friendsOverlay){ updateReferralCountUI(currentUserReferralCount); populateReferralListUI(currentUserReferrals); updateReferralLinkUI(telegramUserId); } if (el === rewardedTasksOverlay) { generateAndPopulateRewardedTasksUI(currentUserAdTasks); } }
        function hideOverlay(el) { if(!el || el.style.display === 'none') return; el.style.display = 'none'; resumeGameFromUI(); }
        function closeAllOverlays(exclude=null) { [profileOverlay, withdrawalOverlay, friendsOverlay, tasksOverlay, rewardedTasksOverlay].forEach(o => { if (o && o !== exclude) hideOverlay(o); }); }

        // --- Rewarded Ad Task Logic (Using Ad SDK) ---
        function handleWatchRewardedAd(taskId, reward, taskElement) {
            if (!db || !telegramUserId || !taskElement) {
                window.Telegram?.WebApp?.showAlert("Cannot process task at the moment.");
                return;
            }
            // Check if the SDK function is globally available
             if (typeof show_9292240 !== 'function') {
                console.error("Ad SDK function 'show_9292240' not found.");
                window.Telegram?.WebApp?.showAlert("Ad SDK not loaded. Please try again later.");
                return;
            }

            const config = REWARDED_AD_TASKS_CONFIG[taskId];
            const currentData = currentUserAdTasks[taskId] || { completed: 0 };
            const completed = currentData.completed || 0;

            if (completed >= config.limit) {
                window.Telegram?.WebApp?.showAlert("No more ads available for this task today.");
                return;
            }

            taskElement.classList.add('disabled'); // Visually disable immediately
            console.log(`Attempting rewarded ad task: ${taskId}, Reward: ${reward}, Ad Type: ${config.adType}`);

            // Define the reward logic as a reusable function
            const grantReward = () => {
                console.log(`Ad success callback triggered for task ${taskId}.`);
                const adTaskRef = db.ref(`users/tg_${telegramUserId}/adTasks/${taskId}/completed`);
                const scoreRef = db.ref(`users/tg_${telegramUserId}/totalScore`);

                adTaskRef.transaction(currentCompleted => {
                    if (currentCompleted === null) currentCompleted = 0;
                    // Re-check limit inside transaction for safety
                    if (currentCompleted >= config.limit) {
                        console.warn(`Limit reached during transaction for task ${taskId}`);
                        return; // Abort transaction by returning undefined
                    }
                    return currentCompleted + 1;
                }).then(result => {
                    if (result.committed && result.snapshot.exists()) {
                        const newCompleted = result.snapshot.val();
                        console.log(`Task ${taskId} count updated to ${newCompleted}. Awarding points.`);
                        return scoreRef.transaction(currentScore => (currentScore || 0) + reward);
                    } else {
                         if (!result.committed && result.error) {
                             console.error(`Count transaction aborted or failed for task ${taskId}:`, result.error);
                             window.Telegram?.WebApp?.showAlert("Could not update task count due to an error. Please try again.");
                         } else if (!result.committed) {
                             // This happens if the transaction was aborted (e.g., limit reached)
                             console.warn(`Count transaction aborted (likely limit reached) for task ${taskId}.`);
                             window.Telegram?.WebApp?.showAlert("Task limit reached.");
                         } else {
                             console.warn(`Failed to update count for task ${taskId}, snapshot missing. Aborting reward.`);
                             window.Telegram?.WebApp?.showAlert("Could not update task count. Please try again.");
                         }
                         return Promise.reject("Count update failed or aborted");
                    }
                }).then(() => {
                    console.log(`Successfully awarded ${reward} points for task ${taskId}`);
                    window.Telegram?.WebApp?.showAlert(`You received ${reward} points!`);
                    // UI update happens via listener, no need to manually remove 'disabled' here as listener handles it
                }).catch(error => {
                     if (error !== "Count update failed or aborted") {
                         console.error(`Error processing task ${taskId} reward:`, error);
                         window.Telegram?.WebApp?.showAlert("An error occurred processing the reward.");
                     }
                     // Let listener handle UI update based on actual DB state, including re-enabling if necessary
                });
            };

            // Call the appropriate Ad SDK function based on config
            if (config.adType === 'rewardedInterstitial') {
                 show_9292240().then(grantReward).catch(error => {
                     console.error(`Rewarded Interstitial Ad SDK failed for task ${taskId}:`, error);
                     window.Telegram?.WebApp?.showAlert("Ad failed or skipped. No reward.");
                     // Check latest count from live data before re-enabling
                     const latestCount = currentUserAdTasks[taskId]?.completed || 0;
                     if (latestCount < config.limit) taskElement.classList.remove('disabled');
                 });
            } else if (config.adType === 'rewardedPopup') {
                 show_9292240('pop').then(grantReward).catch(error => {
                     console.error(`Rewarded Popup Ad SDK failed for task ${taskId}:`, error);
                     window.Telegram?.WebApp?.showAlert("Ad failed or skipped. No reward.");
                     const latestCount = currentUserAdTasks[taskId]?.completed || 0;
                     if (latestCount < config.limit) taskElement.classList.remove('disabled');
                 });
            } else if (config.adType === 'inAppInterstitial') {
                // In-App doesn't have a direct reward callback. Grant reward optimistically.
                console.warn("Using In-App Interstitial for a rewarded task. Reward is granted optimistically.");
                try {
                    // Show immediately, once per 24h (adjust as needed, though these settings might be ignored by SDK sometimes)
                    show_9292240({ type: 'inApp', inAppSettings: { frequency: 1, capping: 24, interval: 0, timeout: 0, everyPage: false } });
                    console.log(`In-App Interstitial initiated for task ${taskId}. Granting reward optimistically.`);
                    // Grant reward immediately after initiating the ad display for this type
                    grantReward();
                } catch (error) {
                     console.error(`In-App Interstitial Ad SDK failed to initiate for task ${taskId}:`, error);
                     window.Telegram?.WebApp?.showAlert("Ad failed to show.");
                     const latestCount = currentUserAdTasks[taskId]?.completed || 0;
                     if (latestCount < config.limit) taskElement.classList.remove('disabled');
                }

            } else { // Fallback for any unexpected types (though config should prevent this)
                console.error(`Unhandled adType '${config.adType}' for task ${taskId}`);
                window.Telegram?.WebApp?.showAlert("Unknown ad type configured for this task.");
                 const latestCount = currentUserAdTasks[taskId]?.completed || 0;
                 if (latestCount < config.limit) taskElement.classList.remove('disabled');
            }
        }


        // --- Game Object Creation ---
        function createStarfield() { if(starField)scene.remove(starField); const c=7000; const p=new Float32Array(c*3); const g=new THREE.BufferGeometry(); const h=parseColorHex(getCssVariable('--star-color')); for(let i=0;i<c;i++){ const i3=i*3; const r=60+Math.random()*60; const ph=Math.acos(-1+(2*Math.random())); const th=Math.random()*Math.PI*2; p[i3]=r*Math.sin(ph)*Math.cos(th); p[i3+1]=r*Math.cos(ph); p[i3+2]=r*Math.sin(ph)*Math.sin(th); } g.setAttribute('position',new THREE.BufferAttribute(p,3)); const m=new THREE.PointsMaterial({size:0.1,color:h,sizeAttenuation:true,transparent:true,opacity:0.8,depthWrite:false,blending:THREE.AdditiveBlending}); starField=new THREE.Points(g,m); starField.userData.isStarfield=true; starField.renderOrder=-1; starField.visible=!document.body.classList.contains('light-mode'); scene.add(starField); }
        function createBall() { if(ball)scene.remove(ball); const g=new THREE.SphereGeometry(0.25,32,32); const h=parseColorHex(getCssVariable('--ball-color')); const m=new THREE.MeshStandardMaterial({color:h,map:ballTexture,metalness:0.8,roughness:0.3,envMap:envMap,envMapIntensity:0.7}); ball=new THREE.Mesh(g,m); ball.userData.isBall=true; ball.position.set(ballStartX,initialBallY,ballStartZ); ballPreviousY=ball.position.y; scene.add(ball); }
        function createPoleSegment(y) { const h=platformSpacingY; const g=new THREE.CylinderGeometry(poleRadius,poleRadius,h,16); const c=parseColorHex(getCssVariable('--pole-color')); const m=new THREE.MeshStandardMaterial({color:c,roughness:0.6,metalness:0.2,transparent:true,opacity:1.0}); const s=new THREE.Mesh(g,m); s.position.y=y; s.userData={y:y,isPoleSegment:true,fadeOut:false,fadeProgress:0,material:m}; poleGroup.add(s); activePoleSegments[y]=s; }
        function createPlatform(y) { const p=new THREE.Group(); p.position.y=y; p.rotation.y=Math.random()*Math.PI*2; const circ=2*Math.PI; if(platformSegments<=0)return; const segAng=(circ-gapSize)/platformSegments; const gapSt=Math.random()*circ; const gapEnd=(gapSt+gapSize)%circ; const hasD=Math.random()<0.25; const dIdx=hasD?Math.floor(Math.random()*platformSegments):-1; const sCol=platformColorPalette[platformColorIndex%platformColorPalette.length]; platformColorIndex++; p.userData={y:y,isSafe:!hasD,segmentAngles:[],isPlatformGroup:true,gapStartAngle:gapSt,gapEndAngle:gapEnd,gapSize:gapSize,fadeOut:false,fadeProgress:0,colorHex:sCol}; const iR=poleRadius+0.05; const oR=platformRadius; let currAng=gapEnd; const dColH=parseColorHex(getCssVariable('--danger-color')); const dEmH=parseColorHex(getCssVariable('--danger-glow')); for(let i=0;i<platformSegments;i++){ const isD=(i===dIdx); const matOpts={roughness:isD?0.5:0.7,metalness:0.1,side:THREE.DoubleSide,transparent:true,opacity:1.0}; if(isD){matOpts.color=new THREE.Color(dColH);matOpts.emissive=new THREE.Color(dEmH);matOpts.emissiveIntensity=0.7;}else{matOpts.color=new THREE.Color(sCol);} const segMat=new THREE.MeshStandardMaterial(matOpts); const segGeo=new THREE.RingGeometry(iR,oR,32,1,0,segAng); segGeo.rotateX(-Math.PI/2); const segMesh=new THREE.Mesh(segGeo,segMat); segMesh.rotation.y=currAng; const sSt=currAng%circ; const sEnd=(currAng+segAng)%circ; const segDat={type:'platform_segment',isDanger:isD,parentPlatform:p,index:i,startAngle:sSt,endAngle:sEnd,mesh:segMesh,material:segMat}; p.userData.segmentAngles.push(segDat); segMesh.userData=segDat; p.add(segMesh); currAng=(currAng+segAng)%circ; } platformGroup.add(p); activePlatforms.push(p); }

        // --- Telegram Integration ---
        async function initializeTelegramIntegration() {
             hasProcessedReferral = false;
             // Use the actual Telegram WebApp object
             if (!window.Telegram?.WebApp) {
                 console.error("Telegram WebApp object not found!");
                 alert("Initialization Error: Could not connect to Telegram.");
                 gameState = 'error'; setInternalPause(true);
                 return Promise.reject("Telegram Env Missing");
             }
             const tg = window.Telegram.WebApp;
             return new Promise(async (resolve, reject) => {
                 try {
                     tg.ready();
                     console.log("TG Ready. Data:", tg.initDataUnsafe);
                     tg.expand();

                     if (tg.initDataUnsafe?.user?.id) {
                         telegramUserData = tg.initDataUnsafe.user;
                         telegramUserId = telegramUserData.id;
                         console.log("TG User:", telegramUserId, telegramUserData);

                         if(userIdOverlay) userIdOverlay.textContent = telegramUserId || 'N/A';
                         if(usernameOverlay) usernameOverlay.textContent = telegramUserData?.username ? `@${telegramUserData.username}` : '(Not Set)';

                         initializeFirebaseApp(); // Initialize Firebase after getting user ID
                         if (db) {
                             listenToUserData(telegramUserId); // Start listening to DB
                             await resetGame(); // Reset game state after DB connection established
                             // Small delay before zoom to ensure layout is stable
                             setTimeout(() => {
                                 onWindowResize(); // Ensure correct sizing
                                 animateCameraZoom(cameraZoomedInZ, cameraZoomDuration); // Zoom in
                                 resolve();
                             }, 150);
                         } else {
                             console.error("Firebase DB Initialization Failed!");
                             gameState='error'; setInternalPause(true);
                             tg.showAlert("Database connection error. Please try again later.");
                             reject("FB DB Error");
                         }
                     } else {
                         console.error("Telegram user ID missing!");
                         gameState='error'; setInternalPause(true);
                         tg.showAlert("Could not verify user information. Please relaunch the app.");
                         reject("TG User Missing");
                     }
                 } catch (e) {
                     console.error("Error during Telegram initialization:", e);
                     gameState='error'; setInternalPause(true);
                     alert("An error occurred during initialization. Please try reloading."); // Fallback alert
                     reject("TG Init Exception");
                 }
             });
         }

        // --- Core Game Initialization ---
        async function init() {
            console.log("Initializing App..."); gameState = 'initializing'; setInternalPause(true);
            scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 150); camera.position.z = cameraFixedZ; renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), antialias: true, alpha: true }); renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight); renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0; renderer.outputEncoding = THREE.sRGBEncoding; renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); renderer.setClearColor(0x000000, 0);
            setupTheme(); // Setup theme early
            composer = new EffectComposer(renderer); composer.addPass(new RenderPass(scene, camera)); bloomPass = new UnrealBloomPass(new THREE.Vector2(gameContainer.clientWidth, gameContainer.clientHeight), 0.6, 0.5, 0.8); composer.addPass(bloomPass);
            scene.add(new THREE.HemisphereLight(0xccccff, 0x555599, 0.7)); const dirLight = new THREE.DirectionalLight(0xffffff, 0.9); dirLight.position.set(5, 8, 6); scene.add(dirLight); scene.add(new THREE.AmbientLight(0x404040, 0.6));
            new RGBELoader().load('back.hdr', (t) => { t.mapping = THREE.EquirectangularReflectionMapping; scene.environment = t; envMap = t; if (ball?.material) ball.material.needsUpdate = true; }, undefined, e => console.warn("HDR load fail", e));
            textureLoader.load('ball.jpg', (t) => { t.wrapS = t.wrapT = THREE.RepeatWrapping; ballTexture = t; if (ball?.material) { ball.material.map = t; ball.material.needsUpdate = true; } }, undefined, e => console.warn("Ball tex fail.", e));
            createBall(); platformGroup = new THREE.Group(); scene.add(platformGroup); poleGroup = new THREE.Group(); scene.add(poleGroup);
            window.addEventListener('resize', onWindowResize, false); document.addEventListener('pointerdown', onPointerDown, { passive: false }); document.addEventListener('pointermove', onPointerMove, { passive: false }); document.addEventListener('pointerup', onPointerUp, false); document.addEventListener('pointerleave', onPointerUp, false);
            setupUIListeners();
            try {
                await initializeTelegramIntegration(); // Initialize TG and Firebase
                console.log("Telegram and Firebase Integration OK.");
                 onWindowResize(); // Ensure resize after everything is set up
                 animate(); // Start animation loop only after successful init
                 console.log("Initialization complete, starting animation.");
            } catch (e) {
                console.error("Critical initialization failure:", e);
                 // UI might show error state from initializeTelegramIntegration
                 // Ensure animation loop doesn't run if init failed
                 gameState = 'error';
                 setInternalPause(true);
                 // Optionally display a persistent error message on the screen
                 // gameContainer.innerHTML = "<p style='color:red; text-align:center; padding-top: 50px;'>Initialization Failed. Please reload.</p>";
                 return; // Stop further execution
            }
        }

        // --- UI Listeners Setup ---
         function setupUIListeners() {
             menuButton.addEventListener('click', (e) => { e.stopPropagation(); toggleSideMenu(); });
             settingsButton.addEventListener('click', (e) => { e.stopPropagation(); toggleSettingsPopup(); });
             menuItemButtons.forEach(b => { b.addEventListener('click', () => { const action = b.getAttribute('data-action'); closeSideMenu(); switch (action) { case 'show-profile': showOverlay(profileOverlay); break; case 'show-withdrawal': showOverlay(withdrawalOverlay); break; case 'show-friends': showOverlay(friendsOverlay); break; case 'show-tasks': showOverlay(tasksOverlay); break; case 'show-rewarded-tasks': showOverlay(rewardedTasksOverlay); break; } }); });
             overlayCloseButtons.forEach(b => { b.addEventListener('click', () => { const id = b.getAttribute('data-overlay-id'); const o = document.getElementById(id); if (o) hideOverlay(o); }); });
             document.addEventListener('click', (e) => { if (sideMenu.classList.contains('open') && !sideMenu.contains(e.target) && !menuButton.contains(e.target)) { closeSideMenu(); } if (settingsPopup.style.display === 'block' && !settingsPopup.contains(e.target) && !settingsButton.contains(e.target)) { closeSettingsPopup(); } });
             menuOverlayDimmer.addEventListener('click', closeSideMenu);
             settingsPopup.addEventListener('click', e => e.stopPropagation()); sideMenu.addEventListener('click', e => e.stopPropagation());
             profileOverlay.addEventListener('click', e => { if (!e.target.closest('.overlay-close-button')) e.stopPropagation(); });
             withdrawalOverlay.addEventListener('click', e => { if (!e.target.closest('.overlay-close-button') && !e.target.closest('button')) e.stopPropagation(); });
             friendsOverlay.addEventListener('click', e => { if (!e.target.closest('.overlay-close-button') && !e.target.closest('#referral-list-container') && !e.target.closest('#copy-referral-link-button')) e.stopPropagation(); });
             tasksOverlay.addEventListener('click', e => { if (!e.target.closest('.overlay-close-button') && !e.target.closest('a')) e.stopPropagation(); });
             rewardedTasksOverlay.addEventListener('click', e => { // Listener on the container
                 const taskItem = e.target.closest('.rewarded-ad-item');
                 if (taskItem && !taskItem.classList.contains('disabled')) {
                      e.stopPropagation(); // Prevent overlay close if clicking task
                     const taskId = taskItem.dataset.taskId;
                     const config = REWARDED_AD_TASKS_CONFIG[taskId];
                     if (taskId && config) { handleWatchRewardedAd(taskId, config.reward, taskItem); }
                      else { console.error("Missing data/config for clicked rewarded ad item", taskItem); }
                 } else if (!e.target.closest('.overlay-close-button')) { // Prevent closing if click is inside but not on task/close
                     e.stopPropagation();
                 }
             });
             if (gameOverUI) gameOverUI.addEventListener('click', e => e.stopPropagation());
             restartButton.addEventListener('click', resetGame);
             if (watchAdButton) watchAdButton.addEventListener('click', handleWatchAd); // Game Over Ad uses its own handler
             if (copyReferralLinkButton) { copyReferralLinkButton.addEventListener('click', async () => { const link = referralLinkDisplay.textContent; if (link && link !== "Generating link..." && link !== "Link Unavailable") { const success = await copyToClipboard(link); copyReferralLinkButton.textContent = success ? "Copied!" : "Failed"; if(success && window.Telegram?.WebApp) window.Telegram.WebApp.showAlert('Referral link copied!'); } else { copyReferralLinkButton.textContent = "Error"; } setTimeout(() => { copyReferralLinkButton.textContent = "Copy"; }, 1500); }); }
         }

        // --- Game Logic Functions ---
        function generatePlatforms() { if (!ball || !camera || internalPauseState || gameState !== 'playing') return; const generationTriggerY = nextPlatformY + platformSpacingY * 8; while (ball.position.y < generationTriggerY && nextPlatformY > -1000) { createPlatform(nextPlatformY); createPoleSegment(nextPlatformY); nextPlatformY -= platformSpacingY; } const removalThresholdY_Above = camera.position.y + 15; activePlatforms.forEach(p => { if (p.position.y > removalThresholdY_Above && !p.userData.fadeOut) startFadeOut(p); }); for (const yPos in activePoleSegments) { const seg = activePoleSegments[yPos]; if (parseFloat(yPos) > removalThresholdY_Above && seg && !seg.userData.fadeOut) startFadeOut(seg); } }
        function updateBallPosition() { if (!ball || internalPauseState || gameState !== 'playing') return; currentBallVelocityY += gravity; ball.position.y += currentBallVelocityY; ball.position.x = ballStartX; ball.position.z = ballStartZ; if (ball.position.y < nextPlatformY - platformSpacingY * 5) { handleGameOver(); } }
        function disposePlatformSegments(platform) { if (!platform) return; platform.traverse(object => { if (object.isMesh) { if (object.geometry) object.geometry.dispose(); if (object.material) { ['map', 'emissiveMap', 'aoMap', 'metalnessMap', 'roughnessMap', 'normalMap', 'displacementMap', 'alphaMap', 'envMap'].forEach(prop => { if (object.material[prop]?.dispose) object.material[prop].dispose(); }); if (Array.isArray(object.material)) { object.material.forEach(m => m.dispose()); } else { object.material.dispose(); } } } }); if (platform.parent) platform.parent.remove(platform); }
        function disposePoleSegment(yPos) { const segment = activePoleSegments[yPos]; if (segment) { if (segment.geometry) segment.geometry.dispose(); if (segment.material) segment.material.dispose(); if (segment.parent) segment.parent.remove(segment); delete activePoleSegments[yPos]; return true; } return false; }
        function startFadeOut(object) { if (!object || !object.userData || object.userData.fadeOut) return; object.userData.fadeOut = true; object.userData.fadeProgress = 0; }
        function destroyPlatformAndPole(platform) { if (!platform || !platform.userData || platform.userData.fadeOut) return; const platformY = platform.userData.y; if (!scoreIncrementedForPlatform[platformY]) { currentScore++; updateScoreUI(); scoreIncrementedForPlatform[platformY] = true; } startFadeOut(platform); const poleSegment = activePoleSegments[platformY]; if (poleSegment) startFadeOut(poleSegment); }
        function updateFadingObjects(deltaTime) { if (internalPauseState || gameState === 'error') return; const fadeSpeed = 1.0 / (FADE_DURATION / 1000); const platformsToRemoveIndexes = []; const poleYPositionsToRemove = []; for (let i = activePlatforms.length - 1; i >= 0; i--) { const p = activePlatforms[i]; if (p.userData.fadeOut) { p.userData.fadeProgress += fadeSpeed * deltaTime; const progress = Math.min(p.userData.fadeProgress, 1); const scale = 1.0 - progress * 0.5; p.scale.set(scale, 1, scale); p.userData.segmentAngles.forEach(segmentData => { if (segmentData.material) segmentData.material.opacity = 1.0 - progress; }); if (progress >= 1) platformsToRemoveIndexes.push(i); } } for (let i = platformsToRemoveIndexes.length - 1; i >= 0; i--) { const index = platformsToRemoveIndexes[i]; disposePlatformSegments(activePlatforms[index]); activePlatforms.splice(index, 1); } for (const y in activePoleSegments) { const segment = activePoleSegments[y]; if (segment?.userData.fadeOut) { segment.userData.fadeProgress += fadeSpeed * deltaTime; const progress = Math.min(segment.userData.fadeProgress, 1); if (segment.material) segment.material.opacity = 1.0 - progress; const scale = 1.0 - progress; segment.scale.set(scale, scale, scale); if (progress >= 1) poleYPositionsToRemove.push(parseFloat(y)); } } poleYPositionsToRemove.forEach(y => disposePoleSegment(y)); }
        function checkCollisions() { if (!ball || internalPauseState || gameState !== 'playing' || currentBallVelocityY >= 0) return; const ballRadius = 0.25; const ballBottomY = ball.position.y - ballRadius; let candidatePlatform = null; let highestCandidateY = -Infinity; for (let i = 0; i < activePlatforms.length; i++) { const platform = activePlatforms[i]; if (!platform || !platform.userData || platform.userData.fadeOut) continue; const platformSurfaceY = platform.position.y; if (ballPreviousY - ballRadius >= platformSurfaceY && ballBottomY <= platformSurfaceY) { if (platformSurfaceY > highestCandidateY) { highestCandidateY = platformSurfaceY; candidatePlatform = platform; } } } if (!candidatePlatform) return; const platformData = candidatePlatform.userData; const collisionY = platformData.y; const ballAngle = Math.atan2(ball.position.z - platformGroup.position.z, ball.position.x - platformGroup.position.x); const towerRotation = platformGroup.rotation.y; const platformInternalRotation = candidatePlatform.rotation.y; let angleRelativeToPlatform = THREE.MathUtils.euclideanModulo( ballAngle - towerRotation - platformInternalRotation, 2 * Math.PI ); const gapStart = platformData.gapStartAngle; const gapEnd = platformData.gapEndAngle; let isInGap; if (gapStart < gapEnd) { isInGap = angleRelativeToPlatform >= gapStart && angleRelativeToPlatform < gapEnd; } else { isInGap = angleRelativeToPlatform >= gapStart || angleRelativeToPlatform < gapEnd; } const ballDistFromCenter = Math.hypot(ball.position.x, ball.position.z); const isInsidePoleRadius = ballDistFromCenter < poleRadius; if (isInGap || isInsidePoleRadius) { destroyPlatformAndPole(candidatePlatform); } else { let hitSegmentData = null; for (const segmentData of platformData.segmentAngles) { let segStart = segmentData.startAngle; let segEnd = segmentData.endAngle; let angleFallsInSegment; if (segStart < segEnd) { angleFallsInSegment = angleRelativeToPlatform >= segStart && angleRelativeToPlatform < segEnd; } else { angleFallsInSegment = angleRelativeToPlatform >= segStart || angleRelativeToPlatform < segEnd; } if (angleFallsInSegment) { hitSegmentData = segmentData; break; } } if (hitSegmentData) { if (hitSegmentData.isDanger) { lastSafePlatformY = collisionY - platformSpacingY; handleGameOver(); startShake(0.7); } else { lastSafePlatformY = collisionY; ball.position.y = collisionY + ballRadius + 0.01; currentBallVelocityY = bounceSpeed; Object.keys(scoreIncrementedForPlatform).forEach(keyY => { if (parseFloat(keyY) < collisionY) delete scoreIncrementedForPlatform[keyY]; }); startShake(0.3); } } else { console.warn("Collision: Not in gap, but no segment hit?"); destroyPlatformAndPole(candidatePlatform); } } }
        function handleGameOver() { if (gameState !== 'playing') return; console.log("Game Over!"); gameState = 'gameOver'; setInternalPause(true); finalScoreEl.textContent = formatNumber(currentScore); gameOverMessageP.innerHTML = `Score: <span id="final-score">${formatNumber(currentScore)}</span>`; gameOverUI.style.display = 'block'; if (restartButton) restartButton.disabled = false; if (watchAdButton) { if (telegramUserId && currentScore > 0) { watchAdButton.style.display = 'block'; watchAdButton.disabled = false; } else { watchAdButton.style.display = 'none'; } } startShake(0.5); }
        // Game Over Ad Handler (uses the standard rewarded interstitial)
        function handleWatchAd() {
            if (gameState !== 'gameOver' || !telegramUserId || currentScore <= 0) return;
            if (typeof show_9292240 !== 'function') {
                window.Telegram?.WebApp?.showAlert("Ad SDK not ready. Please try again later.");
                return;
            }

            console.log("Watch Ad & Save clicked.");
            if (restartButton) restartButton.disabled = true;
            if (watchAdButton) watchAdButton.disabled = true;
            gameOverMessageP.textContent = `Loading Ad...`;

            // Use the default rewardedInterstitial call for the game over save
            show_9292240().then(() => {
                 console.log("Ad watched successfully (Game Over). Saving score...");
                 updateUserTotalScore(currentScore).then(() => {
                     console.log("Score save OK via Ad.");
                     let adCountdown = 3;
                     gameOverMessageP.textContent = `Score Saved! Restarting in ${adCountdown}s`;
                     adTimerIntervalId = setInterval(() => {
                         adCountdown--;
                         if (adCountdown > 0) { gameOverMessageP.textContent = `Score Saved! Restarting in ${adCountdown}s`; }
                         else { clearInterval(adTimerIntervalId); adTimerIntervalId = null; console.log("Ad timer finish. Restarting."); resetGame(); }
                     }, 1000);
                 }).catch((error) => {
                     console.error("Failed score save after Ad:", error);
                     gameOverMessageP.textContent = "Error saving score. Please restart.";
                     if (restartButton) restartButton.disabled = false;
                     if (watchAdButton) watchAdButton.disabled = false; // Re-enable if save failed
                     if (adTimerIntervalId) { clearInterval(adTimerIntervalId); adTimerIntervalId = null; }
                 });
            }).catch((error) => {
                 console.error("Ad failed to show (Game Over):", error);
                 window.Telegram?.WebApp?.showAlert("Ad failed to load or was skipped. Score not saved.");
                 gameOverMessageP.innerHTML = `Score: <span id="final-score">${formatNumber(currentScore)}</span>`; // Restore score display
                 if (restartButton) restartButton.disabled = false;
                 if (watchAdButton) watchAdButton.disabled = false; // Re-enable ad button
            });
        }
        function startShake(intensity) { shakeIntensity = Math.max(shakeIntensity, intensity); }
        async function resetGame() {
             console.log("Resetting game..."); if (adTimerIntervalId) { clearInterval(adTimerIntervalId); adTimerIntervalId = null; }
             // Don't reset if no user ID (implies init failed)
             if (!telegramUserId) {
                 console.warn("Cannot reset game: No Telegram User ID available.");
                 // Ensure UI is closed and game state reflects error/init state
                 gameOverUI.style.display = 'none';
                 closeAllOverlays();
                 closeSideMenu();
                 closeSettingsPopup();
                 if(gameState !== 'error') gameState = 'initializing'; // Or 'error' if that's more accurate
                 setInternalPause(true);
                 return;
             }

             console.log("Resetting for user:", `tg_${telegramUserId}`);
             if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId);
             cameraZoomRequestId = null; isCameraZooming = false;

             if (!ball) createBall(); else { const ballColorHex = parseColorHex(getCssVariable('--ball-color')); ball.material.color.setHex(ballColorHex); } ball.position.set(ballStartX, initialBallY, ballStartZ); ballPreviousY = ball.position.y; currentBallVelocityY = 0;

             // Clear existing game objects more reliably
             activePlatforms.forEach(p => disposePlatformSegments(p));
             activePlatforms = [];
             if (platformGroup) { while(platformGroup.children.length > 0) platformGroup.remove(platformGroup.children[0]); platformGroup.rotation.y = 0; } else { platformGroup = new THREE.Group(); scene.add(platformGroup); }

             Object.keys(activePoleSegments).forEach(y => disposePoleSegment(parseFloat(y)));
             activePoleSegments = {};
             if (poleGroup) { while(poleGroup.children.length > 0) poleGroup.remove(poleGroup.children[0]); } else { poleGroup = new THREE.Group(); scene.add(poleGroup); }

             currentScore = 0; updateScoreUI(); scoreIncrementedForPlatform = {}; platformColorIndex = 0; shakeIntensity = 0; nextPlatformY = initialBallY - platformSpacingY * 2; lastSafePlatformY = nextPlatformY + platformSpacingY;

             // Generate initial platforms
             for (let i = 0; i < 15; i++) { createPlatform(nextPlatformY); createPoleSegment(nextPlatformY); nextPlatformY -= platformSpacingY; }

             gameOverUI.style.display = 'none'; // Hide game over UI
             closeAllOverlays(); // Ensure all overlays are closed
             closeSideMenu();
             closeSettingsPopup();

             // Reset camera position and lookAt
             if (camera && ball) { const camY = ball.position.y + cameraVerticalOffset; const lookY = ball.position.y + cameraLookAtOffset; camera.position.set(0, camY, camera.position.z); // Keep current Z if needed, or reset to cameraFixedZ? Resetting might be better. camera.position.z = cameraFixedZ; camera.lookAt(0, lookY, 0); }

             gameState = 'playing'; setInternalPause(false); console.log("Reset complete. Game state:", gameState);
             animateCameraZoom(cameraZoomedInZ, cameraZoomDuration); // Zoom in again after reset
             setTimeout(onWindowResize, 50); // Adjust size after objects are added
        }


        // --- Input Handling ---
        function onPointerDown(e){
            let target = e.target; let isUI = false;
            // Simplified UI check - if the target is anywhere *but* the game canvas, treat it as UI
             if (target !== renderer?.domElement) {
                 isUI = true;
                 // Allow clicks on specific interactive UI elements even if they overlap canvas slightly
                 if (target.closest('button') || target.closest('a') || target.closest('input') || target.closest('.theme-switch') || target.closest('.rewarded-ad-item:not(.disabled)') || target.closest('#copy-referral-link-button')) {
                     // Let these events proceed normally
                 } else {
                     // Prevent game interaction if clicking on general UI areas
                 }
             } else if (isAnyUIOverlayOpen() || gameState !== 'playing') {
                  // If canvas clicked but UI is open or game not playing, ignore for game control
                  isUI = true;
             }

             // Prevent default touch actions only if it's a game interaction on the canvas
             if (!isUI && e.touches && gameContainer.contains(target) && e.cancelable) {
                 e.preventDefault();
             }

            if (isUI || gameState !== 'playing') { isPointerDown = false; return; } // Don't start grab if UI click or game not active
            isPointerDown = true; previousPointerX = e.clientX ?? e.touches?.[0]?.clientX; if (previousPointerX === undefined) { isPointerDown = false; return; } // Safety check
            document.body.style.cursor = 'grabbing';
        }
        function onPointerMove(e){ if (!isPointerDown || internalPauseState || gameState !== 'playing') return; const currentX = e.clientX ?? e.touches?.[0]?.clientX; if (currentX === undefined) return; // Safety check
            const deltaX = currentX - previousPointerX; if (platformGroup) { platformGroup.rotation.y += deltaX * rotationSensitivity; } previousPointerX = currentX; if (e.cancelable && e.touches) { e.preventDefault(); } // Prevent scroll during drag
        }
        function onPointerUp(e){ if (isPointerDown) { isPointerDown = false; document.body.style.cursor = 'default'; } }

        // --- Window Resize ---
        function onWindowResize() { if (!camera || !renderer || !gameContainer || !composer) return; const w = gameContainer.clientWidth; const h = gameContainer.clientHeight; if (w > 0 && h > 0) { camera.aspect = w / h; camera.updateProjectionMatrix(); renderer.setSize(w, h); composer.setSize(w, h); } }

        // --- Camera Zoom ---
        function animateCameraZoom(targetZ, duration) { if (!camera || isCameraZooming) return; if (cameraZoomRequestId) cancelAnimationFrame(cameraZoomRequestId); isCameraZooming = true; const startZ = camera.position.z; const startTime = performance.now(); function step(now) { const elapsed = now - startTime; const prog = Math.min(elapsed / duration, 1); const ease = t => t * (2 - t); const newZ = startZ + (targetZ - startZ) * ease(prog); camera.position.z = newZ; if (prog < 1) { cameraZoomRequestId = requestAnimationFrame(step); } else { camera.position.z = targetZ; isCameraZooming = false; cameraZoomRequestId = null; } } cameraZoomRequestId = requestAnimationFrame(step); }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate); const dt = clock.getDelta();
            // Only run game updates if not initializing or in error state
            if (gameState !== 'initializing' && gameState !== 'error') {
                if (starField && starField.visible) starField.rotation.y += dt * 0.01;
                let camY = camera ? camera.position.y : (initialBallY + cameraVerticalOffset);
                let lookY = ball ? (ball.position.y + cameraLookAtOffset) : (initialBallY + cameraLookAtOffset);

                // Game logic updates only when playing and not paused internally
                if (!internalPauseState && gameState === 'playing') {
                     updateBallPosition();
                     checkCollisions();
                     generatePlatforms();
                     updateFadingObjects(dt);
                     if (ball) { ballPreviousY = ball.position.y; } // Update previous Y after position update
                }

                // Camera follow logic (runs even if paused, but based on last ball position)
                 if (ball && camera) {
                     const targetCamY = ball.position.y + cameraVerticalOffset;
                     // Lerp smoothly, but allow instant drop if ball falls fast
                     const lerpedY = THREE.MathUtils.lerp(camera.position.y, targetCamY, cameraFollowLerpFactor);
                     // Only lerp upwards or if ball is moving up significantly. Snap down if ball falls below current view.
                      if (lerpedY > camera.position.y || (!internalPauseState && currentBallVelocityY > 0.01) || targetCamY > camera.position.y) {
                          camY = lerpedY;
                      } else if (targetCamY < camera.position.y - 1.0) { // Add a small buffer before snapping down instantly
                          camY = targetCamY;
                      } else {
                          // Keep camera stable if ball is falling slowly within view
                          camY = camera.position.y;
                      }
                      // Prevent camera from going too low during init or reset issues
                      camY = Math.max(camY, nextPlatformY + cameraVerticalOffset - platformSpacingY * 10); // Limit how far down it can look initially

                     lookY = ball.position.y + cameraLookAtOffset;
                     lookY = Math.max(lookY, camY - cameraVerticalOffset + cameraLookAtOffset); // Ensure lookAt isn't below camera base
                 }

                 // Apply shake effect
                let shakeX = 0, shakeY = 0; if (shakeIntensity > 0.01) { shakeX = (Math.random() - 0.5) * 2 * maxShakeOffset * shakeIntensity; shakeY = (Math.random() - 0.5) * 2 * maxShakeOffset * shakeIntensity; if (!internalPauseState) { shakeIntensity *= shakeDecreaseFactor; } } else { shakeIntensity = 0; }
                if (camera) { camera.position.y = camY + shakeY; camera.position.x = 0 + shakeX; camera.lookAt(0 + shakeX, lookY + shakeY, 0); }
            }
            // Render the scene
            if (composer) { composer.render(dt); } else if (renderer && scene && camera) { renderer.render(scene, camera); }
        }

        // --- Start ---
        // Initialize on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', init);

    </script>

</body>
</html>
